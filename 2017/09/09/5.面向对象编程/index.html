<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Python基础," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="面向对象编程.md#面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设">
<meta name="keywords" content="Python基础">
<meta property="og:type" content="article">
<meta property="og:title" content="5. 面向对象编程">
<meta property="og:url" content="http://yoursite.com/2017/09/09/5.面向对象编程/index.html">
<meta property="og:site_name" content="小黄">
<meta property="og:description" content="面向对象编程.md#面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/img/1474869010884.png">
<meta property="og:updated_time" content="2017-09-09T10:11:13.179Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="5. 面向对象编程">
<meta name="twitter:description" content="面向对象编程.md#面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设">
<meta name="twitter:image" content="http://yoursite.com/img/1474869010884.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/09/09/5.面向对象编程/"/>





  <title>5. 面向对象编程 | 小黄</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小黄</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">黄小黄的幸福生活！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-java">
          <a href="/Java/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Java
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/09/5.面向对象编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">5. 面向对象编程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-09T15:30:31+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="面向对象编程-md-面向对象编程"><a href="#面向对象编程-md-面向对象编程" class="headerlink" title="面向对象编程.md#面向对象编程"></a>面向对象编程.md#面向对象编程</h1><p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>
<p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
<p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发来的消息并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类Class的概念。</p>
<p>我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。假定我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; std1=&#123;&apos;name&apos;: &apos;Michael&apos;, &apos;score&apos;: 98 &#125;</div><div class="line">&gt;&gt;&gt; std2=&#123;&apos;name&apos;: &apos;Bob&apos;, &apos;score&apos;: 82 &#125;</div></pre></td></tr></table></figure>
<p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def print_score(std):</div><div class="line">...     print(&apos;%s: %s&apos; %(std[&apos;name&apos;], std[&apos;score&apos;]))</div><div class="line">...</div><div class="line">&gt;&gt;&gt; print_score(std1)</div><div class="line">Michael: 98</div></pre></td></tr></table></figure>
<p>如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是student这种数据类型应该被视为一个对象，这个对象拥有自己<code>name</code>和<code>score</code>两个属性。如果要打印一个同学的成绩，必须创建出这个学生对应的对象，然后给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line"></div><div class="line">...     def __init__(self, name, score):</div><div class="line">...             self.name=name</div><div class="line">...             self.score=score</div><div class="line"></div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s: %s&apos; %(self.name, self.score))</div><div class="line">...</div></pre></td></tr></table></figure>
<p>给对象发消息实际上就是调用对象的相关函数，我们称之为对象的方法Method，面向对象的程序写出来就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,59)</div><div class="line">&gt;&gt;&gt; lisa=Student(&apos;Lisa Simpson&apos;,89)</div><div class="line">&gt;&gt;&gt; bart.print_score()</div><div class="line">Bart Simpson: 59</div><div class="line">&gt;&gt;&gt; lisa.print_score()</div><div class="line">Lisa Simpson: 89</div></pre></td></tr></table></figure>
<p>面向对象的设计思想是从自然界中来的，因为在自然界中，类Class和实例Instance的概念是很自然的。Class是一种抽象概念，比如我们定义的Class—Student，是指学生这个概念，而实例Instance则是一个个具体的Student。</p>
<p>所以面向对象的抽象程度又比函数要高，因为一个Class即包含数据又包含操作数据的方法。</p>
<p><strong>数据封装，继承和多态是面向对象的三大特点。</strong></p>
<h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><p>面向对象最重要的概念就是类Class和实例Instance，必须牢记类是抽象的模板，实例是根据类创建出来的一个个具体的对象，每个对象都拥有相同的方法，但是各自的数据可能不同。</p>
<p>仍以Student类为例，在Python中，定义类是通过<code>class</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     pass</div><div class="line">...</div></pre></td></tr></table></figure>
<p><code>class</code>后面紧跟着类名，即Student，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面会讲，通常，如果没有合适的继承类，就是用object类，这是所有类都会继承的类。</p>
<p>定义好了<code>Student</code>类，就可以根据<code>Student</code>类创建出<code>Student</code>实例，创建实例是通过类名+()来实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart=Student()</div><div class="line">&gt;&gt;&gt; bart</div><div class="line">&lt;__main__.Student object at 0x000002C2CE396160&gt;</div><div class="line">&gt;&gt;&gt; Student</div><div class="line">&lt;class &apos;__main__.Student&apos;&gt;</div></pre></td></tr></table></figure>
<p>可以看到，变量<code>bart</code>指向的就是一个<code>Student</code>的实例，后面的0x000002C2CE396160是内存地址，每个object的地址都不一样，而<code>Student</code>本身则是一个类，可以自由的给一个实例变量绑定属性，比如，给实例<code>bart</code>绑定一个name属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart.name=&apos;Bart Simpson&apos;</div><div class="line">&gt;&gt;&gt; bart.name</div><div class="line">&apos;Bart Simpson&apos;</div></pre></td></tr></table></figure>
<p>由于类可以起到模板的作用，因此在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>的方法，在创建实例的时候，就把<code>name</code>,<code>score</code>等属性绑定上去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.name=name</div><div class="line">...             self.score=score</div><div class="line">...</div></pre></td></tr></table></figure>
<p>注意到<code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身，因此，在<code>__init__</code>方法的内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器会自己把实例变量传进去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,98)</div><div class="line">&gt;&gt;&gt; bart.name</div><div class="line">&apos;Bart Simpson&apos;</div><div class="line">&gt;&gt;&gt; bart.score</div><div class="line">98</div><div class="line">&gt;&gt;&gt; bart</div><div class="line">&lt;__main__.Student object at 0x000002C2CE396278&gt;</div></pre></td></tr></table></figure></p>
<p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数的没有什么区别，仍然可以使用默认参数，可变参数，关键字参数和命名关键字参数。</p>
<h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><p>面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def print_score(std):</div><div class="line">...     print(&apos;%s:%s &apos; % (std.name,std.score))</div><div class="line">...</div><div class="line">&gt;&gt;&gt; print_score(bart)</div><div class="line">Bart Simpson:98</div></pre></td></tr></table></figure></p>
<p>但是，既然<code>Student</code>实例本身就拥有这些数据，要访问这些数据就没有必要从外面的函数去访问，可以直接在<code>Student</code>类的内部定义访问数据的函数，这样，就把数据给封装起来了。这些封装数据的函数和<code>Student</code>类本身是关联的，我们称之为类的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.name=name</div><div class="line">...             self.score=score</div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s:%s&apos; %(self.name,self.score))</div><div class="line">...</div><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,98)</div><div class="line">&gt;&gt;&gt; bart.print_score()</div><div class="line">Bart Simpson:98</div></pre></td></tr></table></figure>
<p>这样一来，我们从外部看<code>Student</code>类，就只需要知道，创建实例需要给出<code>name</code>和<code>score</code>，而如何打印，都是在<code>Student</code>类的内部定义的，这些数据和逻辑被封装起来了，调用很容易但是不知道内部实现的细节。</p>
<p>封装的另一个好处是可以给<code>Student</code>类增加新的方法，比如<code>get_grade</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.name=name</div><div class="line">...             self.score=score</div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s:%s&apos; %(self.name,self.score))</div><div class="line">...     def get_grade(self):</div><div class="line">...             if self.score&gt;=90:</div><div class="line">...                     return &apos;A&apos;</div><div class="line">...             elif self.score&gt;=80:</div><div class="line">...                     return &apos;B&apos;</div><div class="line">...             else:</div><div class="line">...                     return &apos;C&apos;</div><div class="line">...</div><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,98)</div><div class="line">&gt;&gt;&gt; bart.get_grade()</div><div class="line">&apos;A&apos;</div></pre></td></tr></table></figure></p>
<p><code>get_grade</code>方法可以直接在实例变量上调用不需要知道内部的实现细节。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>类是创建实例的模板，而实例则是一个个具体的对象，各个实例拥有的数据都相互独立，互不影响；方法就是与实例绑定的函数和普通函数不同，方法可以直接访问实例的数据；通过在实例上调用 的方法，我们就直接操作了对象内部的数据，也就是说，对于两个实例变量，虽然他们都是同一个类的不同实例，但拥有的变量名称可能不同。</p>
<h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。但是，从前面Student来看，外部代码还是可以自由修改一个实例的name、score属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart.score</div><div class="line">98</div><div class="line">&gt;&gt;&gt; bart.score=69</div><div class="line">&gt;&gt;&gt; bart.score</div><div class="line">69</div><div class="line">&gt;&gt;&gt; bart.get_grade</div><div class="line">&lt;bound method Student.get_grade of &lt;__main__.Student object at 0x000002C2CE3966A0&gt;&gt;</div><div class="line">&gt;&gt;&gt; bart.get_grade()</div><div class="line">&apos;C&apos;</div></pre></td></tr></table></figure>
<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在python中，实例的变量名如果以<code>__</code>开头，就变为了一个私有变量private，只有内部可以访问，外部不可以访问，我们把student类改一改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.__name=name</div><div class="line">...             self.__score=score</div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s: %s&apos; %(self.__name,self.__score))</div><div class="line">...</div></pre></td></tr></table></figure>
<p>改完后，对于外部代码来说没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,99)</div><div class="line">&gt;&gt;&gt; bart.__name</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;__name&apos;</div></pre></td></tr></table></figure></p>
<p>这样就确保了外部代码不能随便修改内部的状态，这样通过访问限制的保护，代码更加稳定。但是如果外部代码要取得name和score怎么办？可以给Student类增加<code>get_name</code>,<code>get_score</code>的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.__name=name</div><div class="line">...             self.__score=score</div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s: %s&apos; %(self.__name,self.__score))</div><div class="line">...     def get_name(self):</div><div class="line">...             return self.__name</div><div class="line">...     def get_score(self):</div><div class="line">...             return self.__score</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>如果要允许外部代码修改score怎么办，需要给Student类增加<code>set_score</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.__name=name</div><div class="line">...             self.__score=score</div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s: %s&apos; %(self.__name,self.__score))</div><div class="line">...     def get_name(self):</div><div class="line">...             return self.__name</div><div class="line">...     def get_score(self):</div><div class="line">...             return self.__score</div><div class="line">...     def set_score(self,score):</div><div class="line">...             self.__score=score</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>与原来直接通过<code>bart.score=90</code>相比，在方法中，可以对参数做检查，避免传入无效的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.__name=name</div><div class="line">...             self.__score=score</div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s: %s&apos; %(self.__name,self.__score))</div><div class="line">...     def get_name(self):</div><div class="line">...             return self.__name</div><div class="line">...     def get_score(self):</div><div class="line">...             return self.__score</div><div class="line">...     def set_score(self,score):</div><div class="line">...             if 0&lt;=score&lt;=100:</div><div class="line">...                     self.__score=score</div><div class="line">...             else:</div><div class="line">...                     raise ValueError(&apos;bad score&apos;)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以下划线结尾的，是特殊百年来那个，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>这样的变量名。<br>而以一个下划线开头的实例变量名，比如<code>_name</code>这样的实例变量外部是可以访问的，但是一般不随便访问此类实例。<br>双下划线开头的实例变量也不是一定不能从外部访问的，不能直接访问<code>__name</code>是因为Python解释器对外吧<code>__name</code>变量改为了<code>_Student__</code>,所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,99)</div><div class="line">&gt;&gt;&gt; bart._Student__name</div><div class="line">&apos;Bart Simpson&apos;</div></pre></td></tr></table></figure>
<p>但是强烈建议你不要这么做，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名。总的来说就是Python本身没有任何机制阻止你干坏事，全靠自觉。</p>
<p>最后注意下面这种错误写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,99)</div><div class="line">&gt;&gt;&gt; bart.get_name()</div><div class="line">&apos;Bart Simpson&apos;</div><div class="line">&gt;&gt;&gt; bart.__name=&apos;fsfd&apos;</div><div class="line">&gt;&gt;&gt; bart.__name</div><div class="line">&apos;fsfd&apos;</div><div class="line">&gt;&gt;&gt; bart.get_name()</div><div class="line">&apos;Bart Simpson</div></pre></td></tr></table></figure></p>
<p>表面上看，外部代码‘成功’的设置了<code>__name</code>变量，但是实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量不是一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给bart增加了一个<code>__name</code>变量。</p>
<hr>
<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subcalss），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>
<p>比如，我们已经编写了一个名为<code>Animal</code>的class，有一个<code>run()</code>方法可以直接打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Animal(object):</div><div class="line">...     def run(self):</div><div class="line">...             print(&apos;Animal is running...&apos;)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>当我们需要编写<code>Dog</code>和<code>Cat</code>类时，就可以直接从<code>Animal</code>类继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Dog(Animal):</div><div class="line">...     pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; class Cat(Animal):</div><div class="line">...     pass</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>对于<code>Dog</code>来说，<code>Animal</code>就是它的父类，对于<code>Animal</code>来说，<code>Dog</code>就是它的子类。</p>
<p>继承最大的好处是获得了父类的全部功能。由于<code>Animal</code>实现了<code>run()</code>方法，因此，<code>Dog</code>和<code>Cat</code>作为他的子类，自动拥有了<code>run()</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; dog=Dog()</div><div class="line">&gt;&gt;&gt; dog.run()</div><div class="line">Animal is running...</div></pre></td></tr></table></figure></p>
<p>也可以对子类增加一些方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Dog(Animal):</div><div class="line">...     def run(self):</div><div class="line">...             print(&apos;Dog is running...&apos;)</div><div class="line">...     def eat(self):</div><div class="line">...             print(&apos;Dog is eating...&apos;)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; dog=Dog()</div><div class="line">&gt;&gt;&gt; dog.eat()</div><div class="line">Dog is eating...</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>继承的第二个好处需要我们队代码进行一点改进。当子类和父类存在相同的<code>run()</code>方法时，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。</p>
<p>要理解什么事多态，我们首先要对数据类型再做一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么区别：</p>
<pre><code>&gt; a=list() a是list的数据类型
    b=Animal()                       b是Animal的数据类型
    c=Dog()                            c是Dog的数据类型
</code></pre><p>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; isinstance(a,list)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(b,Animal)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(c,Animal)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(b,Dog)</div><div class="line">False</div></pre></td></tr></table></figure></p>
<p>可以看出<code>a</code>,<code>b</code>,<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这三种类型。而且<code>c</code>还对应着<code>Animal</code>类型。在继承关系中，如果一个实例的数据类型是某个子类，那他的数据类型可以看做是父类。但是反过来就不行。</p>
<p>为了更好的理解多态，我们还需要再编写一个函数，这个函数可以接受一个<code>Animal</code>类型的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def run_twice(animal):</div><div class="line">...     animal.run()</div><div class="line">...     animal.run()</div></pre></td></tr></table></figure></p>
<p>当我们传入<code>Animal</code>的实例时，<code>run_twice()</code>就会打印出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; run_twice(Animal())</div><div class="line">Animal is running...</div><div class="line">Animal is running...</div></pre></td></tr></table></figure></p>
<p>当我们传入<code>Dog</code>实例时，<code>run_twice()</code>就打印出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; run_twice(Dog())</div><div class="line">Dog is running...</div><div class="line">Dog is running...</div></pre></td></tr></table></figure></p>
<p>看上去没什么，但是当我们再定义一个<code>Tortoise</code>类型，也从<code>Animal</code>派生：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Tortoise(Animal):</div><div class="line">...     def run(self):</div><div class="line">...             print(&apos;Tortoise is running slowly...&apos;)</div></pre></td></tr></table></figure></p>
<p>当我们调用<code>run_twice()</code>时，传入<code>Tortoise</code>的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; run_twice(Tortoise())</div><div class="line">Tortoise is running slowly...</div><div class="line">Tortoise is running slowly...</div></pre></td></tr></table></figure></p>
<p>可以看出，新增一个<code>Animal</code>的子类，不必对<code>run_twice()</code>进行任何修改，实际上，任何依赖<code>Animal</code>作为参数的函数或方法都可以不加修改的正常运行，原因就在于多态。<br>多态的好处就是当我们需要传入<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……时，我们只需要接收<code>Animal</code>类型就可以，因为前面三者都是<code>Animal</code>类型，然后按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就可以自动调用实际类型的<code>run()</code>方法。<br>对于一个变量，我们只需要知道他是<code>Animal</code>类型，无需确切的知道他的子类型，就可以放心的调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>就是由运行时该对象的确切类型决定，也就是说多态调用中：调用方只管调用，不管细节，而当我们新增一种<code>Aniaml</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调节的，这就是著名的<code>开闭</code>原则：</p>
<blockquote>
<p>对扩展开放：允许新增<code>Animal</code>的子类；<br>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。<br>继承还可以一级一级的继承下来，就好比从爷爷到爸爸再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的数。<br><img src="/img/1474869010884.png" alt="Alt text"><br>静态语言vs动态语言</p>
<blockquote>
<p>对于静态语言来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。<br>对于Python这样的静态语言来说，则不一定需要传入<code>Animal</code>类型，我们只需要保证传入的对象有一个<code>run()</code>方法就可以。</p>
</blockquote>
</blockquote>
<p>这就是动态语言的‘鸭子类型’，它并不要求严格的继承体系，一个对象只要看起来像押走，走起路来像鸭子，那他就可以被看做是鸭子。<br>Python的“file-like object”就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>的方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都可以被视为“file-like object”。许多函数接收的参数就是“file-like object”，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p>
<hr>
<h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><p>当我们拿到一个对象的引用时，如何知道这个对象是什么类型，有哪些方法？</p>
<h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><p>首先，我们判断对象类型，使用<code>type()</code>函数，基本类型都可以用<code>type()</code>判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; type(123)</div><div class="line">&lt;class &apos;int&apos;&gt;</div><div class="line">&gt;&gt;&gt; type(&apos;123&apos;)</div><div class="line">&lt;class &apos;str&apos;&gt;</div><div class="line">&gt;&gt;&gt; type(None)</div><div class="line">&lt;class &apos;NoneType&apos;&gt;</div></pre></td></tr></table></figure>
<p>如果一个变量指向函数或者类，也可以用<code>type()</code>来判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; type(abs)</div><div class="line">&lt;class &apos;builtin_function_or_method&apos;&gt;</div><div class="line">&gt;&gt;&gt; type(a)</div><div class="line">&lt;class &apos;list&apos;&gt;</div><div class="line">&gt;&gt;&gt; type(c)</div><div class="line">&lt;class &apos;__main__.Dog&apos;&gt;</div></pre></td></tr></table></figure>
<p>但是<code>type()</code>函数返回的是什么类型呢？它返回对应的Class类型。如果我们要在<code>if</code>语句中判断，就需要比较两个变量的type类型是否相同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; type(123)==type(456)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type(123)==int</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type(&apos;123&apos;)==type(&apos;abc&apos;)</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>判断基本数据类型可以直接写<code>int</code>、<code>str</code>等，但如果要判断一个对象是否是函数时，可以使用<code>types</code>模块中定义的常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import types</div><div class="line">&gt;&gt;&gt; def fn():</div><div class="line">...     pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; type(fn)==types.FunctionType</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type(lambda x:x)==types.LambdaType</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType</div><div class="line">True</div></pre></td></tr></table></figure></p>
<h3 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h3><p>对于class的继承关系来说，使用<code>type()</code>就很不方便。我们要判断class的类型，可以使用<code>isinstance()</code>函数。<br>继承关系为：object-&gt;Animal-&gt;Dog-&gt;Husky，那么<code>isinstance()</code>就可以告诉我们一个对象是否是某种类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a=Animal()</div><div class="line">&gt;&gt;&gt; b=Dog()</div><div class="line">&gt;&gt;&gt; c=Husky()</div><div class="line">&gt;&gt;&gt; isinstance(c,Husky)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(c,Dog)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(c,Animal)</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>可以看出虽然c自身是Husky类型，但由于Husky是从Dog上继承下来的，所以c还是Dog类型。也就是说，<code>isinstance()</code>判断的是一个对象是否是该类型本身或者位于该类型的父继承链上。能用<code>type()</code>判断的类型都可以用<code>isinstance()</code>判断，并且还可以判断一个变量是否是某些类型中的一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; isinstance(&apos;a&apos;,str)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(123,int)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance([1,2,3],(list,tuple))</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance((1,2,3),(list,tuple))</div><div class="line">True</div></pre></td></tr></table></figure></p>
<h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; dir(&apos;123&apos;)</div><div class="line">[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__getnewargs__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rmod__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;, &apos;center&apos;, &apos;count&apos;, &apos;encode&apos;, &apos;endswith&apos;, &apos;expandtabs&apos;, &apos;find&apos;, &apos;format&apos;, &apos;format_map&apos;, &apos;index&apos;, &apos;isalnum&apos;, &apos;isalpha&apos;, &apos;isdecimal&apos;, &apos;isdigit&apos;, &apos;isidentifier&apos;, &apos;islower&apos;, &apos;isnumeric&apos;, &apos;isprintable&apos;, &apos;isspace&apos;, &apos;istitle&apos;, &apos;isupper&apos;, &apos;join&apos;, &apos;ljust&apos;, &apos;lower&apos;, &apos;lstrip&apos;, &apos;maketrans&apos;, &apos;partition&apos;, &apos;replace&apos;, &apos;rfind&apos;, &apos;rindex&apos;, &apos;rjust&apos;, &apos;rpartition&apos;, &apos;rsplit&apos;, &apos;rstrip&apos;, &apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;, &apos;swapcase&apos;, &apos;title&apos;, &apos;translate&apos;, &apos;upper&apos;, &apos;zfill&apos;]</div></pre></td></tr></table></figure></p>
<p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动调用该对象的<code>__len__</code>方法，所以下面代码是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; len(&apos;1234&apos;)</div><div class="line">4</div><div class="line">&gt;&gt;&gt; &apos;1234&apos;.__len__()</div><div class="line">4</div></pre></td></tr></table></figure></p>
<p>我们自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class MyDog(object):</div><div class="line">...     def __len__(self):</div><div class="line">...             return 100</div><div class="line">...</div><div class="line">&gt;&gt;&gt; dog=MyDog()</div><div class="line">&gt;&gt;&gt; len(dog)</div><div class="line">100</div></pre></td></tr></table></figure></p>
<p>剩下的都是普通属性或方法，比如<code>lower()</code>返回小写的字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;ADSAFD&apos;.lower()</div><div class="line">&apos;adsafd&apos;</div></pre></td></tr></table></figure></p>
<p>仅仅把属性和方法列出来是不够的，配合<code>getattr()``setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class MyObject(object):</div><div class="line">...     def __init__(self):</div><div class="line">...             self.x=9</div><div class="line">...     def power(self):</div><div class="line">...             return self.x*self.x</div><div class="line">...</div><div class="line">&gt;&gt;&gt; obj=MyObject()</div></pre></td></tr></table></figure></p>
<p>测试该对象的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; hasattr(obj,&apos;x&apos;)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; obj.x</div><div class="line">9</div><div class="line">&gt;&gt;&gt; hasattr(obj,&apos;y&apos;)</div><div class="line">False</div><div class="line">&gt;&gt;&gt; setattr(obj,&apos;y&apos;,19)</div><div class="line">&gt;&gt;&gt; hasattr(obj,&apos;y&apos;)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; getattr(obj,&apos;y&apos;)</div><div class="line">19</div><div class="line">&gt;&gt;&gt; obj.y</div><div class="line">19</div></pre></td></tr></table></figure></p>
<p>如果试图获取不存在的属性，会抛出AttributeError的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; getattr(obj,&apos;g&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">AttributeError: &apos;MyObject&apos; object has no attribute &apos;g&apos;</div></pre></td></tr></table></figure></p>
<p>可以传入一个default参数，如果属性不存在，就返回默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; getattr(obj,&apos;g&apos;,404)</div><div class="line">404</div></pre></td></tr></table></figure></p>
<p>通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象的信息。</p>
<blockquote>
<p>如果可以直接写:<br>sum=obj.x+obj.y<br>就不要写:<br>sum=getattr(obj,’x’)+getattr(obj,’y’)</p>
</blockquote>
<p>一个正确的用法例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def readImage(fp):</div><div class="line">    if hasattr(fp, &apos;read&apos;):</div><div class="line">        return readData(fp)</div><div class="line">    return None</div></pre></td></tr></table></figure></p>
<p>如果我们要从文件流fp中读取图像，首先要判断该fp是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。</p>
<hr>
<h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。<br>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name):</div><div class="line">...             self.name=name</div><div class="line">...</div><div class="line">&gt;&gt;&gt; s=Student(&apos;Bob&apos;)</div><div class="line">&gt;&gt;&gt; s.score=90</div></pre></td></tr></table></figure></p>
<p>但是，如果<code>Student</code>类本身需要绑定一个属性的时候可以直接在class中定义属性，这种属性是类属性，归<code>Student</code>所有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     name=&apos;sad&apos;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>当我们定义了一个类属性，这个属性虽然归类所有，但类的所有实例都可以访问到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s=Student()</div><div class="line">&gt;&gt;&gt; print(s.name)</div><div class="line">sad</div><div class="line">&gt;&gt;&gt; s.name=&apos;Mick&apos;</div><div class="line">&gt;&gt;&gt; print(s.name)</div><div class="line">Mick</div><div class="line">&gt;&gt;&gt; print(Student.name)</div><div class="line">sad</div><div class="line">&gt;&gt;&gt; del s.name</div><div class="line">&gt;&gt;&gt; print(s.name)</div><div class="line">sad</div></pre></td></tr></table></figure></p>
<p>可以看出，在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的是类属性。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate comment here</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="cdx 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="cdx 支付宝"/>
        <p>支付宝</p>
      </div>
    

    
      <div id="bitcoin" style="display: inline-block">
        <img id="bitcoin_qr" src="/images/bitcoin.png" alt="cdx 比特币"/>
        <p>比特币</p>
      </div>
    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python基础/" rel="tag"># Python基础</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/09/1_函数/" rel="next" title="1. 函数">
                <i class="fa fa-chevron-left"></i> 1. 函数
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/09/3.函数式编程/" rel="prev" title="3. 函数式编程">
                3. 函数式编程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/avatar.gif"
              alt="cdx" />
          
            <p class="site-author-name" itemprop="name">cdx</p>
            <p class="site-description motion-element" itemprop="description">Be a better man!</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">60</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/cdx0312" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:cdxu0312@outlook.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象编程-md-面向对象编程"><span class="nav-number">1.</span> <span class="nav-text">面向对象编程.md#面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类和实例"><span class="nav-number">1.1.</span> <span class="nav-text">类和实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据封装"><span class="nav-number">1.2.</span> <span class="nav-text">数据封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">1.2.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问限制"><span class="nav-number">1.3.</span> <span class="nav-text">访问限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承和多态"><span class="nav-number">1.4.</span> <span class="nav-text">继承和多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取对象信息"><span class="nav-number">1.5.</span> <span class="nav-text">获取对象信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#type"><span class="nav-number">1.5.1.</span> <span class="nav-text">type()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isinstance"><span class="nav-number">1.5.2.</span> <span class="nav-text">isinstance()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dir"><span class="nav-number">1.5.3.</span> <span class="nav-text">dir()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例属性和类属性"><span class="nav-number">1.6.</span> <span class="nav-text">实例属性和类属性</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cdx</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
