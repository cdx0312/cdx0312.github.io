<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Be a better man!">
<meta property="og:type" content="website">
<meta property="og:title" content="小黄">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="小黄">
<meta property="og:description" content="Be a better man!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小黄">
<meta name="twitter:description" content="Be a better man!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>小黄</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小黄</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">黄小黄的幸福生活！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-java">
          <a href="/Java/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Java
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/09/4.模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/4.模块/" itemprop="url">4. 模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-09T15:30:31+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>在计算机程序的开发过程中，随着程序代码越来越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们可以把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就越来越少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块。</p>
<p>使用模块的好处在哪里？</p>
<p>最大的好处是大大提高了代码的可维护性，其次，编写代码不用从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们在编写模块时，不必考虑名字会和其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。Python的内置函数在这里：          [<a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="external">https://docs.python.org/3/library/functions.html</a>]</p>
<p>同时，为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包(Package)。</p>
<p>例如，一个<code>abc.py</code>的文件就是一个名字叫<code>abc</code>的模块，一个<code>xyz.py</code>的文件就是一个名字叫<code>xyz</code>的模块。现在我们假设abc和xyz这两个模块名字与其他模块冲突了，于是我们通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如<code>mycompany</code>，按照如下目录来存放：<br><img src="./1470055483538.png" alt="Alt text"><br>引入了包之后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，<code>abc.py</code>模块的名字就变为了<code>mycompany.abc</code>。请注意，在每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当做普通目录，而不是一个包。<code>__init__.py</code>可以是空文件也可以有Python代码，因为其本身就是一个模块，其模块名为<code>mycompany</code>。</p>
<p>类似的，可以有多级目录，组成多级层次的包结构，比如：<br><img src="./1470055757208.png" alt="Alt text"><br>文件<code>www.py</code>的模块名就是<code>mycompany.web.www</code>，两个文件<code>utils.py</code>的模块名分比为<code>mycompany.utils</code>和<code>mycompany.web.utils</code>。</p>
<p>自己创建模块时要注意命名，不能喝Python自带的模块名称冲突。例如，系统自带了<code>sys</code>模块，自己模块就不可命名为<code>sys.py</code>，否则就无法导入系统自带的<code>sys</code>模块。<code>mycompany.web</code>也是一个模块，对应的文件为<code>__init__.py</code>。</p>
<hr>
<h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><p>Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立即使用。</p>
<p>我们以内建的<code>sys</code>模块为例，编写一个hello的模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment">#-*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="string">'a test module'</span></div><div class="line"></div><div class="line">__author__=<span class="string">'cdx'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></div><div class="line">	args=sys.argv</div><div class="line">	<span class="keyword">if</span> len(args)==<span class="number">1</span>:</div><div class="line">		print(<span class="string">'Hello,world!'</span>)</div><div class="line">	<span class="keyword">elif</span> len(args==<span class="number">2</span>):</div><div class="line">		print(<span class="string">'Hello,%s!'</span> %args[<span class="number">1</span>])</div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		print(<span class="string">'too many arguments!'</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">	test()</div></pre></td></tr></table></figure>
<p>第一行和第二行是标准注释，第一行注释可以让这个<code>hello.py</code>文件直接在Unix/Linux/Mac上运行，第二行注释表示.py文件本身使用标准的UTF-8编码。<br>第四行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；第六行使用<code>__author__</code>变量把作者写进去，开源后可以查看作者姓名。签名都是一些标准写法，虽然可以不写，但是按照标准是没有任何问题的。</p>
<p>使用<code>sys</code>的第一步是导入该模块：</p>
<blockquote>
<p>import sys</p>
</blockquote>
<p>导入该模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能。<code>sys</code>模块有一个<code>argv</code>变量，用list存储了命令行的所有参数。<code>argv</code>至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：</p>
<p>运行<code>python hello.py</code>获得的<code>sys.argv</code>就是<code>[&#39;hello.py&#39;,&#39;cdx&#39;]</code>。</p>
<p>最后注意到这两行代码：</p>
<blockquote>
<p>if <strong>name</strong>==’<strong>main</strong>‘:<br>    test()</p>
</blockquote>
<p>当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该hello模块时，if判断将失败，因此这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
<p>我们可以通过命令行运行<code>hello.py</code>看看效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D:\笔记\Python\Notepad++&gt;python hello.py</div><div class="line">Hello,world!</div></pre></td></tr></table></figure>
<p>如果进入Python交互换将，再导入hello模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Python 3.5.0 (v3.5.0:374f501f4567, Sep 13 2015, 02:27:37) [MSC v.1900 64 bit (AMD64)] on win32</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line">&gt;&gt;&gt; import hello</div><div class="line">&gt;&gt;&gt; hello.test()</div><div class="line">Hello,world!</div></pre></td></tr></table></figure>
<p>导入时，没有打印<code>Hello,world!</code>，因为没有执行<code>test()</code>函数，调用<code>Hello,world!</code>时就会打印了。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在一个模块中，我们会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过前缀<code>_</code>来实现的。</p>
<p>正常函数和变量名是公开的public，可以被直接引用，比如：<code>abc</code>,<code>x123</code>,<code>PI</code>等。</p>
<p>类似<code>__xxx__</code>这样的变量是特殊变量，可以别直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，hello模块定义的文档注释也可以用特殊变量<code>__doc__</code>来访问，我们自己的变量一般不要用这种变量名；</p>
<p>类似<code>_xxx</code>和<code>__xxx</code>这种函数或变量就是非公开的private，不应该被直接引用，比如<code>_abc``__abc_</code>等。</p>
<p>之所以说，private函数和变量不应该被直接引用，而不是不能被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p>
<p>private变量或函数的作用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def _private_1(name):</div><div class="line">    return &apos;Hello, %s&apos; % name</div><div class="line"></div><div class="line">def _private_2(name):</div><div class="line">    return &apos;Hi, %s&apos; % name</div><div class="line"></div><div class="line">def greeting(name):</div><div class="line">    if len(name) &gt; 3:</div><div class="line">        return _private_1(name)</div><div class="line">    else:</div><div class="line">        return _private_2(name)</div></pre></td></tr></table></figure>
<p>我们在模块里公开<code>greeting()</code>函数，而把内部逻辑用private函数隐藏起来了，这样，调用<code>greeting()</code>函数不关心内部的private细节，这也是一种非常有用的代码封装和抽象方法，即：</p>
<p>外部不需要引用的函数全部定义为private，只有外部需要引用的函数才定义为public。</p>
<h2 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h2><p>在Python中，安装第三方模块，是通过管理工具pip完成的。</p>
<p>现在我们来安装一个第三方库—-Python Imaging Library，这是Python下非常强大的处理图像的工具库。一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须知道该库的名称，可以在官网或者pipy上搜索，比如Pillow的名称叫pillow，因此，安装Pillow的命令就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install Pillow</div></pre></td></tr></table></figure>
<p>安装了Pillow之后，就可以处理图片了，随便找一个图片生成缩略图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from PIL import Image</div><div class="line">&gt;&gt;&gt; im=Image.open(r&apos;desktop\test.png&apos;)</div><div class="line">&gt;&gt;&gt; print(im.format, im.size, im.mode)</div><div class="line">PNG (1841, 959) RGBA</div><div class="line">&gt;&gt;&gt; im.thumbnail((200,100))</div><div class="line">&gt;&gt;&gt;im.save(r&apos;desktop\thumb.jpg&apos;,&apos;JPEG&apos;)</div></pre></td></tr></table></figure>
<p>其他常用的第三方库还有MySQL的驱动，<code>mysql-connector-python</code>，用于科学计算的NumPy库<code>numpy</code>，用于生成文本的模板工具<code>Jinja2</code>等。</p>
<h2 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h2><p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错；默认情况下，Python解释器会搜索当前目录，所有已安装的内置模块和第三方模块，搜索路径存放在sys模块中的path变量中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</div><div class="line">[<span class="string">''</span>, <span class="string">'C:\\Users\\cdxu0\\AppData\\Local\\Programs\\Python\\Python35\\python35.zip'</span>, <span class="string">'C:\\Users\\cdxu0\\AppData\\Local\\Programs\\Python\\Python35\\DLLs'</span>, <span class="string">'C:\\Users\\cdxu0\\AppData\\Local\\Programs\\Python\\Python35\\lib'</span>, <span class="string">'C:\\Users\\cdxu0\\AppData\\Local\\Programs\\Python\\Python35'</span>, <span class="string">'C:\\Users\\cdxu0\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages'</span>]</div></pre></td></tr></table></figure>
<p>如果要添加自己的搜索目录，有两种方法：</p>
<blockquote>
<p>1.直接修改<code>sys.path</code>，添加要搜索的目录<br>2.设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中，设置方法和设置path 环境变量类似。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/09/3.函数式编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/3.函数式编程/" itemprop="url">3. 函数式编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-09T15:30:31+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><blockquote>
<p>函数式Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>
<p>而函数式编程—-Functional Programming，虽然也可以归结到面向过程的程序设计，但是其思想更接近数学计算。</p>
<p>我们首先要弄清楚计算机和计算的概念。在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。而计算则是指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p>
<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p>函数抽象编程是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入时确定的，输出就是确定的，这种函数我们称为没有副作用。而允许使用变量的程序设计语言，由于函数内部变量状态不确定，同样的输入，可能会得到不同的输出，因此这种函数式有副作用的。</p>
<p>函数式编程的一个特点就是，允许函数本身作为参数传入另一个函数，还允许返回一个函数！Python对函数式编程提供部分支持，由于Python允许使用变量，因此，Python不是纯函数编程式编程语言。</p>
</blockquote>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数—-Higher-order function。</p>
<h3 id="变量可以指向函数"><a href="#变量可以指向函数" class="headerlink" title="变量可以指向函数"></a>变量可以指向函数</h3><p>以Python内置的求绝对值的函数<code>abs()</code>为例子，调用该函数的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-10</span>)</div><div class="line"><span class="number">10</span></div></pre></td></tr></table></figure>
<p>如果只写abs:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs</div><div class="line">&lt;built-<span class="keyword">in</span> function abs&gt;</div></pre></td></tr></table></figure></p>
<p>可见，abs是函数本身，abs(-10)是函数调用。</p>
<p>要获得函数调用结果，我们可以把结果赋值给变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x=abs(<span class="number">-123</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x</div><div class="line"><span class="number">123</span></div></pre></td></tr></table></figure>
<p>但是如果把函数本身赋值给变量呢：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x=abs</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x(<span class="number">-123</span>)</div><div class="line"><span class="number">123</span></div></pre></td></tr></table></figure>
<blockquote>
<p>结论：函数本身也可以赋值给变量，即变量可以指向函数。如果一个变量指向了函数，那么，可以通过变量来调用这个函数。</p>
</blockquote>
<h3 id="函数名也是变量"><a href="#函数名也是变量" class="headerlink" title="函数名也是变量"></a>函数名也是变量</h3><p>函数名其实就是指向函数的变量！！！对于<code>abs()</code>这个函数，完全可以把函数名<code>abs</code>看成变量，他指向一个可以计算绝对值的函数。如果把<code>abs</code>指向其他对象，会发生什么？？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs=<span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-1</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: <span class="string">'int'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</div></pre></td></tr></table></figure>
<p>此时，abs这个变量已经不指向求绝对值函数，而是指向一个整数1。</p>
<h3 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h3><p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数被称为高阶函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y,f)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> f(x)*f(y)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>当我们调用<code>add(-4,2,abs)</code>时，参数<code>x</code>,<code>y</code>,<code>f</code>分别接收<code>-4</code>,<code>2</code>,<code>abs</code>,验证一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">-4</span>,<span class="number">2</span>,abs)</div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure>
<p>编写高阶函数，就是让函数能够接收别的函数。</p>
<blockquote>
<p>小结<br>把函数作为参数传入，这样的函数称之为高阶函数，函数式编程就是指这种高度抽象的编程范式。</p>
</blockquote>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p>Python中内建了<code>map()</code>和<code>reduce()</code>函数。</p>
<p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。举例如下：我们有一个函数f(x)=x^2，要把这个函数作用在一个list<code>[1,2,3,4,5,6,7,8,9]</code>上就可以用<code>map</code>实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x*x</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>h=map(f,L)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(h)</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</div></pre></td></tr></table></figure>
<p><code>map()</code>传入的第一个参数是<code>f</code>，也就是函数对象本身。由于结果<code>r</code>是一个<code>Iterator</code>，<code>Iterator</code>是惰性序列，因此需要<code>list()</code>函数让它把整个序列都计算出来并返回一个list。</p>
<p>但是其实用循环也可以实现上述功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L=[]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]:</div><div class="line"><span class="meta">... </span>    L.append(f(x))</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</div></pre></td></tr></table></figure>
<p>这样也可以实现这个功能，但是循环中不能看出  ‘把f(x)作用于L上的每一个元素并生成一个新的list’  的功能。所以<code>map</code>作为高阶函数，事实上吧运算规则抽象化了，因此，我们不仅可以计算简单的平法，也可以计算更加复杂的任意函数。比如把list 所有数字转为字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; list(map(str,L))</div><div class="line">[&apos;1&apos;, &apos;4&apos;, &apos;9&apos;, &apos;16&apos;, &apos;25&apos;, &apos;36&apos;, &apos;49&apos;, &apos;64&apos;, &apos;81&apos;]</div></pre></td></tr></table></figure>
<p><code>reduce</code>把一个函数作用在一个序列<code>[x1,x2,x3,...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x+y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</div><div class="line"><span class="number">45</span></div></pre></td></tr></table></figure>
<p>求和运算推荐用<code>sum()</code>函数，但是如果把序列[1,3,5,7,9]换为13579，就可以用reduce：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">10</span>*x+y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(f,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])</div><div class="line"><span class="number">13579</span></div></pre></td></tr></table></figure>
<p>这个例子本身没有什么实用性，但是考虑到字符串<code>str</code>是一个序列，对上面个的例子进行改动并配合<code>map()</code>函数，我们就可以把str转为int的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">10</span>*x+y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> &#123;<span class="string">'0'</span>:<span class="number">0</span>,<span class="string">'1'</span>:<span class="number">1</span>,<span class="string">'2'</span>:<span class="number">2</span>,<span class="string">'3'</span>:<span class="number">3</span>,<span class="string">'4'</span>:<span class="number">4</span>,<span class="string">'5'</span>:<span class="number">5</span>,<span class="string">'6'</span>:<span class="number">6</span>,<span class="string">'7'</span>:<span class="number">7</span>,<span class="string">'8'</span>:<span class="number">8</span>,<span class="string">'9'</span>:<span class="number">9</span>&#125;[s]</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(f,map(char2num,<span class="string">'13579'</span>))</div><div class="line"><span class="number">13579</span></div></pre></td></tr></table></figure>
<p>还可以用lambda函数进一步简化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from functools import reduce</div><div class="line">&gt;&gt;&gt; def char2num(s):</div><div class="line">...     return &#123;&apos;0&apos;:0,&apos;1&apos;:1,&apos;2&apos;:2,&apos;3&apos;:3,&apos;4&apos;:4,&apos;5&apos;:5,&apos;6&apos;:6,&apos;7&apos;:7,&apos;8&apos;:8,&apos;9&apos;:9&#125;[s]</div><div class="line">...</div><div class="line">&gt;&gt;&gt; def str2int(s):</div><div class="line">...     return reduce(lambda x,y:x*10+y,map(char2num,s))</div><div class="line">...</div><div class="line">&gt;&gt;&gt; str2int(&apos;13579&apos;)</div><div class="line">13579</div></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>Python内建的<code>filter</code>函数用于过滤序列。</p>
<p>和<code>map</code>类似，<code>filter</code>函数也接收一个函数和一个序列。不同的是<code>filter</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>or <code>False</code>决定保留还是丢弃该元素。在一个list中，删掉偶数，保留奇数，可以这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(s)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> s%<span class="number">2</span>==<span class="number">1</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(is_odd,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]))</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</div></pre></td></tr></table></figure>
<p>把一个序列中的空字符串删掉，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def not_empty(s):</div><div class="line">...     return s and s.strip()</div><div class="line">...</div><div class="line">&gt;&gt;&gt; list(filter(not_empty,[&apos;A&apos;,&apos;B&apos;,None]))</div><div class="line">[&apos;A&apos;, &apos;B&apos;]</div></pre></td></tr></table></figure>
<p>用filter求素数：</p>
<p>计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：<br>首先，列出从2开始的所有自然数，构造一个序列：<code>2,3,4,5,6,7,8,9,10,...</code><br>取序列的第一个数2，他一定是素数，然后用2把序列的2的倍数筛掉：<br><code>3,5,7,9,11,13,...</code><br>取新数列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：<br><code>5,7,11,13,17,19,...</code><br>不断筛选下去，最终会得到所有的素数。</p>
<p>首先构造一个从3开始的奇数序列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def _odd_iter():</div><div class="line">...     n=1</div><div class="line">...     while True:</div><div class="line">...             n=n+2</div><div class="line">...             yield n</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这是一个生成器，并且是一个无限序列。然后定义一个筛选函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def _not_divisible(n):</div><div class="line">...     return lambda x:x%n&gt;0</div><div class="line">...</div></pre></td></tr></table></figure>
<p>最后定义一个生成器，不断返回下一个素数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">2</span></div><div class="line"><span class="meta">... </span>    it=_odd_iter()</div><div class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line"><span class="meta">... </span>            n=next(it)</div><div class="line"><span class="meta">... </span>            <span class="keyword">yield</span> n</div><div class="line"><span class="meta">... </span>            it=filter(_not_divisible(n),it)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这个生成器先返回第一个素数2，然后利用filter不断产生筛选后的新的序列。由于primes也是一个无限序列，所以退出时需要一个退出循环的条件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> primes():</div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> n&lt;<span class="number">1000</span>:</div><div class="line"><span class="meta">... </span>            print(n)</div><div class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>            <span class="keyword">break</span></div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>排序算法</p>
<p>排序也是在程序中经常遇到的算法，无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但是如果是字符串或者两个dict时，直接比较数学书的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。</p>
<p>Python内置的<code>sorted()</code>函数就可以对list进行排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">23</span>,<span class="number">43</span>,<span class="number">5</span>,<span class="number">-5</span>,<span class="number">122</span>])</div><div class="line">[<span class="number">-5</span>, <span class="number">5</span>, <span class="number">23</span>, <span class="number">43</span>, <span class="number">122</span>]</div></pre></td></tr></table></figure>
<p>此外，<code>sorted()</code>函数也是一个高阶函数，它还可以接收一个key来实现自定义的排序，比如按照绝对值大小排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">23</span>,<span class="number">43</span>,<span class="number">5</span>,<span class="number">-7</span>,<span class="number">122</span>],key=abs)</div><div class="line">[<span class="number">5</span>, <span class="number">-7</span>, <span class="number">23</span>, <span class="number">43</span>, <span class="number">122</span>]</div></pre></td></tr></table></figure>
<p>key指定的函数作用于list上的每一个元素，并根据key函数的返回值进行排序。对比原始的list和经过<code>key=abd</code> 处理过的list:</p>
<blockquote>
<p>list=[23,43,5,-7,122]<br>key=[23,43,5,7,122]</p>
</blockquote>
<p>然后<code>sorted()</code>函数按照key进行排序，并按照对应关系返回list相应的元素。</p>
<p>我们再来看一个字符串排序的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>,<span class="string">'james'</span>,<span class="string">'curry'</span>,<span class="string">'Kobe'</span>])</div><div class="line">[<span class="string">'Kobe'</span>, <span class="string">'bob'</span>, <span class="string">'curry'</span>, <span class="string">'james'</span>]</div></pre></td></tr></table></figure>
<p>默认情况下，对字符串的排序，是按照ASCII的大小比较的，由于<code>&#39;Z&#39;&lt;&#39;a&#39;</code>，所以大写字母Z是排在小写字母a前面的。</p>
<p>当我们提出排列时忽略大小写，按照字母排序，要实现这个算法，不必对现有代码加大改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（小写）再比较</p>
<p>这样我们给<code>sorted()</code>传入key函数，即可忽略大小写的排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>,<span class="string">'james'</span>,<span class="string">'curry'</span>,<span class="string">'Kobe'</span>],key=str.lower)</div><div class="line">[<span class="string">'bob'</span>, <span class="string">'curry'</span>, <span class="string">'james'</span>, <span class="string">'Kobe'</span>]</div></pre></td></tr></table></figure>
<p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>,<span class="string">'james'</span>,<span class="string">'curry'</span>,<span class="string">'Kobe'</span>],key=str.lower,reverse=<span class="keyword">True</span>)</div><div class="line">[<span class="string">'Kobe'</span>, <span class="string">'james'</span>, <span class="string">'curry'</span>, <span class="string">'bob'</span>]</div></pre></td></tr></table></figure>
<p><code>sorted()</code>也是一个高阶函数。用<code>sorted()</code>排序的关键是实现一个映射函数。</p>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><blockquote>
<p>函数作为返回值</p>
</blockquote>
<p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果返回。</p>
<p>我们来实现一个可变参数的求和。通常情况下，求和函数式这样定义的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">cal_sum</span><span class="params">(*args)</span>:</span></div><div class="line"><span class="meta">... </span>    ax=<span class="number">0</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> args:</div><div class="line"><span class="meta">... </span>            ax=ax+n</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> ax</div><div class="line">...</div></pre></td></tr></table></figure>
<p>但是，如果不需要立即求和，而是在后面的代码中根据需要再进行计算怎么办？可以不返回求和的结果，而是返回求和的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>            ax=<span class="number">0</span></div><div class="line"><span class="meta">... </span>            <span class="keyword">for</span> n <span class="keyword">in</span> args:</div><div class="line"><span class="meta">... </span>                    ax=ax+n</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> ax</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> sum</div><div class="line">...</div></pre></td></tr></table></figure>
<p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数，调用函数f时，才真正计算求和的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f=lazy_sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f</div><div class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at <span class="number">0x000001BA761FF378</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f()</div><div class="line"><span class="number">21</span></div></pre></td></tr></table></figure>
<p>在这个例子中，我们在函数<code>lazy_sum</code>中又定义了sum，并且，内部函数sum可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数sum时，相关参数和变量都保存在返回的函数中，这种程序结构称为‘闭包’（Closure）。</p>
<p>请再注意一点，当我们调用<code>lazy_sum</code>时，每次调用都会返回一个新的函数，即使传入相同的参数。</p>
<p><em>闭包</em></p>
<p>注意到返回的函数在其内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来不容易。另一个需要注意的问题是，返回的函数并没有立刻被执行，而是在调用了<code>f()</code>之后才执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    fs=[]</div><div class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>):</div><div class="line"><span class="meta">... </span>            <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>                    <span class="keyword">return</span> i*i</div><div class="line"><span class="meta">... </span>            fs.append(f)</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> fs</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1,f2,f3=count()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1</div><div class="line">&lt;function count.&lt;locals&gt;.f at <span class="number">0x000001BA761FF730</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>
<p>在上面的例子中，每次循环都创建了一个新的函数，然后，把创建的三个函数都返回了。调用三个函数结果不是1，4，9而都是9。原因在于返回的函数引用了局部变量i，但是它不是立刻执行，等到三个函数都返回时，引用的变量i变为3，因此最终的结果为9</p>
<p>返回闭包时牢记的一点是，返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果一定要引用循环变量时，可以新建一个函数，用该函数的参数绑定循环变量的当前值，无论该循环变量后续如何更改，已经绑定到函数参数的值不变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></div><div class="line"><span class="meta">... </span>            <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>                    <span class="keyword">return</span> j*j</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> g</div><div class="line"><span class="meta">... </span>    fs=[]</div><div class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>):</div><div class="line"><span class="meta">... </span>            fs.append(f(i))</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> fs</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1,f2,f3=count()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>
<blockquote>
<p>小结<br>一个函数可以返回一个计算结果也可以返回一个函数。返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。</p>
</blockquote>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>当我们传入函数时，有些时候，不需要显示的定义函数，直接传入匿名函数更方便。在Python中，对匿名函数提供了优先支持。以<code>map()</code>函数为例，计算f(x)=x^2时，除了定义一个函数外，还可以传入匿名函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x:x*x,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]))</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</div></pre></td></tr></table></figure>
<p>通过对比可以看出，匿名函数<code>lambda x:x*x</code>实际上就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x*x</div></pre></td></tr></table></figure>
<p>关键字<code>lambda</code>表示匿名函数，冒号前面的x表示函数参数。</p>
<p>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f=<span class="keyword">lambda</span> x:x*x+x</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f</div><div class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x00000230CEB4F510</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">16</span>)</div><div class="line"><span class="number">272</span></div></pre></td></tr></table></figure>
<p>同样，也可以把匿名函数作为返回值返回：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(x,y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="keyword">lambda</span>:x*x+y*y</div></pre></td></tr></table></figure>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>由于函数也是一个对象，而且函数对象可以被赋值变量，所以，通过变量能调用该函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'2016-11-23'</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f=now</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f()</div><div class="line"><span class="number">2016</span><span class="number">-11</span><span class="number">-23</span></div></pre></td></tr></table></figure>
<p>函数对象有一个<code>__name__</code>属性，可以拿到函数的名字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</div><div class="line"><span class="string">'now'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.__name__</div><div class="line"><span class="string">'now'</span></div></pre></td></tr></table></figure>
<p>现在，假定我们要增强<code>now()</code>的功能，比如，在函数调用前后自动打印日志，但又不希望修改<code>now()</code>的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）</p>
<p>本质上，decorator就是一个返回函数的高阶函数。所以我们要定义一个能打印日志的decorator如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kw)</span>:</span></div><div class="line"><span class="meta">... </span>            print(<span class="string">'call %s():'</span> %func.__name__)</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> func(*args,**kw)</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</div><div class="line">...</div></pre></td></tr></table></figure>
<p>观察上面的log，因为他是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们借助Python的@语法，把decorator置于函数的定义处，调用now函数，不仅会运行now函数本身，还会在运行该函数前打印一行日志：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>@log</div><div class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'2016-04-09'</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now()</div><div class="line">call now():</div><div class="line"><span class="number">2016</span><span class="number">-04</span><span class="number">-09</span></div></pre></td></tr></table></figure>
<p>把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句：</p>
<blockquote>
<p>now=log(now)</p>
</blockquote>
<p>由于<code>log()</code>是一个decorator，返回一个函数，所以，原来的<code>now()</code>函数仍然存在，只是现在同名的now变量指向了信道函数，于是调用<code>now()</code>将执行新函数，即在<code>log()</code>函数中返回的<code>wrapper()</code>函数。</p>
<p><code>wrapper()</code>函数的参数定义是<code>(*args,**kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。在<code>wrapper()</code>函数内，首先打印日志，再紧接着调用原始函数。</p>
<p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来很复杂，比如要自定义log的文本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">... </span>            <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kw)</span>:</span></div><div class="line"><span class="meta">... </span>                     print(<span class="string">'%s %s():'</span> % (text, func.__name__))</div><div class="line"><span class="meta">... </span>                    <span class="keyword">return</span> func(*args,**kw)</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> wrapper</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> decorator</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这个三层嵌套的decorator用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>@log(<span class="string">'execute'</span>)</div><div class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'2015-3-25'</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now()</div><div class="line">execute now():</div><div class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></div></pre></td></tr></table></figure>
<p>和两层嵌套的decorator相比，3层嵌套的decorator的效果是这样的：</p>
<blockquote>
<p>now=log(‘execute’)(now)</p>
</blockquote>
<p>上面的语句中，首先执行<code>log(&#39;execute&#39;)</code>，返回的是<code>decorator</code>函数，再调用返回的函数，参数是now的函数，返回值最终是wrapper的函数。以上两种decorator的定义都没有问题，但还差最后一步。我们讲了函数也是对象，有<code>__name__</code>等属性，但你去看经过decorator装饰之后的函数，它们的<code>__name__</code>属性已经从原来的<code>now</code>变为了<code>wrapper</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</div><div class="line"><span class="string">'wrapper'</span></div></pre></td></tr></table></figure>
<p>因为返回的那个<code>wrapper()</code>函数的名字就是<code>wrapper</code>，所以，需要把原始函数的<code>__name__</code>等属性复制到<code>wrapper()</code>函数中，否则，有些依赖函数签名的代码执行就会出错。</p>
<p>不需要编写<code>wrapper.__name__=func.__name__</code>这样的代码，Python内置的<code>functools.wraps</code>就是干这个事情的，所以一个完整的decorator如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">... </span>    @functools.wraps(func)</div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kw)</span>:</span></div><div class="line"><span class="meta">... </span>            print(<span class="string">'call %s():'</span> % func.__name__)</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> func(*args,**kw)</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</div><div class="line">...</div></pre></td></tr></table></figure>
<p>或者针对带参数的decorator：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">        @functools.wraps(func)</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></div><div class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</div><div class="line">            <span class="keyword">return</span> func(*args, **kw)</div><div class="line">        <span class="keyword">return</span> wrapper</div><div class="line">    <span class="keyword">return</span> decorator</div></pre></td></tr></table></figure>
<p><strong>小结</strong><br>在面对对象的设计模块中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。</p>
<p>decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>Python的<code>fucntools</code>模块提供了很多有用的功能，其中一个就是偏函数(Partial function)。要注意，这里的偏函数和数学上的偏函数不一样。在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。</p>
<p>如<code>int()</code>函数可以把字符串装换为整数，当仅传入字符串时，<code>int()</code>函数默认按照十进制装换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'12354'</span>)</div><div class="line"><span class="number">12354</span></div></pre></td></tr></table></figure>
<p>但<code>int()</code>函数还提供额外的<code>base</code>参数，默认值为10，如果传入<code>base</code>参数，就可以做N进制装换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'12354'</span>,base=<span class="number">16</span>)</div><div class="line"><span class="number">74580</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'12354'</span>,base=<span class="number">12</span>)</div><div class="line"><span class="number">24688</span></div></pre></td></tr></table></figure>
<p>假设要装换大量二进制字符，每次都传入<code>int(x,base=2)</code>非常麻烦，我们可以定义一个<code>int2()</code>函数，默认把<code>base=2</code>传进去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def int2(x,base=2):</div><div class="line">...     return int(x,base)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; int2(&apos;111001&apos;)</div><div class="line">57</div><div class="line">&gt;&gt;&gt; int2(&apos;111001100101010&apos;)</div><div class="line">29482</div></pre></td></tr></table></figure></p>
<p><code>functools.partial</code>就是帮我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int2=functools.partial(int, base=<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'111001'</span>)</div><div class="line"><span class="number">57</span></div></pre></td></tr></table></figure>
<p>所以简单总结<code>functllos.partial</code>的作用就是，把一个函数的某些参数给固定住，返回一个新的函数，调用这个新函数会更简单。注意到上面的int2函数，仅仅是把base参数重新设定位2，但可以在函数调用时传入其他值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; int2(&apos;1111111100&apos;,base=4)</div><div class="line">349520</div></pre></td></tr></table></figure>
<p>最后，创建偏函数时，实际上可以接收函数对象，<em>args,*</em>kw三个参数，当传入<code>int2=functools.partial(int, base=2)</code>实际上固定了<code>int()</code>函数的关键字参数base，也就是<code>int2(&#39;10010&#39;)</code>相当于：</p>
<blockquote>
<p>kw={‘base’ : 2}<br>int(‘10010’,**kw)</p>
</blockquote>
<p>当传入<code>max2 = functools.partial(max, 10)</code>实际上会把10作为<code>*args</code>的一部分自动加到左边，也就是max2(5,6,7)相当于：</p>
<blockquote>
<p>args=(10,5,6,7)<br>max(*args)</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/09/5.面向对象编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/5.面向对象编程/" itemprop="url">5. 面向对象编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-09T15:30:31+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象编程-md-面向对象编程"><a href="#面向对象编程-md-面向对象编程" class="headerlink" title="面向对象编程.md#面向对象编程"></a>面向对象编程.md#面向对象编程</h1><p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>
<p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
<p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发来的消息并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类Class的概念。</p>
<p>我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。假定我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; std1=&#123;&apos;name&apos;: &apos;Michael&apos;, &apos;score&apos;: 98 &#125;</div><div class="line">&gt;&gt;&gt; std2=&#123;&apos;name&apos;: &apos;Bob&apos;, &apos;score&apos;: 82 &#125;</div></pre></td></tr></table></figure>
<p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def print_score(std):</div><div class="line">...     print(&apos;%s: %s&apos; %(std[&apos;name&apos;], std[&apos;score&apos;]))</div><div class="line">...</div><div class="line">&gt;&gt;&gt; print_score(std1)</div><div class="line">Michael: 98</div></pre></td></tr></table></figure>
<p>如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是student这种数据类型应该被视为一个对象，这个对象拥有自己<code>name</code>和<code>score</code>两个属性。如果要打印一个同学的成绩，必须创建出这个学生对应的对象，然后给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line"></div><div class="line">...     def __init__(self, name, score):</div><div class="line">...             self.name=name</div><div class="line">...             self.score=score</div><div class="line"></div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s: %s&apos; %(self.name, self.score))</div><div class="line">...</div></pre></td></tr></table></figure>
<p>给对象发消息实际上就是调用对象的相关函数，我们称之为对象的方法Method，面向对象的程序写出来就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,59)</div><div class="line">&gt;&gt;&gt; lisa=Student(&apos;Lisa Simpson&apos;,89)</div><div class="line">&gt;&gt;&gt; bart.print_score()</div><div class="line">Bart Simpson: 59</div><div class="line">&gt;&gt;&gt; lisa.print_score()</div><div class="line">Lisa Simpson: 89</div></pre></td></tr></table></figure>
<p>面向对象的设计思想是从自然界中来的，因为在自然界中，类Class和实例Instance的概念是很自然的。Class是一种抽象概念，比如我们定义的Class—Student，是指学生这个概念，而实例Instance则是一个个具体的Student。</p>
<p>所以面向对象的抽象程度又比函数要高，因为一个Class即包含数据又包含操作数据的方法。</p>
<p><strong>数据封装，继承和多态是面向对象的三大特点。</strong></p>
<h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><p>面向对象最重要的概念就是类Class和实例Instance，必须牢记类是抽象的模板，实例是根据类创建出来的一个个具体的对象，每个对象都拥有相同的方法，但是各自的数据可能不同。</p>
<p>仍以Student类为例，在Python中，定义类是通过<code>class</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     pass</div><div class="line">...</div></pre></td></tr></table></figure>
<p><code>class</code>后面紧跟着类名，即Student，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面会讲，通常，如果没有合适的继承类，就是用object类，这是所有类都会继承的类。</p>
<p>定义好了<code>Student</code>类，就可以根据<code>Student</code>类创建出<code>Student</code>实例，创建实例是通过类名+()来实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart=Student()</div><div class="line">&gt;&gt;&gt; bart</div><div class="line">&lt;__main__.Student object at 0x000002C2CE396160&gt;</div><div class="line">&gt;&gt;&gt; Student</div><div class="line">&lt;class &apos;__main__.Student&apos;&gt;</div></pre></td></tr></table></figure>
<p>可以看到，变量<code>bart</code>指向的就是一个<code>Student</code>的实例，后面的0x000002C2CE396160是内存地址，每个object的地址都不一样，而<code>Student</code>本身则是一个类，可以自由的给一个实例变量绑定属性，比如，给实例<code>bart</code>绑定一个name属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart.name=&apos;Bart Simpson&apos;</div><div class="line">&gt;&gt;&gt; bart.name</div><div class="line">&apos;Bart Simpson&apos;</div></pre></td></tr></table></figure>
<p>由于类可以起到模板的作用，因此在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>的方法，在创建实例的时候，就把<code>name</code>,<code>score</code>等属性绑定上去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.name=name</div><div class="line">...             self.score=score</div><div class="line">...</div></pre></td></tr></table></figure>
<p>注意到<code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身，因此，在<code>__init__</code>方法的内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器会自己把实例变量传进去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,98)</div><div class="line">&gt;&gt;&gt; bart.name</div><div class="line">&apos;Bart Simpson&apos;</div><div class="line">&gt;&gt;&gt; bart.score</div><div class="line">98</div><div class="line">&gt;&gt;&gt; bart</div><div class="line">&lt;__main__.Student object at 0x000002C2CE396278&gt;</div></pre></td></tr></table></figure></p>
<p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数的没有什么区别，仍然可以使用默认参数，可变参数，关键字参数和命名关键字参数。</p>
<h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><p>面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def print_score(std):</div><div class="line">...     print(&apos;%s:%s &apos; % (std.name,std.score))</div><div class="line">...</div><div class="line">&gt;&gt;&gt; print_score(bart)</div><div class="line">Bart Simpson:98</div></pre></td></tr></table></figure></p>
<p>但是，既然<code>Student</code>实例本身就拥有这些数据，要访问这些数据就没有必要从外面的函数去访问，可以直接在<code>Student</code>类的内部定义访问数据的函数，这样，就把数据给封装起来了。这些封装数据的函数和<code>Student</code>类本身是关联的，我们称之为类的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.name=name</div><div class="line">...             self.score=score</div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s:%s&apos; %(self.name,self.score))</div><div class="line">...</div><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,98)</div><div class="line">&gt;&gt;&gt; bart.print_score()</div><div class="line">Bart Simpson:98</div></pre></td></tr></table></figure>
<p>这样一来，我们从外部看<code>Student</code>类，就只需要知道，创建实例需要给出<code>name</code>和<code>score</code>，而如何打印，都是在<code>Student</code>类的内部定义的，这些数据和逻辑被封装起来了，调用很容易但是不知道内部实现的细节。</p>
<p>封装的另一个好处是可以给<code>Student</code>类增加新的方法，比如<code>get_grade</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.name=name</div><div class="line">...             self.score=score</div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s:%s&apos; %(self.name,self.score))</div><div class="line">...     def get_grade(self):</div><div class="line">...             if self.score&gt;=90:</div><div class="line">...                     return &apos;A&apos;</div><div class="line">...             elif self.score&gt;=80:</div><div class="line">...                     return &apos;B&apos;</div><div class="line">...             else:</div><div class="line">...                     return &apos;C&apos;</div><div class="line">...</div><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,98)</div><div class="line">&gt;&gt;&gt; bart.get_grade()</div><div class="line">&apos;A&apos;</div></pre></td></tr></table></figure></p>
<p><code>get_grade</code>方法可以直接在实例变量上调用不需要知道内部的实现细节。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>类是创建实例的模板，而实例则是一个个具体的对象，各个实例拥有的数据都相互独立，互不影响；方法就是与实例绑定的函数和普通函数不同，方法可以直接访问实例的数据；通过在实例上调用 的方法，我们就直接操作了对象内部的数据，也就是说，对于两个实例变量，虽然他们都是同一个类的不同实例，但拥有的变量名称可能不同。</p>
<h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。但是，从前面Student来看，外部代码还是可以自由修改一个实例的name、score属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart.score</div><div class="line">98</div><div class="line">&gt;&gt;&gt; bart.score=69</div><div class="line">&gt;&gt;&gt; bart.score</div><div class="line">69</div><div class="line">&gt;&gt;&gt; bart.get_grade</div><div class="line">&lt;bound method Student.get_grade of &lt;__main__.Student object at 0x000002C2CE3966A0&gt;&gt;</div><div class="line">&gt;&gt;&gt; bart.get_grade()</div><div class="line">&apos;C&apos;</div></pre></td></tr></table></figure>
<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在python中，实例的变量名如果以<code>__</code>开头，就变为了一个私有变量private，只有内部可以访问，外部不可以访问，我们把student类改一改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.__name=name</div><div class="line">...             self.__score=score</div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s: %s&apos; %(self.__name,self.__score))</div><div class="line">...</div></pre></td></tr></table></figure>
<p>改完后，对于外部代码来说没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,99)</div><div class="line">&gt;&gt;&gt; bart.__name</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;__name&apos;</div></pre></td></tr></table></figure></p>
<p>这样就确保了外部代码不能随便修改内部的状态，这样通过访问限制的保护，代码更加稳定。但是如果外部代码要取得name和score怎么办？可以给Student类增加<code>get_name</code>,<code>get_score</code>的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.__name=name</div><div class="line">...             self.__score=score</div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s: %s&apos; %(self.__name,self.__score))</div><div class="line">...     def get_name(self):</div><div class="line">...             return self.__name</div><div class="line">...     def get_score(self):</div><div class="line">...             return self.__score</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>如果要允许外部代码修改score怎么办，需要给Student类增加<code>set_score</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.__name=name</div><div class="line">...             self.__score=score</div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s: %s&apos; %(self.__name,self.__score))</div><div class="line">...     def get_name(self):</div><div class="line">...             return self.__name</div><div class="line">...     def get_score(self):</div><div class="line">...             return self.__score</div><div class="line">...     def set_score(self,score):</div><div class="line">...             self.__score=score</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>与原来直接通过<code>bart.score=90</code>相比，在方法中，可以对参数做检查，避免传入无效的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name,score):</div><div class="line">...             self.__name=name</div><div class="line">...             self.__score=score</div><div class="line">...     def print_score(self):</div><div class="line">...             print(&apos;%s: %s&apos; %(self.__name,self.__score))</div><div class="line">...     def get_name(self):</div><div class="line">...             return self.__name</div><div class="line">...     def get_score(self):</div><div class="line">...             return self.__score</div><div class="line">...     def set_score(self,score):</div><div class="line">...             if 0&lt;=score&lt;=100:</div><div class="line">...                     self.__score=score</div><div class="line">...             else:</div><div class="line">...                     raise ValueError(&apos;bad score&apos;)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以下划线结尾的，是特殊百年来那个，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>这样的变量名。<br>而以一个下划线开头的实例变量名，比如<code>_name</code>这样的实例变量外部是可以访问的，但是一般不随便访问此类实例。<br>双下划线开头的实例变量也不是一定不能从外部访问的，不能直接访问<code>__name</code>是因为Python解释器对外吧<code>__name</code>变量改为了<code>_Student__</code>,所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,99)</div><div class="line">&gt;&gt;&gt; bart._Student__name</div><div class="line">&apos;Bart Simpson&apos;</div></pre></td></tr></table></figure>
<p>但是强烈建议你不要这么做，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名。总的来说就是Python本身没有任何机制阻止你干坏事，全靠自觉。</p>
<p>最后注意下面这种错误写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bart=Student(&apos;Bart Simpson&apos;,99)</div><div class="line">&gt;&gt;&gt; bart.get_name()</div><div class="line">&apos;Bart Simpson&apos;</div><div class="line">&gt;&gt;&gt; bart.__name=&apos;fsfd&apos;</div><div class="line">&gt;&gt;&gt; bart.__name</div><div class="line">&apos;fsfd&apos;</div><div class="line">&gt;&gt;&gt; bart.get_name()</div><div class="line">&apos;Bart Simpson</div></pre></td></tr></table></figure></p>
<p>表面上看，外部代码‘成功’的设置了<code>__name</code>变量，但是实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量不是一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给bart增加了一个<code>__name</code>变量。</p>
<hr>
<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subcalss），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>
<p>比如，我们已经编写了一个名为<code>Animal</code>的class，有一个<code>run()</code>方法可以直接打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Animal(object):</div><div class="line">...     def run(self):</div><div class="line">...             print(&apos;Animal is running...&apos;)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>当我们需要编写<code>Dog</code>和<code>Cat</code>类时，就可以直接从<code>Animal</code>类继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Dog(Animal):</div><div class="line">...     pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; class Cat(Animal):</div><div class="line">...     pass</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>对于<code>Dog</code>来说，<code>Animal</code>就是它的父类，对于<code>Animal</code>来说，<code>Dog</code>就是它的子类。</p>
<p>继承最大的好处是获得了父类的全部功能。由于<code>Animal</code>实现了<code>run()</code>方法，因此，<code>Dog</code>和<code>Cat</code>作为他的子类，自动拥有了<code>run()</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; dog=Dog()</div><div class="line">&gt;&gt;&gt; dog.run()</div><div class="line">Animal is running...</div></pre></td></tr></table></figure></p>
<p>也可以对子类增加一些方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Dog(Animal):</div><div class="line">...     def run(self):</div><div class="line">...             print(&apos;Dog is running...&apos;)</div><div class="line">...     def eat(self):</div><div class="line">...             print(&apos;Dog is eating...&apos;)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; dog=Dog()</div><div class="line">&gt;&gt;&gt; dog.eat()</div><div class="line">Dog is eating...</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>继承的第二个好处需要我们队代码进行一点改进。当子类和父类存在相同的<code>run()</code>方法时，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。</p>
<p>要理解什么事多态，我们首先要对数据类型再做一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么区别：</p>
<pre><code>&gt; a=list() a是list的数据类型
    b=Animal()                       b是Animal的数据类型
    c=Dog()                            c是Dog的数据类型
</code></pre><p>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; isinstance(a,list)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(b,Animal)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(c,Animal)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(b,Dog)</div><div class="line">False</div></pre></td></tr></table></figure></p>
<p>可以看出<code>a</code>,<code>b</code>,<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这三种类型。而且<code>c</code>还对应着<code>Animal</code>类型。在继承关系中，如果一个实例的数据类型是某个子类，那他的数据类型可以看做是父类。但是反过来就不行。</p>
<p>为了更好的理解多态，我们还需要再编写一个函数，这个函数可以接受一个<code>Animal</code>类型的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def run_twice(animal):</div><div class="line">...     animal.run()</div><div class="line">...     animal.run()</div></pre></td></tr></table></figure></p>
<p>当我们传入<code>Animal</code>的实例时，<code>run_twice()</code>就会打印出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; run_twice(Animal())</div><div class="line">Animal is running...</div><div class="line">Animal is running...</div></pre></td></tr></table></figure></p>
<p>当我们传入<code>Dog</code>实例时，<code>run_twice()</code>就打印出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; run_twice(Dog())</div><div class="line">Dog is running...</div><div class="line">Dog is running...</div></pre></td></tr></table></figure></p>
<p>看上去没什么，但是当我们再定义一个<code>Tortoise</code>类型，也从<code>Animal</code>派生：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Tortoise(Animal):</div><div class="line">...     def run(self):</div><div class="line">...             print(&apos;Tortoise is running slowly...&apos;)</div></pre></td></tr></table></figure></p>
<p>当我们调用<code>run_twice()</code>时，传入<code>Tortoise</code>的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; run_twice(Tortoise())</div><div class="line">Tortoise is running slowly...</div><div class="line">Tortoise is running slowly...</div></pre></td></tr></table></figure></p>
<p>可以看出，新增一个<code>Animal</code>的子类，不必对<code>run_twice()</code>进行任何修改，实际上，任何依赖<code>Animal</code>作为参数的函数或方法都可以不加修改的正常运行，原因就在于多态。<br>多态的好处就是当我们需要传入<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……时，我们只需要接收<code>Animal</code>类型就可以，因为前面三者都是<code>Animal</code>类型，然后按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就可以自动调用实际类型的<code>run()</code>方法。<br>对于一个变量，我们只需要知道他是<code>Animal</code>类型，无需确切的知道他的子类型，就可以放心的调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>就是由运行时该对象的确切类型决定，也就是说多态调用中：调用方只管调用，不管细节，而当我们新增一种<code>Aniaml</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调节的，这就是著名的<code>开闭</code>原则：</p>
<blockquote>
<p>对扩展开放：允许新增<code>Animal</code>的子类；<br>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。<br>继承还可以一级一级的继承下来，就好比从爷爷到爸爸再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的数。<br><img src="/img/1474869010884.png" alt="Alt text"><br>静态语言vs动态语言</p>
<blockquote>
<p>对于静态语言来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。<br>对于Python这样的静态语言来说，则不一定需要传入<code>Animal</code>类型，我们只需要保证传入的对象有一个<code>run()</code>方法就可以。</p>
</blockquote>
</blockquote>
<p>这就是动态语言的‘鸭子类型’，它并不要求严格的继承体系，一个对象只要看起来像押走，走起路来像鸭子，那他就可以被看做是鸭子。<br>Python的“file-like object”就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>的方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都可以被视为“file-like object”。许多函数接收的参数就是“file-like object”，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p>
<hr>
<h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><p>当我们拿到一个对象的引用时，如何知道这个对象是什么类型，有哪些方法？</p>
<h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><p>首先，我们判断对象类型，使用<code>type()</code>函数，基本类型都可以用<code>type()</code>判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; type(123)</div><div class="line">&lt;class &apos;int&apos;&gt;</div><div class="line">&gt;&gt;&gt; type(&apos;123&apos;)</div><div class="line">&lt;class &apos;str&apos;&gt;</div><div class="line">&gt;&gt;&gt; type(None)</div><div class="line">&lt;class &apos;NoneType&apos;&gt;</div></pre></td></tr></table></figure>
<p>如果一个变量指向函数或者类，也可以用<code>type()</code>来判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; type(abs)</div><div class="line">&lt;class &apos;builtin_function_or_method&apos;&gt;</div><div class="line">&gt;&gt;&gt; type(a)</div><div class="line">&lt;class &apos;list&apos;&gt;</div><div class="line">&gt;&gt;&gt; type(c)</div><div class="line">&lt;class &apos;__main__.Dog&apos;&gt;</div></pre></td></tr></table></figure>
<p>但是<code>type()</code>函数返回的是什么类型呢？它返回对应的Class类型。如果我们要在<code>if</code>语句中判断，就需要比较两个变量的type类型是否相同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; type(123)==type(456)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type(123)==int</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type(&apos;123&apos;)==type(&apos;abc&apos;)</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>判断基本数据类型可以直接写<code>int</code>、<code>str</code>等，但如果要判断一个对象是否是函数时，可以使用<code>types</code>模块中定义的常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import types</div><div class="line">&gt;&gt;&gt; def fn():</div><div class="line">...     pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; type(fn)==types.FunctionType</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type(lambda x:x)==types.LambdaType</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType</div><div class="line">True</div></pre></td></tr></table></figure></p>
<h3 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h3><p>对于class的继承关系来说，使用<code>type()</code>就很不方便。我们要判断class的类型，可以使用<code>isinstance()</code>函数。<br>继承关系为：object-&gt;Animal-&gt;Dog-&gt;Husky，那么<code>isinstance()</code>就可以告诉我们一个对象是否是某种类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a=Animal()</div><div class="line">&gt;&gt;&gt; b=Dog()</div><div class="line">&gt;&gt;&gt; c=Husky()</div><div class="line">&gt;&gt;&gt; isinstance(c,Husky)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(c,Dog)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(c,Animal)</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>可以看出虽然c自身是Husky类型，但由于Husky是从Dog上继承下来的，所以c还是Dog类型。也就是说，<code>isinstance()</code>判断的是一个对象是否是该类型本身或者位于该类型的父继承链上。能用<code>type()</code>判断的类型都可以用<code>isinstance()</code>判断，并且还可以判断一个变量是否是某些类型中的一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; isinstance(&apos;a&apos;,str)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(123,int)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance([1,2,3],(list,tuple))</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance((1,2,3),(list,tuple))</div><div class="line">True</div></pre></td></tr></table></figure></p>
<h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; dir(&apos;123&apos;)</div><div class="line">[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__getnewargs__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rmod__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;, &apos;center&apos;, &apos;count&apos;, &apos;encode&apos;, &apos;endswith&apos;, &apos;expandtabs&apos;, &apos;find&apos;, &apos;format&apos;, &apos;format_map&apos;, &apos;index&apos;, &apos;isalnum&apos;, &apos;isalpha&apos;, &apos;isdecimal&apos;, &apos;isdigit&apos;, &apos;isidentifier&apos;, &apos;islower&apos;, &apos;isnumeric&apos;, &apos;isprintable&apos;, &apos;isspace&apos;, &apos;istitle&apos;, &apos;isupper&apos;, &apos;join&apos;, &apos;ljust&apos;, &apos;lower&apos;, &apos;lstrip&apos;, &apos;maketrans&apos;, &apos;partition&apos;, &apos;replace&apos;, &apos;rfind&apos;, &apos;rindex&apos;, &apos;rjust&apos;, &apos;rpartition&apos;, &apos;rsplit&apos;, &apos;rstrip&apos;, &apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;, &apos;swapcase&apos;, &apos;title&apos;, &apos;translate&apos;, &apos;upper&apos;, &apos;zfill&apos;]</div></pre></td></tr></table></figure></p>
<p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动调用该对象的<code>__len__</code>方法，所以下面代码是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; len(&apos;1234&apos;)</div><div class="line">4</div><div class="line">&gt;&gt;&gt; &apos;1234&apos;.__len__()</div><div class="line">4</div></pre></td></tr></table></figure></p>
<p>我们自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class MyDog(object):</div><div class="line">...     def __len__(self):</div><div class="line">...             return 100</div><div class="line">...</div><div class="line">&gt;&gt;&gt; dog=MyDog()</div><div class="line">&gt;&gt;&gt; len(dog)</div><div class="line">100</div></pre></td></tr></table></figure></p>
<p>剩下的都是普通属性或方法，比如<code>lower()</code>返回小写的字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;ADSAFD&apos;.lower()</div><div class="line">&apos;adsafd&apos;</div></pre></td></tr></table></figure></p>
<p>仅仅把属性和方法列出来是不够的，配合<code>getattr()``setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class MyObject(object):</div><div class="line">...     def __init__(self):</div><div class="line">...             self.x=9</div><div class="line">...     def power(self):</div><div class="line">...             return self.x*self.x</div><div class="line">...</div><div class="line">&gt;&gt;&gt; obj=MyObject()</div></pre></td></tr></table></figure></p>
<p>测试该对象的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; hasattr(obj,&apos;x&apos;)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; obj.x</div><div class="line">9</div><div class="line">&gt;&gt;&gt; hasattr(obj,&apos;y&apos;)</div><div class="line">False</div><div class="line">&gt;&gt;&gt; setattr(obj,&apos;y&apos;,19)</div><div class="line">&gt;&gt;&gt; hasattr(obj,&apos;y&apos;)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; getattr(obj,&apos;y&apos;)</div><div class="line">19</div><div class="line">&gt;&gt;&gt; obj.y</div><div class="line">19</div></pre></td></tr></table></figure></p>
<p>如果试图获取不存在的属性，会抛出AttributeError的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; getattr(obj,&apos;g&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">AttributeError: &apos;MyObject&apos; object has no attribute &apos;g&apos;</div></pre></td></tr></table></figure></p>
<p>可以传入一个default参数，如果属性不存在，就返回默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; getattr(obj,&apos;g&apos;,404)</div><div class="line">404</div></pre></td></tr></table></figure></p>
<p>通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象的信息。</p>
<blockquote>
<p>如果可以直接写:<br>sum=obj.x+obj.y<br>就不要写:<br>sum=getattr(obj,’x’)+getattr(obj,’y’)</p>
</blockquote>
<p>一个正确的用法例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def readImage(fp):</div><div class="line">    if hasattr(fp, &apos;read&apos;):</div><div class="line">        return readData(fp)</div><div class="line">    return None</div></pre></td></tr></table></figure></p>
<p>如果我们要从文件流fp中读取图像，首先要判断该fp是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。</p>
<hr>
<h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。<br>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     def __init__(self,name):</div><div class="line">...             self.name=name</div><div class="line">...</div><div class="line">&gt;&gt;&gt; s=Student(&apos;Bob&apos;)</div><div class="line">&gt;&gt;&gt; s.score=90</div></pre></td></tr></table></figure></p>
<p>但是，如果<code>Student</code>类本身需要绑定一个属性的时候可以直接在class中定义属性，这种属性是类属性，归<code>Student</code>所有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Student(object):</div><div class="line">...     name=&apos;sad&apos;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>当我们定义了一个类属性，这个属性虽然归类所有，但类的所有实例都可以访问到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s=Student()</div><div class="line">&gt;&gt;&gt; print(s.name)</div><div class="line">sad</div><div class="line">&gt;&gt;&gt; s.name=&apos;Mick&apos;</div><div class="line">&gt;&gt;&gt; print(s.name)</div><div class="line">Mick</div><div class="line">&gt;&gt;&gt; print(Student.name)</div><div class="line">sad</div><div class="line">&gt;&gt;&gt; del s.name</div><div class="line">&gt;&gt;&gt; print(s.name)</div><div class="line">sad</div></pre></td></tr></table></figure></p>
<p>可以看出，在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的是类属性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/09/1_函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/1_函数/" itemprop="url">1. 函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-09T15:29:57+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>我们知道圆的计算公式是：</p>
<p><strong>S=π<em>r</em>r</strong></p>
<p>当我们知道圆的半径r时，就可以很快的计算出圆的面积：</p>
<blockquote>
<p>r1=12.34<br>s1=3.14<em>r1</em>r1</p>
</blockquote>
<p> 当代码出现规律的重复时，你就需要当心了，每次写<code>3.14*x*x</code>不仅很麻烦，而且，如果要把<code>3.14</code>改为<code>3.14159265359</code> 的时候就要全部替换。</p>
<p>有了函数，我们就不用再每次 再写<code>s=3.14*x*x</code>而是写成更有意义的函数调用<code>s=area_of_circle(x)</code>,而函数<code>area_of _circle(x)</code>本身只需要写一次就可以多次调用。</p>
<p>基本上所有的高级语言都支持函数，Python也不例外。Python不但能非常灵活的定义函数，而且本身内置了很多有用的函数，可以直接调用。</p>
<hr>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><hr>
<p>Python内置了很多有用的函数，我们可以直接调用。</p>
<p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数<code>abs</code>,只有一个参数。可以直接在Python的官方网站查看文档：</p>
<p> <a href="http://docs.python.org/3/library/functions.html#abs" target="_blank" rel="external">http://docs.python.org/3/library/functions.html#abs</a></p>
<p> 也可以在交互式命令行通过<code>help(abs)</code>查看abs函数的帮助信息。<br>调用<code>abs</code>函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">100</span>)</div><div class="line"><span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-256</span>)</div><div class="line"><span class="number">256</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-12.88</span>)</div><div class="line"><span class="number">12.88</span></div></pre></td></tr></table></figure>
<p>调用函数时，如果传入的参数的数量不对，会报<code>TperError</code>的 错误，并且给出错位信息：<code>str</code>是错误的参数类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; abs(&apos;a&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: bad operand type for abs(): &apos;str&apos;</div></pre></td></tr></table></figure>
<p>而<code>max</code>函数<code>max()</code>可以接收任意多个参数，并返回最大的那个：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">65</span>,<span class="number">334</span>)</div><div class="line"><span class="number">334</span></div></pre></td></tr></table></figure>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>Python内置的常用函数还包括数据类型转换函数，比如<code>int()</code>函数可以把其他数据类型转换为整数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'1234'</span>)</div><div class="line"><span class="number">1234</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">12.34</span>)</div><div class="line"><span class="number">12</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>float(<span class="number">12.34</span>)</div><div class="line"><span class="number">12.34</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">1.23</span>)</div><div class="line"><span class="string">'1.23'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">100</span>)</div><div class="line"><span class="string">'100'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">1</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="string">''</span>)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure></p>
<p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个别名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a=abs        <span class="comment">#变量a指向abs函数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">-1</span>)        <span class="comment">#所以可以通过a来调用函数</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>请用Python内置的<code>hex()</code>函数把一个整数转换成十六进制表示的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>n1=<span class="number">255</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>n2=<span class="number">1000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(str(hex(n1)))</div><div class="line"><span class="number">0xff</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(str(hex(n2)))</div><div class="line"><span class="number">0x3e8</span></div></pre></td></tr></table></figure>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><hr>
<p>在Python中，定义一个函数要使用<code>def</code>语句，依次写出函数名，括号，括号中的参数和冒号<code>:</code>，然后在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。</p>
<p>我们自定义一个求绝对值的<code>my_abs</code>函数为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> x&gt;=<span class="number">0</span>:</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> x</div><div class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> -x</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">-1524</span>)</div><div class="line"><span class="number">1524</span></div></pre></td></tr></table></figure>
<blockquote>
<p>请注意，函数内部结构的的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部可以通过条件判断和循环实现非常复杂的逻辑。<br>如果没有<code>return</code>语句，函数执行完也会返回结果，只是结果为<code>None</code>.</p>
</blockquote>
<h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><p>如果想定义一个什么事业不做的空函数，可以用<code>pass</code>语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">pass</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p><code>pass</code>语句什么都不做，有什么用？实际上<code>pass</code>可以用来作为占位符，比如现在还没有想好怎么写函数的代码，可以先放一个<code>pass</code>，让代码能运行起来。</p>
<p><code>pass</code>还可以用在其他语句里，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; <span class="keyword">if</span> age&gt;=<span class="number">18</span>:</div><div class="line">..     <span class="keyword">pass</span></div><div class="line">..</div></pre></td></tr></table></figure></p>
<p>缺少了<code>pass</code>，代码运行就会有语法错误。</p>
<h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>调用函数是，如果参数个数不对，Python解释器会自动检查出来，并抛出<code>TypeError</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">1</span>,<span class="number">12</span>,<span class="number">-5</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: my_abs() takes <span class="number">1</span> positional argument but <span class="number">3</span> were given</div></pre></td></tr></table></figure>
<p>单数如果参数类型不对，Python解释器就无法帮我们检查。试试<code>my_abs</code>和内置函数<code>abs</code>的区别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="string">'x'</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> my_abs</div><div class="line">TypeError: unorderable types: str() &gt;= int()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="string">'x'</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>,   <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: bad operand type <span class="keyword">for</span> abs(): <span class="string">'str'</span></div></pre></td></tr></table></figure>
<blockquote>
<p>当传入了不恰当的参数时，内置函数<code>abs</code>会检查出参数错误，而我们定义的<code>my_abs</code>没有参数检查，会导致<code>if</code>语句出错，出错信息和<code>abs</code>不一样，所以这个函数定义的不够好。<br>让我们修改一下<code>my_abs</code>的定义，对参数进行检查，只允许整数和浮点数类型的参数。数据类型的检查可以用内置函数<code>isinstance()</code>来实现：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x,(int,float)):</div><div class="line"><span class="meta">... </span>            <span class="keyword">raise</span> TypeError(<span class="string">'bad operand type'</span>)</div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> x&gt;=<span class="number">0</span>:</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> x</div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> x&lt;<span class="number">0</span>:</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> -x</div></pre></td></tr></table></figure>
<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>函数可以返回多个值吗？答案是肯定的。</p>
<p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标，位移和角度，就可以计算出新的坐标：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x,y,step,angle=<span class="number">0</span>)</span>:</span></div><div class="line"><span class="meta">... </span>    nx=x+step*math.cos(angle)</div><div class="line"><span class="meta">... </span>    ny=y+step*math.sin(angle)</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> nx, ny</div><div class="line">...</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p><code>import math</code>语句表示导入<code>math</code>包，并允许后续代码引用<code>math</code>包里面的<code>sin</code> ,<code>cos</code>等函数。<br>然后我们就可以同时获得返回值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x,y=move(<span class="number">100</span>,<span class="number">100</span>,<span class="number">60</span>,math.pi/<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(x,y)</div><div class="line"><span class="number">151.96152422706632</span> <span class="number">130.0</span></div></pre></td></tr></table></figure>
<p>但是其实这只是一个假象，Python函数返回的仍然是单一值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r=move(<span class="number">100</span>,<span class="number">100</span>,<span class="number">60</span>,math.pi/<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(r)</div><div class="line">(<span class="number">151.96152422706632</span>, <span class="number">130.0</span>)</div></pre></td></tr></table></figure>
<p>原来返回的是一个tuple，但是，在语法上面，返回一个tuple是可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数的返回多值，实际上就是返回一个tuple，但是写起来方便很多。</p>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quadratic</span><span class="params">(a,b,c)</span>:</span></div><div class="line">	<span class="keyword">if</span> <span class="keyword">not</span> isinstance(a,(int,float)):</div><div class="line">		<span class="keyword">raise</span> TypeError(<span class="string">'输入的数据类型错误'</span>)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">not</span> isinstance(b,(int,float)):</div><div class="line">		<span class="keyword">raise</span> TypeError(<span class="string">'输入的数据类型错误'</span>)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">not</span> isinstance(c,(int,float)):</div><div class="line">		<span class="keyword">raise</span> TypeError(<span class="string">'输入的数据类型错误'</span>)</div><div class="line"></div><div class="line">	d=b*b<span class="number">-4</span>*a*c</div><div class="line"></div><div class="line">	<span class="keyword">if</span> a!=<span class="number">0</span>:</div><div class="line">		<span class="keyword">if</span> d&gt;<span class="number">0</span>:</div><div class="line">			s=<span class="string">'方程有两个不同的实数根'</span></div><div class="line">			x1=(-b+math.sqrt(d))/<span class="number">2</span>/a</div><div class="line">			x2=(-b-math.sqrt(d))/<span class="number">2</span>/a</div><div class="line">			<span class="keyword">return</span> s,x1,x2</div><div class="line">		<span class="keyword">elif</span> d==<span class="number">0</span>:</div><div class="line">			s=<span class="string">'方程有两个相同的实数根'</span></div><div class="line">			x1=-b/<span class="number">2</span>/a</div><div class="line">			x2=-b/<span class="number">2</span>/a</div><div class="line">			<span class="keyword">return</span> s,x1,x2</div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			s=<span class="string">'方程有两个不同的复数根'</span></div><div class="line">			<span class="keyword">return</span> s</div><div class="line">	<span class="keyword">elif</span> b!=<span class="number">0</span>:</div><div class="line">		s=<span class="string">'方程有一个实数根'</span></div><div class="line">		x1=-c/b</div><div class="line">		<span class="keyword">return</span> s,x1</div><div class="line">	<span class="keyword">elif</span> c!=<span class="number">0</span>:</div><div class="line">		s=<span class="string">'方程无解'</span></div><div class="line">		<span class="keyword">return</span> s</div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		s=<span class="string">'方程无意义'</span></div><div class="line">		<span class="keyword">return</span> s</div><div class="line"></div><div class="line">r=quadratic(<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>)</div><div class="line">print(r)</div><div class="line"></div><div class="line"></div><div class="line">F:\python&gt;python jiefangcheng.py</div><div class="line">(<span class="string">'方程有两个不同的实数根'</span>, <span class="number">-0.5857864376269049</span>, <span class="number">-3.414213562373095</span>)</div></pre></td></tr></table></figure>
<hr>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就足够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p>
<p>Python的函数定义非常简单，但灵活度却很大。除了正常定义的必选参数外，还可以使用默认参数，可变参数和关键字参数，是的函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p>
<h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>我们先写一个计算x的平方的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x*x</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>)</div><div class="line"><span class="number">25</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">52</span>)</div><div class="line"><span class="number">2704</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>对于<code>power(x)</code>的函数，参数x就是一个位置参数。当我们调用<code>power</code>函数时，必须传入有且仅有一参数x。</p>
</blockquote>
<p>现在，我们要计算x³怎么办？计算xⁿ怎么办，我们可以把<code>power(x)</code>改为`power(x,n)，用来计算xⁿ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x,n)</span>:</span></div><div class="line"><span class="meta">... </span>    s=<span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</div><div class="line"><span class="meta">... </span>            n=n<span class="number">-1</span></div><div class="line"><span class="meta">... </span>            s=s*x</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> s</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>,<span class="number">5</span>)</div><div class="line"><span class="number">3125</span></div></pre></td></tr></table></figure>
<blockquote>
<p>修改后的<code>power(x,n)</code>函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给x和n。</p>
</blockquote>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>新的<code>power(x,n)</code>函数没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: power() missing <span class="number">1</span> required positional argument: <span class="string">'n'</span></div></pre></td></tr></table></figure>
<p>Python的错误信息很明确：调用函数<code>power( )</code>缺少了一个位置信息n。</p>
<blockquote>
<p>这个时候默认参数就派上用场了。由于我们经常计算x²，所以，完全可以把第二个参数n默认值设为2：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x,n=<span class="number">2</span>)</span>:</span></div><div class="line"><span class="meta">... </span>    s=<span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</div><div class="line"><span class="meta">... </span>            n=n<span class="number">-1</span></div><div class="line"><span class="meta">... </span>            s=s*x</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> s</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>)</div><div class="line"><span class="number">25</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>,<span class="number">5</span>)</div><div class="line"><span class="number">3125</span></div></pre></td></tr></table></figure>
<blockquote>
<p>这个例子可以看出，默认参数可以简化函数的调用。设置默认参数时，要注意以下几点：</p>
<blockquote>
<p>1.必选参数在前，默认参数在后，否则Python的解释器会报错<br>2.如何设置默认参数：<br>把变化大的参数放在前面，变化小的参数放后面。变化小的参数可以做默认参数。</p>
</blockquote>
</blockquote>
<p>使用默认参数的好处是能降低调用函数的难度。</p>
<blockquote>
<p>举个例子，我们写个一年级小学生的注册的函数，需要传入<code>name</code>和<code>gender</code>两个参数：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">enroll</span><span class="params">(name,gender)</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'name:'</span>,name)</div><div class="line"><span class="meta">... </span>    print(<span class="string">'gender:'</span>,gender)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>enroll(<span class="string">'James'</span>,<span class="string">'D'</span>)</div><div class="line">name: James</div><div class="line">gender: D</div></pre></td></tr></table></figure>
<p>这样，调用<code>enroll()</code>函数需要传入两个参数。如果要继续传入年龄，城市信息等信息怎么办？这样会使得调用函数的复杂度大大增大。我们可以把年龄和城市设为默认参数，这样大多数学生注册时不需要提供年龄和城市，只需要提供必需的两个参数，只有与默认的参数不符的学生才需要提供额外信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">enroll</span><span class="params">(name,gender,age=<span class="number">7</span>,city=<span class="string">'Beijing'</span>)</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'name:'</span>,name)</div><div class="line"><span class="meta">... </span>    print(<span class="string">'gender:'</span>,gender)</div><div class="line"><span class="meta">... </span>    print(<span class="string">'age:'</span>,age)</div><div class="line"><span class="meta">... </span>    print(<span class="string">'city:'</span>,city)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>enroll(<span class="string">'James'</span>,<span class="string">'D'</span>)</div><div class="line">name: James</div><div class="line">gender: D</div><div class="line">age: <span class="number">7</span></div><div class="line">city: Beijing</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>enroll(<span class="string">'James'</span>,<span class="string">'D'</span>,<span class="number">6</span>,<span class="string">'Shanghai'</span>)</div><div class="line">name: James</div><div class="line">gender: D</div><div class="line">age: <span class="number">6</span></div><div class="line">city: Shanghai</div></pre></td></tr></table></figure>
<p>可见，默认参数降低了函数的复杂度，而一旦函数需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p>
<p>有多个默认参数时，调用的时候，既可以按照顺序提供默认参数，比如调用<code>enroll(&#39;Bob&#39;,&#39;M&#39;,7)</code>，意思是除了<code>name</code>和<code>gender</code>两个参数外，最后一个参数应用在参数<code>age</code>上，<code>city</code>上则使用默认值。</p>
<p>也可以不按照顺序提供默认参数。当不按照顺序提供默认参数的时候，需要把参数名写上。比如调用<code>enroll(&#39;Adam&#39;,&#39;B&#39;,city=&#39;Tianjin&#39;)</code>，意思是city参数用传进去的值，其他默认参数继续使用默认值。</p>
<p>默认参数使用很有效，但是使用不当也会产生误导，如下：</p>
<p>先定义一个函数，传入一个list，添加一个<code>END</code>再返回：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=[])</span>:</span></div><div class="line"><span class="meta">... </span>    L.append(<span class="string">'END'</span>)</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> L</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">'END'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end([<span class="string">'x'</span>,<span class="string">'t'</span>,<span class="string">'xc'</span>])</div><div class="line">[<span class="string">'x'</span>, <span class="string">'t'</span>, <span class="string">'xc'</span>, <span class="string">'END'</span>]</div></pre></td></tr></table></figure></p>
<p>调用没有问题，一开始调用默认参数也没有问题，但是再调用<code>add_end()</code>时，结果就不对了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>, <span class="string">'END'</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p>这是因为Python在函数定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是定义的<code>[]</code>了，所以定义默认参数时要牢记一点：<code>默认参数必须指向不变对象来实现！</code></p>
</blockquote>
<p>可以用<code>None</code>来修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line"><span class="meta">... </span>            L=[]</div><div class="line"><span class="meta">... </span>    L.append(<span class="string">'END'</span>)</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> L</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end([<span class="string">'x'</span>,<span class="number">5</span>,<span class="string">'dfs'</span>])</div><div class="line">[<span class="string">'x'</span>, <span class="number">5</span>, <span class="string">'dfs'</span>, <span class="string">'END'</span>]</div></pre></td></tr></table></figure>
<p>设计<code>str</code>,<code>None</code>这样的不变对象的目的在于：不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读取一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，就尽量设计成不变的对象。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入参数的个数是可变的，可以是1个，2个，到任意个。</p>
<p>我们以数学题为例，给定一组数字a,b,c……，计算a²＋b²＋c²＋……。</p>
<p>要定义出这个函数，我们必须确定输入的从参数。由于参数的个数不确定，我们首先想到把a,b,c,……作为一个list或者 tuple传进来，这样函数可以定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(numbers)</span>:</span></div><div class="line"><span class="meta">... </span>    sum=<span class="number">0</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</div><div class="line"><span class="meta">... </span>            sum=sum+n*n</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> sum</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cal([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line"><span class="number">14</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cal([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</div><div class="line"><span class="number">285</span></div></pre></td></tr></table></figure>
<p>但是这样调用的时候需要先组装成一个list和tuple，如果利用可变参数，调用函数的方式可以变为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(*numbers)</span>:</span></div><div class="line"><span class="meta">... </span>    sum=<span class="number">0</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</div><div class="line"><span class="meta">... </span>            sum=sum+n*n</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> sum</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cal(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="number">14</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cal()</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<p>定义可变参数和定义一个list或者tuple相比，仅仅在参数前面加了个*号，在函数内部，参数<code>numbers</code>接受到的是一个tuple，因此，函数代码完全不变，但是，调用该函数时，可以传入任意个参数，包括零个参数。</p>
<p>如果已经有了一个list或者tuple，要调用一个可变参数时，可以这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cal(*numbers)</div><div class="line"><span class="number">30</span></div></pre></td></tr></table></figure>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>可变参数允许传入0个或者任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装成一个dictionary：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name,age,**kw)</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'name:'</span>,name,<span class="string">'age:'</span>,age,<span class="string">'others:'</span>,kw)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Mike'</span>,<span class="number">30</span>)</div><div class="line">name: Mike age: <span class="number">30</span> others: &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'james'</span>,<span class="number">22</span>,city=<span class="string">'Beijing'</span>)</div><div class="line">name: james age: <span class="number">22</span> others: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'james'</span>,<span class="number">22</span>,city=<span class="string">'Beijing'</span>,gender=<span class="string">'b'</span>)</div><div class="line">name: james age: <span class="number">22</span> others: &#123;<span class="string">'gender'</span>: <span class="string">'b'</span>, <span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</div></pre></td></tr></table></figure>
<p>函数<code>person</code>除了必选参数<code>name</code>和<code>age&#39;</code>之外，还可以接受关键字参数<code>kw</code>。在调用函数时，可以只传入必选参数，也可以传入任意个数的关键字参数。</p>
<p>关键字参数可以扩展函数的功能。比如，在<code>person</code>函数里，我们保证能接收到<code>name</code>和<code>age</code>两个参数，但是如果调用者愿意提供更多的参数，我们也能接收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填选项，其他都是可选项，利用关键字这个函数就可以很容易满足注册的需求。</p>
<p>和可变参数类似，也可以先组装一个dict，然后把该dict转换为关键字参数传入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>extra=&#123;<span class="string">'city'</span>:<span class="string">'beijing'</span>,<span class="string">'job'</span>:<span class="string">'teacher'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'jack'</span>,<span class="number">24</span>,**extra)</div><div class="line">name: jack age: <span class="number">24</span> others: &#123;<span class="string">'job'</span>: <span class="string">'teacher'</span>, <span class="string">'city'</span>: <span class="string">'beijing'</span>&#125;</div></pre></td></tr></table></figure>
<p><code>**extra</code>表示把<code>extra</code>这个dict的所有key-value用关键字参数传入到<code>**kw</code>中，<code>kw</code>将获得一个dict，注意<code>kw</code>获得的dict是<code>extra</code>的一个拷贝，对<code>kw</code>的改动不会影响到原始数据。</p>
<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>对于关键字参数，函数调用者可以传入任意不受限制的关键字采纳数。至于到底传入了哪些，需要函数内部通过<code>kw</code>检查。仍以<code>person</code>为例，我们希望检查是否有<code>city</code>和<code>job</code>的参数,这时候仍可以传入不受限制的关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name,age,**kw)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="string">'city'</span> <span class="keyword">in</span> kw:</div><div class="line"><span class="meta">... </span>            <span class="keyword">pass</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="string">'job'</span> <span class="keyword">in</span> kw:</div><div class="line"><span class="meta">... </span>            <span class="keyword">pass</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'name:'</span>,name,<span class="string">'age:'</span>,age,<span class="string">'others:'</span>,kw)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'james'</span>,<span class="number">22</span>,city=<span class="string">'Beijing'</span>,gender=<span class="string">'b'</span>)</div><div class="line">name: james age: <span class="number">22</span> others: &#123;<span class="string">'gender'</span>: <span class="string">'b'</span>, <span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'james'</span>,<span class="number">22</span>,city=<span class="string">'Beijing'</span>,job=<span class="string">'teacher'</span>)</div><div class="line">name: james age: <span class="number">22</span> others: &#123;<span class="string">'job'</span>: <span class="string">'teacher'</span>, <span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</div></pre></td></tr></table></figure>
<p>如果我们要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收<code>city</code>和<code>job</code>作为关键字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name,age,*,city,job)</span>:</span></div><div class="line"><span class="meta">... </span>    print(name,age,city,job)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'james'</span>,<span class="number">22</span>,city=<span class="string">'Beijing'</span>,job=<span class="string">'teacher'</span>)</div><div class="line">james <span class="number">22</span> Beijing teacher</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'james'</span>,<span class="number">22</span>,city=<span class="string">'Beijing'</span>,gender=<span class="string">'b'</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: person() got an unexpected keyword argument <span class="string">'gender'</span></div></pre></td></tr></table></figure>
<p>和关键字参数<strong>kw不同，命名关键字需要一个特殊分隔符<code>*</code>,<code>*</code>后面的参数为命名关键字参数，如果函数定义中已经有一个可变参数，后面就不需要一个特殊分隔符<code>*</code>。
</strong>命名关键字可以有缺省**可以简化调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name,age,*,city=<span class="string">'beijing'</span>,job)</span>:</span></div><div class="line"><span class="meta">... </span>    print(name,age,city,job)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>,<span class="number">24</span>,job=<span class="string">'Engineer'</span>)</div><div class="line">Jack <span class="number">24</span> beijing Engineer</div></pre></td></tr></table></figure>
<p><strong>使用命名关键字参数时需要注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，Python解释器将无法识别位置参数和命名关键字参数</strong></p>
<h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>在Python中定义函数，可以选用必选参数，默认参数，可变参数，关键字参数和命名关键字参数，这五种参数都可以组合使用。但是请注意，参数定义的顺序是：必选参数，默认参数，可变参数，命名关键字参数和关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a,b,c=<span class="number">0</span>,*args,**kw)</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'a='</span>,a, <span class="string">'b='</span>,b, <span class="string">'c='</span>,c, <span class="string">'args='</span>,args, <span class="string">'kw='</span>,kw)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a,b,c=<span class="number">0</span>,*,d,**kw)</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'a='</span>,a, <span class="string">'b='</span>,b, <span class="string">'c='</span>,c, <span class="string">'d='</span>,d, <span class="string">'kw='</span>,kw)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">a= <span class="number">1</span> b= <span class="number">2</span> c= <span class="number">0</span> args= () kw= &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>)</div><div class="line">a= <span class="number">1</span> b= <span class="number">2</span> c= <span class="number">3</span> args= () kw= &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'a'</span>,<span class="string">'b'</span>)</div><div class="line">a= <span class="number">1</span> b= <span class="number">2</span> c= <span class="number">3</span> args= (<span class="string">'a'</span>, <span class="string">'b'</span>) kw= &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,x=<span class="number">999</span>)</div><div class="line">a= <span class="number">1</span> b= <span class="number">2</span> c= <span class="number">3</span> args= (<span class="string">'a'</span>, <span class="string">'b'</span>) kw= &#123;<span class="string">'x'</span>: <span class="number">999</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">1</span>,<span class="number">2</span>,d=<span class="number">99</span>,ext=<span class="keyword">None</span>)</div><div class="line">a= <span class="number">1</span> b= <span class="number">2</span> c= <span class="number">0</span> d= <span class="number">99</span> kw= &#123;<span class="string">'ext'</span>: <span class="keyword">None</span>&#125;</div></pre></td></tr></table></figure>
<p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去，最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>args=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>kw=&#123;<span class="string">'d'</span>:<span class="number">88</span>,<span class="string">'x'</span>:<span class="string">'#'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1(*args,**kw)</div><div class="line">a= <span class="number">1</span> b= <span class="number">2</span> c= <span class="number">3</span> args= (<span class="number">4</span>,) kw= &#123;<span class="string">'d'</span>: <span class="number">88</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>args=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>kw=&#123;<span class="string">'d'</span>:<span class="number">88</span>,<span class="string">'x'</span>:<span class="string">'#'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2(*args,**kw)</div><div class="line">a= <span class="number">1</span> b= <span class="number">2</span> c= <span class="number">3</span> d= <span class="number">88</span> kw= &#123;<span class="string">'x'</span>: <span class="string">'#'</span>&#125;</div></pre></td></tr></table></figure>
<p>所以，对于任意函数，都可以通过类似<code>func(*args,**kw)</code>的形式调用它，无论他的参数是如何定义的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。默认参数一定要用不可变对象，如果是可变对象程序运行时会出现逻辑错误！</p>
<p>要注意定义可变参数和关键字参数的语法：</p>
<p><code>*args</code>是可变参数，args接收的是一个tuple；</p>
<p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p>
<p>以及调用函数时如何传入可变参数和关键字参数的语法：</p>
<p>可变参数既可以直接传入：<code>func(1,2,3)</code>，又可以先组装list或者tuple，再通过<code>*args</code>传入：<code>func(*(1,2,3))</code>;</p>
<p>关键字参数既可以直接传入：<code>func(a=1,b=2)</code>又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;:1,&#39;b&#39;:2})</code>。</p>
<p>使用<code>*args</code>和<code>**kw</code>是Python的习惯洗发，当然也可以用其他参数名，但是最好使用习惯用法。命名关键字参数时为了限制调用者可以传入的参数名，同时也可以提供默认值。</p>
<p>定义命名的关键字参数在没有可变参数的情况下不要忘记加分隔符<code>*</code>。</p>
<hr>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自己本身，这个函数就是递归函数。举个例子，我们计算阶乘<code>n!=1*2*3*...*n</code>，用函数<code>fact()</code>来表示，可以看出：fact(n)=n!=1<em>2</em>3<em>…</em>n=fact(n-1)<em>n，所以fact(n)可以表示为`n</em>fact(n-1)`,只有在n=1时需要特殊处理。于是，fact(n)用递归的方式写出来就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> n==<span class="number">1</span>:</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> <span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> n*fact(n<span class="number">-1</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">1</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">100</span>)</div><div class="line"><span class="number">93326215443944152681699238856266700490715968264381621468592963895217599993229915</span></div><div class="line"><span class="number">608941463976156518286253697920827223758251185210916864000000000000000000000000</span></div></pre></td></tr></table></figure>
<p>递归函数的优点是定义简单，逻辑清楚。理论上，所有的递归函数都可以写成循环的方式，但是循环的逻辑不如递归的逻辑清楚。</p>
<p>使用递归函数是需要防止栈溢出。在计算机中，函数调用时通过栈这种数据结构来实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以递归的次数过多，会导致栈溢出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> fact</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> fact</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> fact</div><div class="line">RecursionError: maximum recursion depth exceeded <span class="keyword">in</span> comparison</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">5000</span>)</div></pre></td></tr></table></figure>
<p>解决递归调用栈溢出的方法是通过<strong>尾递归</strong>优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归也是可以的。</p>
<p>尾递归是指，在函数返回的时候，调用函数本身，并且return语句不能包含表达式。这样，编译器或者解释器就可以吧尾递归做优化，使递归本身无论调用多少次，都只占一个栈帧，不会出现栈溢出的情况。</p>
<p>上面的<code>fact(n)</code>函数由于<code>return n*fact(n-1)</code>引入了乘法表达式，所以就不是尾递归了。要改成尾递归的方式，需要多一点代码，主要是把每一步的成绩传入到递归函数中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> fact_iter(n,<span class="number">1</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span><span class="params">(num,product)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> num==<span class="number">1</span>:</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> product</div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> fact_iter(num<span class="number">-1</span>,num*product)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>可以看到，<code>return fact_iter(num-1,num*product)</code>仅仅返回递归函数本身，<code>num-1</code>和<code>num*product</code>在函数调用前就会被计算出来，不会影响函数调用。</p>
<p><code>fact(5)</code>对应的<code>fact_iter(5,1)</code>的调用如下：</p>
<blockquote>
<p>fact_iter(5,1)<br>fact_iter(4,5)<br>fact_iter(3,20)<br>fact_iter(2,60)<br>fact_iter(1,120)<br>120</p>
</blockquote>
<p>尾递归调用时，如果做了优化，栈就不会增长，因此，无论多少次调用都不会导致栈溢出。</p>
<p>遗憾的是，大多数编程语言都没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的<code>fact(n)</code>函数改为尾递归方式，也会导致栈溢出。</p>
<h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><p>汉诺塔的移动可以用递归函数非常简单的实现，请编写move函数，它接收参数n，表示3个柱子A,B,C中第一个柱子A的盘子数量，然后打印出所有盘子从A借助B移动到C的方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(n, a, b, c)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line"><span class="meta">... </span>        print(<span class="string">'move'</span>, a, <span class="string">'--&gt;'</span>, c)</div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span></div><div class="line"><span class="meta">... </span>    move(n<span class="number">-1</span>, a, c, b)</div><div class="line"><span class="meta">... </span>    print(<span class="string">'move'</span>, a, <span class="string">'--&gt;'</span>, c)</div><div class="line"><span class="meta">... </span>    move(n<span class="number">-1</span>, b, a, c)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>move(<span class="number">4</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</div><div class="line">move A --&gt; B</div><div class="line">move A --&gt; C</div><div class="line">move B --&gt; C</div><div class="line">move A --&gt; B</div><div class="line">move C --&gt; A</div><div class="line">move C --&gt; B</div><div class="line">move A --&gt; B</div><div class="line">move A --&gt; C</div><div class="line">move B --&gt; C</div><div class="line">move B --&gt; A</div><div class="line">move C --&gt; A</div><div class="line">move B --&gt; C</div><div class="line">move A --&gt; B</div><div class="line">move A --&gt; C</div><div class="line">move B --&gt; C</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/09/2.高级特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/2.高级特性/" itemprop="url">2.高级特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-09T15:29:57+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><p>掌握了Python的数据类型，语句和函数，基本上就可以编出很多有用的程序了，比如构造一个<code>1,3,5,...,99</code>的列表，可以通过循环实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L=[]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>n=<span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> n&lt;=<span class="number">99</span>:</div><div class="line"><span class="meta">... </span>    L.append(n)</div><div class="line"><span class="meta">... </span>    n=n+<span class="number">2</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(L)</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">25</span>, <span class="number">27</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">39</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">45</span>, <span class="number">47</span>, <span class="number">49</span>, <span class="number">51</span>, <span class="number">53</span>, <span class="number">55</span>, <span class="number">57</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">63</span>, <span class="number">65</span>, <span class="number">67</span>, <span class="number">69</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">75</span>, <span class="number">77</span>, <span class="number">79</span>, <span class="number">81</span>, <span class="number">83</span>, <span class="number">85</span>, <span class="number">87</span>, <span class="number">89</span>, <span class="number">91</span>, <span class="number">93</span>, <span class="number">95</span>, <span class="number">97</span>, <span class="number">99</span>]</div></pre></td></tr></table></figure>
<p>取list的前一半元素，也可以通过循环实现。</p>
<p>但是Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。</p>
<p>基于这一思想，我们开始介绍Python中非常有用的高级特性，1行代码能实现的功能，绝对不用五行代码。</p>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>取一个list或者tuple的部分元素是非常常见的操作，比如，一个list如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">L=[<span class="string">'Michael'</span>,<span class="string">'Sarah'</span>,<span class="string">'Tracy'</span>,<span class="string">'Bob'</span>,<span class="string">'Jack'</span>]</div></pre></td></tr></table></figure>
<p>取前三个元素，应该怎么办？</p>
<p>笨方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> Q=[L[<span class="number">0</span>],L[<span class="number">1</span>],L[<span class="number">2</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(Q)</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure></p>
<p>该方法如果扩展之后让去N个元素就没有办法了。取N个元素，也就是取序号为0-N-1的元素，可以用循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r=[]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>n=<span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>i=<span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> i&lt;n:</div><div class="line"><span class="meta">... </span>    r.append(L[i])</div><div class="line"><span class="meta">... </span>    i=i+<span class="number">1</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(r)</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p> 或者：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r=[]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>n=<span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line"><span class="meta">... </span>    r.append(L[i])</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p>对这种经常取指定索引范围的操作，用循环身份繁琐，因此，Python提供了切片（slice）操作符，能大大简化这种操作。</p>
<p>对应上面的问题，取前三个元素，用一行代码就可以搞定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">3</span>]</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>:<span class="number">3</span>]</div><div class="line">[<span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">3</span>]</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure>
<p><code>L[0:3]</code>表示，从索引0开始取，取到索引3为止，但不包括3.即索引取0,1,2，正好是三个元素。如果第一个索引是0，还可以省略，也可以从索引1开始，取出两个元素。</p>
<p>类似的，既然Python支持<code>L[-1]</code>取出倒数第一个元素，那么他同样支持倒数切片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-3</span>:<span class="number">-1</span>]</div><div class="line">[<span class="string">'Tracy'</span>, <span class="string">'Bob'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-5</span>:]</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</div></pre></td></tr></table></figure>
<p>切片操作十分有用。我们先创建一个0-99的数列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L=list(range(<span class="number">100</span>))</div></pre></td></tr></table></figure>
<p>可以通过切片取出某一段数列，比如前十个，后十个，11-20等：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>]</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-10</span>:]</div><div class="line">[<span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">10</span>:<span class="number">20</span>]</div><div class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</div></pre></td></tr></table></figure></p>
<p>前十个数，每两个去一个：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>:<span class="number">2</span>]</div><div class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure></p>
<p>所有数，每五个取一个：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[::<span class="number">5</span>]</div><div class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>]</div></pre></td></tr></table></figure></p>
<p>如果什么都不写，只写<code>[:]</code>就可以复制一个list。</p>
<p>tuple也是list的一种，唯一区别是tuple不可变。因此tuple也可以用切片操作，操作的结果仍然是tuple：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t=tuple(range(<span class="number">20</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t[:<span class="number">3</span>]</div><div class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">-12</span>:<span class="number">-3</span>]</div><div class="line">(<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>)</div></pre></td></tr></table></figure>
<p>字符串<code>xxx</code>也可以看成是一种list，每一个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍然是字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>h=<span class="string">'abcdefghi'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>h[:<span class="number">4</span>]</div><div class="line"><span class="string">'abcd'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>h[<span class="number">2</span>:<span class="number">8</span>:<span class="number">2</span>]</div><div class="line"><span class="string">'ceg'</span></div></pre></td></tr></table></figure>
<p>在许多编程语言中，针对字符串提供了很多种截取函数，如substring，其实目的就是对字符串进行切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p>
<blockquote>
<p>小结<br>有了切片操作，很多地方循环就不需要了。Python的切片非常灵活，一行代码就可以实现多行循环才能完成的操作</p>
</blockquote>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>如果给定一个list或者tuple，我们可以通过<code>for</code>循环来遍历这个list或者tuple，这种遍历我们称为迭代（iteration）。</p>
<p>在Python中，迭代是通过<code>for...in</code>来完成的，而很多语言如Java，迭代是通过下标完成的，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;list.length;i++)&#123;</div><div class="line">	n=list[i]</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>可以看出，Python的<code>for</code>循环抽象程度要高于Java的<code>for</code>循环，因为Python的for循环不仅可以用于list或tuple上，还可以用于其他可迭代对象上，list这种数据类型虽然有下标，但很多其他数据类型是没有下标的。只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> d:</div><div class="line"><span class="meta">... </span>    print(key)</div><div class="line">...</div><div class="line">c</div><div class="line">a</div><div class="line">b</div></pre></td></tr></table></figure>
<p>其中因为dict的存储不是按照list的方式顺序排列，所以迭代出来的顺序很可能不一样。默认情况下，dict迭代的是key。如果要迭代value，可以用<code>for value in d.values()</code>，如果要同时迭代key和value，可以用<code>for k,v in d.items()</code>。</p>
<p>由于字符串也是可迭代对象，因此，也可以用作<code>for</code>循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'abcdnf'</span>:</div><div class="line"><span class="meta">... </span>    print(ch)</div><div class="line">...</div><div class="line">a</div><div class="line">b</div><div class="line">c</div><div class="line">d</div><div class="line">n</div><div class="line">f</div></pre></td></tr></table></figure>
<p>所以，当我们使用<code>for</code>循环时，只要作用于一个可迭代对象，<code>for</code>循环就可以正常运行，而我们不太关心该对象是list还是其他的数据类型。</p>
<p>如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from collections import Iterable</div><div class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;,Iterable) #str是否可迭代</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance([1,2,3,4],Iterable) #str是否可迭代</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(123,Iterable) #str是否可迭代</div><div class="line">False</div></pre></td></tr></table></figure>
<p>如果对list实现类似Java那样的下标循环怎么办？Python中内置的<code>enumerate</code>函数可以把一个list编程索引-元素对，这样就可以在<code>for</code>循环中同事迭代索引和元素本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; for i, value in enumerate([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]):</div><div class="line">...     print(i,value)</div><div class="line">...</div><div class="line">0 a</div><div class="line">1 b</div><div class="line">2 c</div><div class="line">3 d</div><div class="line">4 e</div></pre></td></tr></table></figure>
<p>上面的<code>for</code>循环里，同时引用了两个变量，在Python里面是很常见的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; for x,y in [(1,2),(3,4),(5,6),(7,8)]:</div><div class="line">...     print(x,y)</div><div class="line">...</div><div class="line">1 2</div><div class="line">3 4</div><div class="line">5 6</div><div class="line">7 8</div></pre></td></tr></table></figure>
<blockquote>
<p>小结<br>任何可迭代对象都可以作用于<code>for</code>循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用<code>for</code>循环。</p>
</blockquote>
<hr>
<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>,<span class="number">11</span>))</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div></pre></td></tr></table></figure>
<p>但是如果要生成<code>[1*1,2*2,3*3,...,10*10]</code>，方法一是循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L=[]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</div><div class="line"><span class="meta">... </span>    L.append(x*x)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</div></pre></td></tr></table></figure>
<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>)]</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</div></pre></td></tr></table></figure>
<p>写列表生成式时，把要生成的元素<code>x*x</code>放在前面，后面跟上<code>for</code>循环，就可以把list创建出来。</p>
<p>for循环后面还可以加上if判断，这样我们局可以筛选出仅偶数的平方：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>]</div><div class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</div></pre></td></tr></table></figure>
<p>还可以使用两层循环，可以生成全排列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x+y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abcd'</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">'ABCD'</span>]</div><div class="line">[<span class="string">'aA'</span>, <span class="string">'aB'</span>, <span class="string">'aC'</span>, <span class="string">'aD'</span>, <span class="string">'bA'</span>, <span class="string">'bB'</span>, <span class="string">'bC'</span>, <span class="string">'bD'</span>, <span class="string">'cA'</span>, <span class="string">'cB'</span>, <span class="string">'cC'</span>, <span class="string">'cD'</span>, <span class="string">'dA'</span>, <span class="string">'dB'</span>, <span class="string">'dC'</span>, <span class="string">'dD'</span>]</div></pre></td></tr></table></figure>
<p>三层和三层以上的循环就很少用了。</p>
<p>运用列表生成式可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; <span class="keyword">import</span> os</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>)]</div><div class="line">[<span class="string">'3D Objects'</span>, <span class="string">'AppData'</span>, <span class="string">'Application Data'</span>, <span class="string">'Contacts'</span>, <span class="string">'Cookies'</span>, <span class="string">'Desktop'</span>, <span class="string">'Documents'</span>, <span class="string">'Downloads'</span>, <span class="string">'Favorites'</span>, <span class="string">'IntelGraphicsProfiles'</span>, <span class="string">'Links'</span>, <span class="string">'Local Settings'</span>, <span class="string">'Music'</span>, <span class="string">'My Documents'</span>, <span class="string">'NetHood'</span>, <span class="string">'NTUSER.DAT'</span>, <span class="string">'ntuser.dat.LOG1'</span>, <span class="string">'ntuser.dat.LOG2'</span>, <span class="string">'NTUSER.DAT&#123;eccc1a56-42ca-11e6-9cd4-bf9ec156b7db&#125;.TM.blf'</span>, <span class="string">'NTUSER.DAT&#123;eccc1a56-42ca-11e6-9cd4-bf9ec156b7db&#125;.TMContainer00000000000000000001.regtrans-ms'</span>, <span class="string">'NTUSER.DAT&#123;eccc1a56-42ca-11e6-9cd4-bf9ec156b7db&#125;.TMContainer00000000000000000002.regtrans-ms'</span>, <span class="string">'ntuser.ini'</span>, <span class="string">'OneDrive'</span>, <span class="string">'Pictures'</span>, <span class="string">'PrintHood'</span>, <span class="string">'Recent'</span>, <span class="string">'Saved Games'</span>, <span class="string">'Searches'</span>, <span class="string">'SendTo'</span>, <span class="string">'Templates'</span>, <span class="string">'Videos'</span>, <span class="string">'「开始」菜单'</span>]</div></pre></td></tr></table></figure>
<p><code>for</code>循环其实可以同时使用两个甚至多个变量，如<code>dict</code>的<code>items()</code>可以同时迭代key和value：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</div><div class="line"><span class="meta">... </span>    print(k,<span class="string">'='</span>,v)</div><div class="line">...</div><div class="line">c = <span class="number">3</span></div><div class="line">a = <span class="number">1</span></div><div class="line">b = <span class="number">2</span></div></pre></td></tr></table></figure>
<p>因此列表生成式也可以使用两个变量来生成list：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="string">'a'</span>:<span class="string">'b'</span>,<span class="string">'c'</span>:<span class="string">'v'</span>,<span class="string">'d'</span>:<span class="string">'g'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">'='</span> + v <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items()]</div><div class="line">[<span class="string">'d=g'</span>, <span class="string">'c=v'</span>, <span class="string">'a=b'</span>]</div></pre></td></tr></table></figure>
<p>最后把一个list中的所有字符串变为小写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L=[<span class="string">'Hello'</span>,<span class="string">'DSFA'</span>,<span class="string">'DFAC'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]</div><div class="line">[<span class="string">'hello'</span>, <span class="string">'dsfa'</span>, <span class="string">'dfac'</span>]</div></pre></td></tr></table></figure>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p> L1=[‘Hello’,’World’,18,’Apple’,None]，添加if语句，期待L2=[‘hello’, ‘world’, ‘apple’]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L2=[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L1 <span class="keyword">if</span> isinstance(s,str)]</div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L2</div><div class="line">[<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'apple'</span>]</div></pre></td></tr></table></figure>
<hr>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>通过列表生成式，我们可以直接创建一个列表。但是受到内存的限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的空间，如果我们仅仅需要访问前面几个元素，后面的绝大多数元素占用的空间就被白白浪费了。</p>
<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环过程中不断推算出后面的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p>
<p>要创建一个generator，有很多中方法。第一种很简答，只要把一个列表生成式的<code>[]</code> 改为<code>()</code>，就创建了一个generator：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>g=(x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>g</div><div class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x0000020E84788E60</span>&gt;</div></pre></td></tr></table></figure>
<p>可以看出创建<code>L</code>和<code>g</code>的区别仅在于最外层是<code>[]</code>还是<code>()</code>，<code>L</code>是一个list，而g是一个generator。我们可以直接打出list的么一个元素，但是我们怎么打出generator的每一个元素呢，如果要一个一个打，可以通过<code>next()</code>函数来获得generator的下一个返回值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">16</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">25</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">36</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">49</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">64</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">81</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div></pre></td></tr></table></figure>
<p>我们前面讲过，generator保存的是算法，每次调用<code>next(g)</code>，就计算出下一个<code>g</code>的值，直到计算到最后一个元素，没有更多的元素时，抛出<code>stopiteration</code>的错误。generator非常强大，如果推算的算法比较复杂，用类似列表生成式的<code>for</code>循环无法实现的时候，还可以用函数来实现。比如著名的斐波拉契数列（Fibonacci），除了第一个和第二个数外，任意一个数可由前面两个数相加得到：<br>1,1,2,3,5,8,13,21,34…</p>
<p>斐波拉契数列用列表生成式写不出来，但是，用函数可以把它打印出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></div><div class="line"><span class="meta">... </span>    n,a,b=<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">while</span> n&lt;max:</div><div class="line"><span class="meta">... </span>            print(b)</div><div class="line"><span class="meta">... </span>            a,b=b,a+b</div><div class="line"><span class="meta">... </span>            n=n+<span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">'done'</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">10</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="number">13</span></div><div class="line"><span class="number">21</span></div><div class="line"><span class="number">34</span></div><div class="line"><span class="number">55</span></div><div class="line"><span class="string">'done'</span></div></pre></td></tr></table></figure>
<p>仔细看，<code>fib</code>函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑非常类似generator。也就是说，上面个的函数和generator只有一步之遥。要把<code>fib</code>变为generator，只需要把<code>print(b)</code>改为<code>yield b</code>就可以了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></div><div class="line"><span class="meta">... </span>    n,a,b=<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">while</span> n&lt;max:</div><div class="line"><span class="meta">... </span>            <span class="keyword">yield</span> b</div><div class="line"><span class="meta">... </span>            a,b=b,a+b</div><div class="line"><span class="meta">... </span>            n=n+<span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">'done'</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">10</span>)</div><div class="line">&lt;generator object fib at <span class="number">0x0000020E84788BA0</span>&gt;</div></pre></td></tr></table></figure>
<p>这就是定义generator的另一种方法。如果一个函数定义包含关键字<code>yield</code>，那么这个函数就不再是一个普通的函数，而是一个generator。</p>
<p>这里最难理解的是generator和函数的执行流程不一样。函数是顺序执行的，遇到return语句或者最后一行函数语句就返回。而变为generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的yield语句出继续执行。</p>
<p>举个例子，定义一个generator，一次返回数字1,3,5：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">odd</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'step1'</span>)</div><div class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'step2'</span>)</div><div class="line"><span class="meta">... </span>    <span class="keyword">yield</span> (<span class="number">3</span>)</div><div class="line"><span class="meta">... </span>    print(<span class="string">'step3'</span>)</div><div class="line"><span class="meta">... </span>    <span class="keyword">yield</span> (<span class="number">5</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>o=odd()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(o)</div><div class="line">step1</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(o)</div><div class="line">step2</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(o)</div><div class="line">step3</div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(o)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">StopIteration</div></pre></td></tr></table></figure>
<p>可以看出，<code>odd()</code>不是普通函数，而是generator，在执行过程中，遇到yield就会中断，下次又继续执行。执行3次之后，没有<code>yield</code>可以执行了，所以第四次调用<code>next(o)</code>就报错。回到<code>fib</code>的例子，我们在循环过程中不断用<code>yield</code>，就会不断中断。当然要给循环设置一个条件来跳出循环，不然就会产生一个无限数列出来。同样的，把函数改为generator之后，我们基本上从来不会用<code>next()</code>来获取下一个返回值，而是直接使用<code>for</code>循环来迭代。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span>  n <span class="keyword">in</span> fib(<span class="number">10</span>):</div><div class="line"><span class="meta">... </span>    print(n)</div><div class="line">...</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="number">13</span></div><div class="line"><span class="number">21</span></div><div class="line"><span class="number">34</span></div><div class="line"><span class="number">55</span></div></pre></td></tr></table></figure>
<p>但是使用<code>for</code>循环时，发现拿不到generator的<code>return</code>语句的返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f=fib(<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</div><div class="line"><span class="meta">... </span>            x=next(f)</div><div class="line"><span class="meta">... </span>            print(<span class="string">'g'</span>,x)</div><div class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</div><div class="line"><span class="meta">... </span>            print(<span class="string">'Generator return value:'</span>,e.value)</div><div class="line"><span class="meta">... </span>            <span class="keyword">break</span></div><div class="line">...</div><div class="line">g <span class="number">1</span></div><div class="line">g <span class="number">1</span></div><div class="line">g <span class="number">2</span></div><div class="line">g <span class="number">3</span></div><div class="line">g <span class="number">5</span></div><div class="line">g <span class="number">8</span></div><div class="line">Generator <span class="keyword">return</span> value: done</div></pre></td></tr></table></figure>
<blockquote>
<p>练习<br>杨辉三角，把每一行看做一个list，试着写一个generator，不断输出下一行的list：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">tri</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    L=[<span class="number">1</span>]</div><div class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line"><span class="meta">... </span>            <span class="keyword">yield</span> L</div><div class="line"><span class="meta">... </span>            L=[L[x]+L[x+<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> range(len(L)<span class="number">-1</span>)]</div><div class="line"><span class="meta">... </span>            L.insert(<span class="number">0</span>,<span class="number">1</span>)</div><div class="line"><span class="meta">... </span>            L.append(<span class="number">1</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>n=<span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> t <span class="keyword">in</span> tri():</div><div class="line"><span class="meta">... </span>    print(t)</div><div class="line"><span class="meta">... </span>    n=n+<span class="number">1</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> n==<span class="number">10</span>:</div><div class="line"><span class="meta">... </span>            <span class="keyword">break</span></div><div class="line">...</div><div class="line">[<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">28</span>, <span class="number">56</span>, <span class="number">70</span>, <span class="number">56</span>, <span class="number">28</span>, <span class="number">8</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">1</span>, <span class="number">9</span>, <span class="number">36</span>, <span class="number">84</span>, <span class="number">126</span>, <span class="number">126</span>, <span class="number">84</span>, <span class="number">36</span>, <span class="number">9</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p>小结<br>generator是非常强大的工具，在Python中，可以简单的把列表生成式改为generator。要理解generator的工作原理，他是在<code>for</code>循环的过程中不断计算出下一个元素，并在适当的条件结束循环。对于函数改成的generator来说，遇到<code>return</code>语句或者执行到函数体最后一行语句，就要结束generator的指令，<code>for</code>循环随之结束。</p>
</blockquote>
<p>请注意区分普通函数和generator函数，普通函数调用直接返回结果，generator函数调用实际返回一个generator对象。</p>
<hr>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>我们已经知道，可以直接作用关于<code>for</code>循环的数据类型有以下几种：一类是集合数据类型，如<code>list</code>,<code>tuple</code>,<code>dict</code>,<code>set</code>,<code>str</code>等；一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。可以使用<code>isinstance()</code>来判断一个对象是否是<code>Iterable</code>对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([],Iterable)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;,Iterable)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>,Iterable)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)),Iterable)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>而生成器不但可以作用于<code>for</code>循环，还可以被<code>next()</code>函数不断调用并返回下一个值，直到最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值了。可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。</p>
<p>可以用<code>isinstance()</code>来判断一个对象是否是<code>Iterator</code>对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)),Iterator)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>生成器都是<code>Iterator</code>对象，但是<code>list</code>,<code>dict</code>,<code>str</code>却不是。把这些<code>Iterable</code>变为<code>Iterator</code>可以使用<code>iter()</code>函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter([]),Iterator)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(<span class="string">'adsaf'</span>),Iterator)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>为什么<code>list</code>,<code>dict</code>,<code>str</code>不是<code>Iterator</code>？？？</p>
<p>这是因为Python的<code>Iterator</code>对象表示一个数据流，<code>Iterator</code>对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序的序列，但是我们却不能提前得知序列的长度，只能不断通过<code>next()</code>函数实现按需计算的下一个数据，所以<code>Iterator</code>的计算时惰性的，只有在需要的时候才会计算。<code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数，但是list是永远不可能存储全体的自然数的。</p>
<blockquote>
<p>小结<br>凡是可以用作<code>for</code>循环的对象都是<code>Iterable</code>类型；<br>凡是可作用关于<code>next()</code>函数的对象都是<code>Iterator</code>类型，他们表示一个惰性计算的序列；<br>集合数据类型如<code>list</code>，<code>dict</code>，<code>str</code>等都是<code>Iterable</code>,但是不是<code>Iterator</code>，不过可以通过<code>iter()</code>获得一个<code>Iterator</code>对象。</p>
<p>·Python上的<code>for</code>循环本质上是通过不断调用<code>next()</code>函数来实现的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]:</div><div class="line"><span class="meta">... </span>    <span class="keyword">pass</span></div><div class="line"><span class="meta">... </span>                <span class="comment">#等价的</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>it=iter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</div><div class="line"><span class="meta">... </span>            x=next(it)</div><div class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration:</div><div class="line"><span class="meta">... </span>            <span class="keyword">break</span></div><div class="line">...</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/09/15.电子邮件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/15.电子邮件/" itemprop="url">15. 电子邮件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-09T15:10:22+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p>电子邮件软件成为MUA：Mail User Agent—-邮件用户代理。E-mail从MUA发出去，不是直接到达对方电脑而是发到MTA(Mail Transfer Agent—邮件传输代理)，就是Email服务提供商，比如网易，新浪等。MTA会把email投递到MDA(Mail Delivery Agent—邮件投递代理)，存储在某个文件或特殊的数据库里也就是邮箱。要想获取邮件，必须通过MUA从MDA上获取到自己电脑上。</p>
<blockquote>
<p>发件人—&gt;MUA—&gt;MTA—&gt;MTA—&gt;若干个MTA—&gt;MDA&lt;—MUA&lt;—收件人</p>
</blockquote>
<p>要编写程序来发送和接收邮件，本质上就是：</p>
<blockquote>
<p>1、编写MUA把邮件发到MTA<br>2、编写MUA从MDA上收邮件</p>
</blockquote>
<p>发邮件时MUA和MTA使用的协议是SMTP：Simple Mail Transfer Protocol。<br>收邮件时，MUA和MDA使用的协议有两种：POP：Post Office Protocol，目前版本是3，俗称POP3；IMAP：Internet Message Access Protocol，目前版本是4，优点是不但能取邮件，还可以直接操作MDA上存储的邮件，比如从收件箱移到垃圾箱。</p>
<p>邮件客户端在发邮件时，会让你先配置SMTP服务器，也就是你要发到哪个MTA上。比如你在用163邮箱，就不能直接发送到新浪的MTA上，你要填163提供的SMTP服务器地址：<code>smtp.163.com</code>，还需要输入邮箱地址和邮箱口令来证明你是163用户，这样MUA才能正常地把Email通过SMTP协议发送到MTA。</p>
<p>从MDA收取邮件时，MDA服务器会要求验证邮箱口令，这样MUA才能顺利地通过POP或IMAP协议从MDA获取邮件。</p>
<h2 id="SMTP发送邮件"><a href="#SMTP发送邮件" class="headerlink" title="SMTP发送邮件"></a>SMTP发送邮件</h2><p>SMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本邮件，HTML邮件及其附件。</p>
<p>Python对SMTP支持有<code>smtplib</code>和<code>email</code>两个模块，<code>email</code>负责构造邮件，<code>stmplib</code>负责发送邮件。首先，我们来构造一个最简单的纯文本邮件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>msg=MIMEText(<span class="string">'Hello, send by Python...'</span>,<span class="string">'plain'</span>,<span class="string">'utf-8'</span>)</div></pre></td></tr></table></figure></p>
<p>注意到构造<code>MIMEText</code>对象时，第一个参数就是邮件正文，第二个参数是MIME的subtype，传入<code>plain</code>表示纯文本，最终的MIME就是<code>text/plain</code>，最后一定要用<code>utf-8</code>编码保证多语言兼容性。然后通过SMTP发送出去：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from_addr=input(<span class="string">'From:'</span>)</div><div class="line">password=input(<span class="string">'Password:'</span>)</div><div class="line"></div><div class="line">to_addr=input(<span class="string">'To:'</span>)</div><div class="line"></div><div class="line">smtp_server=input(<span class="string">'SMTP server: '</span>)</div><div class="line"></div><div class="line"><span class="keyword">import</span> smtplib</div><div class="line">server=smtplib.SMTP(smtp_server, <span class="number">25</span>)<span class="comment">#smtp默认的端口是25</span></div><div class="line">server.set_debuglevel(<span class="number">1</span>)</div><div class="line">server.login(from_addr, password)</div><div class="line">server.sendmail(from_addr,[to_addr],msg.as_string())</div><div class="line">server.quit()</div></pre></td></tr></table></figure></p>
<p>我们用<code>set_debuglevel(1)</code>就可以打印出和SMTP服务器交互的所有信息。SMTP协议就是简单的文本命令和相应。<code>login()</code>方法用来登录SMTP服务器，<code>sendmail()</code>方法就是发邮件，由于可以一次发给对个人，所以传入一个<code>list</code>，邮件正文是一个<code>str</code>，<code>as_string()</code>把MIMEText对象编程<code>str</code>。收到的邮件的问题是没有主题收件人没有显示为友好的名字，且收到了邮件却提示你不在收件人中。这是因为邮件主题、如何显示发件人、收件人的信息并不是通过SMTP协议发给MTA，而是包含在发给MTA的文本中的，所以，我们必须把From、To、Subject添加到MIMEText中才是一封完整的邮件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> smtplib</div><div class="line"><span class="keyword">from</span> email <span class="keyword">import</span> encoders</div><div class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</div><div class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</div><div class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr, formataddr</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_format_addr</span><span class="params">(s)</span>:</span></div><div class="line">    name, addr = parseaddr(s)</div><div class="line">    <span class="keyword">return</span> formataddr((Header(name, <span class="string">'utf-8'</span>).encode(), addr))</div><div class="line"></div><div class="line">from_addr=input(<span class="string">'From:'</span>)</div><div class="line">password=input(<span class="string">'Password:'</span>)</div><div class="line">to_addr=input(<span class="string">'To:'</span>)</div><div class="line">smtp_server=input(<span class="string">'SMTP server: '</span>)</div><div class="line"></div><div class="line">msg=MIMEText(<span class="string">'hello, send by python...'</span>, <span class="string">'plain'</span> ,<span class="string">'utf-8'</span>)</div><div class="line">msg[<span class="string">'From'</span>] = _format_addr(<span class="string">'Python爱好者 &lt;%s&gt;'</span> % from_addr)</div><div class="line">msg[<span class="string">'To'</span>] = _format_addr(<span class="string">'管理员 &lt;%s&gt;'</span> % to_addr)</div><div class="line">msg[<span class="string">'Subject'</span>] = Header(<span class="string">'来自SMTP的问候……'</span>, <span class="string">'utf-8'</span>).encode()</div><div class="line"></div><div class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>) <span class="comment"># SMTP协议默认端口是25</span></div><div class="line">server.set_debuglevel(<span class="number">1</span>)</div><div class="line">server.login(from_addr, password)</div><div class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</div><div class="line">server.quit()</div></pre></td></tr></table></figure></p>
<p>我们编写了一个函数<code>_format_addr()</code>来格式化一个邮件地址。注意不能简单地传入<code>name &lt;addr@example.com&gt;</code>,因为如果包含中文，需要通过<code>Header</code>对象编码。</p>
<p><code>msg[&#39;To&#39;]</code>发送的是字符串而不是list，如果有多个地址邮件，用，分隔即可。发送邮箱显示：<br><img src="/img/1478864121047.png" alt="Alt text"></p>
<p>你看到的收件人的名字可能不是我们传入的管理员，因为很多邮件服务商在显示邮件时会把收件人名字自动替换为用户注册的名字。我们插卡Email原始内容如下：</p>
<blockquote>
<p>From: =?utf-8?b?UHl0aG9u54ix5aW96ICF?= <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#120;&#x78;&#x78;&#x78;&#x78;&#x78;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#x6d;">&#120;&#x78;&#x78;&#x78;&#x78;&#x78;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#x6d;</a><br>To: =?utf-8?b?566h55CG5ZGY?= <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#120;&#120;&#x78;&#x78;&#120;&#x78;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;">&#120;&#120;&#x78;&#x78;&#120;&#x78;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;</a><br>Subject: =?utf-8?b?5p2l6IeqU01UUOeahOmXruWAmeKApuKApg==?=</p>
</blockquote>
<h3 id="发送HTML邮件"><a href="#发送HTML邮件" class="headerlink" title="发送HTML邮件"></a>发送HTML邮件</h3><p>如果我们要发送HTML邮件而不是普通的纯文本文件怎么办，就在构造<code>MIMEText</code>对象时，把HTML字符串传进去，再把第二个参数由plain改为plain就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msg=MIMEText(&apos;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&apos; + &apos;&lt;p&gt;send by &lt;a href=&quot;http://www.python.org&quot;&gt;Python&lt;/a&gt;...&lt;/p&gt;&apos;+&apos;&lt;/body&gt;&lt;/html&gt;&apos;, &apos;html&apos;, &apos;utf-8&apos;)</div></pre></td></tr></table></figure></p>
<p>再发送一遍邮件：<br><img src="/img/1478864651325.png" alt="Alt text"></p>
<h3 id="发送附件"><a href="#发送附件" class="headerlink" title="发送附件"></a>发送附件</h3><p>如果Email中要加上附件，可以把带附件的邮件看做包含若干部分的邮件：文本和各个附件本身，所以可以构造一个<code>MIMEMultipart</code>对象代表邮件本身，然后往里面加上一个<code>MIMEText</code>作为邮件正文，再继续往里面加上表示附件的<code>MIMEBase</code>对象即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 邮件对象:</span></div><div class="line">msg = MIMEMultipart()</div><div class="line">msg[<span class="string">'From'</span>] = _format_addr(<span class="string">'Python爱好者 &lt;%s&gt;'</span> % from_addr)</div><div class="line">msg[<span class="string">'To'</span>] = _format_addr(<span class="string">'管理员 &lt;%s&gt;'</span> % to_addr)</div><div class="line">msg[<span class="string">'Subject'</span>] = Header(<span class="string">'来自SMTP的问候……'</span>, <span class="string">'utf-8'</span>).encode()</div><div class="line"></div><div class="line"><span class="comment"># 邮件正文是MIMEText:</span></div><div class="line">msg.attach(MIMEText(<span class="string">'send with file...'</span>, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line"><span class="comment"># 添加附件就是加上一个MIMEBase，从本地读取一个图片:</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'/Users/michael/Downloads/test.png'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</div><div class="line">    <span class="comment"># 设置附件的MIME和文件名，这里是png类型:</span></div><div class="line">    mime = MIMEBase(<span class="string">'image'</span>, <span class="string">'png'</span>, filename=<span class="string">'test.png'</span>)</div><div class="line">    <span class="comment"># 加上必要的头信息:</span></div><div class="line">    mime.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=<span class="string">'test.png'</span>)</div><div class="line">    mime.add_header(<span class="string">'Content-ID'</span>, <span class="string">'&lt;0&gt;'</span>)</div><div class="line">    mime.add_header(<span class="string">'X-Attachment-Id'</span>, <span class="string">'0'</span>)</div><div class="line">    <span class="comment"># 把附件的内容读进来:</span></div><div class="line">    mime.set_payload(f.read())</div><div class="line">    <span class="comment"># 用Base64编码:</span></div><div class="line">    encoders.encode_base64(mime)</div><div class="line">    <span class="comment"># 添加到MIMEMultipart:</span></div><div class="line">    msg.attach(mime)</div></pre></td></tr></table></figure></p>
<p> 发送结果：<br> <img src="/img/1478944551315.png" alt="Alt text"></p>
<h3 id="发送图片"><a href="#发送图片" class="headerlink" title="发送图片"></a>发送图片</h3><p>如果要把一个图片嵌入到邮件正文中，直接在HTML邮件中连接图片地址是不行的，我们需要按照发送附件的方法，把邮件作为附件添加进去，然后在HTML中通过引用<code>src=&quot;cid:0&quot;</code>就可以把附件作为图片嵌入。如果有多个图片，可以依次编号，然后引用不同的<code>cid:x</code>就可以。</p>
<p>把上面代码中加入<code>MIMEMultipart</code>的<code>MIMEText</code>从<code>plain</code>改为<code>html</code>，然后在适当的位置引用图片：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">msg.attach(MIMEText(<span class="string">'&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;'</span> +</div><div class="line">    <span class="string">'&lt;p&gt;&lt;img src="cid:0"&gt;&lt;/p&gt;'</span> +</div><div class="line">    <span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>, <span class="string">'html'</span>, <span class="string">'utf-8'</span>))</div></pre></td></tr></table></figure></p>
<p>发送结果：<br><img src="/img/1478945851210.png" alt="Alt text"></p>
<h3 id="同时支持HTML和Plain格式"><a href="#同时支持HTML和Plain格式" class="headerlink" title="同时支持HTML和Plain格式"></a>同时支持HTML和Plain格式</h3><p>如果我们发送HTML邮件，收件人通过浏览器或者Outlook之类的软件是可以正常浏览邮件内容的，但是如果收件人的设备无法查看HTML邮件时，我们可以在发送HTML的同时再附加一个纯文本，如果收件人无法查看HTML格式的邮件，就可以自动降级查看纯文本邮件。</p>
<p>利用<code>MIMEMultipart</code>可以组合一个HTML和Plain，要注意指定subtype是<code>alternative</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">msg = MIMEMultipart(<span class="string">'alternative'</span>)</div><div class="line">msg[<span class="string">'From'</span>] = ...</div><div class="line">msg[<span class="string">'To'</span>] = ...</div><div class="line">msg[<span class="string">'Subject'</span>] = ...</div><div class="line"></div><div class="line">msg.attach(MIMEText(<span class="string">'hello'</span>, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>))</div><div class="line">msg.attach(MIMEText(<span class="string">'&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'</span>, <span class="string">'html'</span>, <span class="string">'utf-8'</span>))</div><div class="line"><span class="comment"># 正常发送msg对象...</span></div></pre></td></tr></table></figure></p>
<h3 id="加密SMTP"><a href="#加密SMTP" class="headerlink" title="加密SMTP"></a>加密SMTP</h3><p>使用标准的25端口连接SMTP服务器时，使用的是明文传输，发送邮件的整个过程可能会被窃听。要更安全地发送邮件，可以加密SMTP会话，实际上就是先创建SSL安全连接，然后再使用SMTP协议发送邮件。</p>
<p>Gmail提供的SMTP服务必须要加密传输。首先知道Gmail的SMTP端口是587，修改代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">smtp_server = <span class="string">'smtp.gmail.com'</span></div><div class="line">smtp_port = <span class="number">587</span></div><div class="line">server = smtplib.SMTP(smtp_server, smtp_port)</div><div class="line">server.starttls()</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>只需要在创建SMTP对象后，立刻调用<code>starttls()</code>方法，就创建了安全链接。后面的代码和前面的发送邮件代码完全一样。</p>
<p>使用Python的smtplib发送邮件很简单，只要掌握了各种邮件类型的构造方法，正确设置好邮件头就可以顺利发出。构造一个邮件对象就是一个<code>Message</code>对象，如果构建一个<code>MIMEText</code>对象，就表示一个作为附件的图片，要把多个对象组合起来，就用<code>MIMEMultipart</code>，<code>MIMEBase</code>可以表示任何对象，继承关系如下：<br><img src="/img/1478946592016.png" alt="Alt text"></p>
<hr>
<h2 id="POP3收取邮件"><a href="#POP3收取邮件" class="headerlink" title="POP3收取邮件"></a>POP3收取邮件</h2><p>收邮件就是编写一个MUA作为客户端，从MDA把邮件获取到用户的电脑或者手机上。收取邮件最常用的协议是POP协议。Python内置了一个<code>poplib</code>模块，实现了POP3协议。</p>
<p>POP3收取的不是一个已经可以阅读的邮件本身，而是邮件的原始文本，这和SMTP一样，SMTP发送的也是经过编码后的一大段文本。要把POP3收取的文本变为可以阅读的邮件，还需要用<code>email</code>模块提供的各种类来解析原始文本，变成可阅读的邮件对象。收取邮件分为两部分：</p>
<blockquote>
<p>1、用<code>poplib</code>把邮件的原始文本下载到本地；<br>2、用<code>email</code>解析原始文本，还原为邮件对象。</p>
</blockquote>
<h3 id="通过POP3下载邮件"><a href="#通过POP3下载邮件" class="headerlink" title="通过POP3下载邮件"></a>通过POP3下载邮件</h3><p>POP3的协议本身很简单，以下面的代码为例，我们来获取最新的一封邮件内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> email.parser <span class="keyword">import</span> Parser</div><div class="line"><span class="keyword">import</span> poplib</div><div class="line"></div><div class="line"><span class="comment">#输入邮箱地址，口令和POP3服务器地址：</span></div><div class="line">email = input(<span class="string">'Email:'</span>)</div><div class="line">password =input(<span class="string">'Password:'</span>)</div><div class="line">pop3_server = input(<span class="string">'POP3 server:'</span>)</div><div class="line"></div><div class="line"><span class="comment">#连接到POP3服务器</span></div><div class="line">server = poplib.POP3(pop3_server)</div><div class="line"><span class="comment">#可以打开或关闭调试信息</span></div><div class="line">server.set_debuglevel(<span class="number">1</span>)</div><div class="line">print(server.getwelcome().decode(<span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line"><span class="comment">#身份认证</span></div><div class="line">server.user(email)</div><div class="line">server.pass_(password)</div><div class="line"></div><div class="line"><span class="comment">#start()返回邮件数量和占用空间</span></div><div class="line">print(<span class="string">'Messages: %s, Size: %s'</span> %server.stat())</div><div class="line"><span class="comment">#list()返回所有邮件的编号</span></div><div class="line">resp, mails, octets = server.list()</div><div class="line"></div><div class="line">print(mails)</div><div class="line"></div><div class="line"><span class="comment">#获取最新一封邮件，索引号从1开始</span></div><div class="line">index = len(mails)</div><div class="line">resp, lines, octets = server.retr(index)</div><div class="line">msg_content = <span class="string">b'\r\n'</span>.join(lines).decode(<span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line">msg = Parser().parsestr(msg_content)</div><div class="line"></div><div class="line">server.quit()</div></pre></td></tr></table></figure></p>
<p>用POP3协议很简单，要获取所有邮件，只需要循环使用<code>retr()</code>把每一封邮件内容拿到即可。</p>
<h3 id="解析邮件"><a href="#解析邮件" class="headerlink" title="解析邮件"></a>解析邮件</h3><p>解析邮件的过程和上一节构造邮件刚好相反，必须导入必要的模块：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> email.parser <span class="keyword">import</span> Parser</div><div class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> decode_header</div><div class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr</div><div class="line"></div><div class="line"><span class="keyword">import</span> poplib</div></pre></td></tr></table></figure></p>
<p>一行代码可以把邮件内容解析为Message对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msg = Parser().parsestr(msg_content)</div></pre></td></tr></table></figure></p>
<p>这个<code>Message</code>对象本身可能是一个<code>MIMEMultipart</code>对象，即包含嵌套的其他<code>MIMEBase</code>对象，嵌套可能还不止一层。所以我们要递归地打印出Message对象的层次结构：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># indent用于缩进显示:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">(msg, indent=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="keyword">if</span> indent == <span class="number">0</span>:</div><div class="line">        <span class="keyword">for</span> header <span class="keyword">in</span> [<span class="string">'From'</span>, <span class="string">'To'</span>, <span class="string">'Subject'</span>]:</div><div class="line">            value = msg.get(header, <span class="string">''</span>)</div><div class="line">            <span class="keyword">if</span> value:</div><div class="line">                <span class="keyword">if</span> header==<span class="string">'Subject'</span>:</div><div class="line">                    value = decode_str(value)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    hdr, addr = parseaddr(value)</div><div class="line">                    name = decode_str(hdr)</div><div class="line">                    value = <span class="string">u'%s &lt;%s&gt;'</span> % (name, addr)</div><div class="line">            print(<span class="string">'%s%s: %s'</span> % (<span class="string">'  '</span> * indent, header, value))</div><div class="line">    <span class="keyword">if</span> (msg.is_multipart()):</div><div class="line">        parts = msg.get_payload()</div><div class="line">        <span class="keyword">for</span> n, part <span class="keyword">in</span> enumerate(parts):</div><div class="line">            print(<span class="string">'%spart %s'</span> % (<span class="string">'  '</span> * indent, n))</div><div class="line">            print(<span class="string">'%s--------------------'</span> % (<span class="string">'  '</span> * indent))</div><div class="line">            print_info(part, indent + <span class="number">1</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        content_type = msg.get_content_type()</div><div class="line">        <span class="keyword">if</span> content_type==<span class="string">'text/plain'</span> <span class="keyword">or</span> content_type==<span class="string">'text/html'</span>:</div><div class="line">            content = msg.get_payload(decode=<span class="keyword">True</span>)</div><div class="line">            charset = guess_charset(msg)</div><div class="line">            <span class="keyword">if</span> charset:</div><div class="line">                content = content.decode(charset)</div><div class="line">            print(<span class="string">'%sText: %s'</span> % (<span class="string">'  '</span> * indent, content + <span class="string">'...'</span>))</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">'%sAttachment: %s'</span> % (<span class="string">'  '</span> * indent, content_type))</div></pre></td></tr></table></figure></p>
<p>邮件的Subject或者Email中包含的名字都是经过编码后的str，要正常显示，就必须decode：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_Str</span><span class="params">(s)</span>:</span></div><div class="line">	value, charset = decode_header(s)[<span class="number">0</span>]</div><div class="line">	<span class="keyword">if</span> charset:</div><div class="line">		value = value.decode(charset)</div><div class="line">	<span class="keyword">return</span> value</div></pre></td></tr></table></figure></p>
<p><code>decode_header()</code>返回一个list，因为像<code>Cc``Bcc</code>这样的字段可能包含多个邮件地址，所以解析出来的会有多个元素。上面的代码我们只取了第一个元素。文本邮件的内容也是str，还需要检测编码，否则非UTF-8编码的邮件都无法正常显示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gusee_charset</span><span class="params">(msg)</span>:</span></div><div class="line">	charset = msg.get_charset()</div><div class="line">	<span class="keyword">if</span> charset <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">		content_type = msg.get(<span class="string">'Content-Type'</span>, <span class="string">''</span>).lower()</div><div class="line">		pos = content_type.find(<span class="string">'charset='</span>)</div><div class="line">		<span class="keyword">if</span> pos &gt;= <span class="number">0</span>:</div><div class="line">			charset = content_type[pos + <span class="number">8</span>:].strip()</div><div class="line">	<span class="keyword">return</span> charset</div></pre></td></tr></table></figure></p>
<p>把上面的代码整理好，我们就可以来试试获取一封邮件。先往自己的邮箱发送一封邮件，然后用Python程序把它收到本地：<br><img src="/img/1478954102163.png" alt="Alt text"></p>
<p>源码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> email.parser <span class="keyword">import</span> Parser</div><div class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> decode_header</div><div class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr</div><div class="line"></div><div class="line"><span class="keyword">import</span> poplib</div><div class="line"></div><div class="line"><span class="comment"># 输入邮件地址, 口令和POP3服务器地址:</span></div><div class="line">email = input(<span class="string">'Email: '</span>)</div><div class="line">password = input(<span class="string">'Password: '</span>)</div><div class="line">pop3_server = input(<span class="string">'POP3 server: '</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">guess_charset</span><span class="params">(msg)</span>:</span></div><div class="line">    charset = msg.get_charset()</div><div class="line">    <span class="keyword">if</span> charset <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        content_type = msg.get(<span class="string">'Content-Type'</span>, <span class="string">''</span>).lower()</div><div class="line">        pos = content_type.find(<span class="string">'charset='</span>)</div><div class="line">        <span class="keyword">if</span> pos &gt;= <span class="number">0</span>:</div><div class="line">            charset = content_type[pos + <span class="number">8</span>:].strip()</div><div class="line">    <span class="keyword">return</span> charset</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_str</span><span class="params">(s)</span>:</span></div><div class="line">    value, charset = decode_header(s)[<span class="number">0</span>]</div><div class="line">    <span class="keyword">if</span> charset:</div><div class="line">        value = value.decode(charset)</div><div class="line">    <span class="keyword">return</span> value</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">(msg, indent=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="keyword">if</span> indent == <span class="number">0</span>:</div><div class="line">        <span class="keyword">for</span> header <span class="keyword">in</span> [<span class="string">'From'</span>, <span class="string">'To'</span>, <span class="string">'Subject'</span>]:</div><div class="line">            value = msg.get(header, <span class="string">''</span>)</div><div class="line">            <span class="keyword">if</span> value:</div><div class="line">                <span class="keyword">if</span> header==<span class="string">'Subject'</span>:</div><div class="line">                    value = decode_str(value)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    hdr, addr = parseaddr(value)</div><div class="line">                    name = decode_str(hdr)</div><div class="line">                    value = <span class="string">u'%s &lt;%s&gt;'</span> % (name, addr)</div><div class="line">            print(<span class="string">'%s%s: %s'</span> % (<span class="string">'  '</span> * indent, header, value))</div><div class="line">    <span class="keyword">if</span> (msg.is_multipart()):</div><div class="line">        parts = msg.get_payload()</div><div class="line">        <span class="keyword">for</span> n, part <span class="keyword">in</span> enumerate(parts):</div><div class="line">            print(<span class="string">'%spart %s'</span> % (<span class="string">'  '</span> * indent, n))</div><div class="line">            print(<span class="string">'%s--------------------'</span> % (<span class="string">'  '</span> * indent))</div><div class="line">            print_info(part, indent + <span class="number">1</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        content_type = msg.get_content_type()</div><div class="line">        <span class="keyword">if</span> content_type==<span class="string">'text/plain'</span> <span class="keyword">or</span> content_type==<span class="string">'text/html'</span>:</div><div class="line">            content = msg.get_payload(decode=<span class="keyword">True</span>)</div><div class="line">            charset = guess_charset(msg)</div><div class="line">            <span class="keyword">if</span> charset:</div><div class="line">                content = content.decode(charset)</div><div class="line">            print(<span class="string">'%sText: %s'</span> % (<span class="string">'  '</span> * indent, content + <span class="string">'...'</span>))</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">'%sAttachment: %s'</span> % (<span class="string">'  '</span> * indent, content_type))</div><div class="line"></div><div class="line"><span class="comment"># 连接到POP3服务器:</span></div><div class="line">server = poplib.POP3(pop3_server)</div><div class="line"><span class="comment"># 可以打开或关闭调试信息:</span></div><div class="line">server.set_debuglevel(<span class="number">1</span>)</div><div class="line"><span class="comment"># 可选:打印POP3服务器的欢迎文字:</span></div><div class="line">print(server.getwelcome().decode(<span class="string">'utf-8'</span>))</div><div class="line"><span class="comment"># 身份认证:</span></div><div class="line">server.user(email)</div><div class="line">server.pass_(password)</div><div class="line"><span class="comment"># stat()返回邮件数量和占用空间:</span></div><div class="line">print(<span class="string">'Messages: %s. Size: %s'</span> % server.stat())</div><div class="line"><span class="comment"># list()返回所有邮件的编号:</span></div><div class="line">resp, mails, octets = server.list()</div><div class="line"><span class="comment"># 可以查看返回的列表类似[b'1 82923', b'2 2184', ...]</span></div><div class="line">print(mails)</div><div class="line"><span class="comment"># 获取最新一封邮件, 注意索引号从1开始:</span></div><div class="line">index = len(mails)</div><div class="line">resp, lines, octets = server.retr(index)</div><div class="line"><span class="comment"># lines存储了邮件的原始文本的每一行,</span></div><div class="line"><span class="comment"># 可以获得整个邮件的原始文本:</span></div><div class="line">msg_content = <span class="string">b'\r\n'</span>.join(lines).decode(<span class="string">'utf-8'</span>)</div><div class="line"><span class="comment"># 稍后解析出邮件:</span></div><div class="line">msg = Parser().parsestr(msg_content)</div><div class="line">print_info(msg)</div><div class="line"><span class="comment"># 可以根据邮件索引号直接从服务器删除邮件:</span></div><div class="line"><span class="comment"># server.dele(index)</span></div><div class="line"><span class="comment"># 关闭连接:</span></div><div class="line">server.quit()</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/09/13.virtualenv&图形界面/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/13.virtualenv&图形界面/" itemprop="url">13. virtualenv&图形界面</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-09T15:08:02+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="virtualenv-amp-图形界面"><a href="#virtualenv-amp-图形界面" class="headerlink" title="virtualenv&amp;图形界面"></a>virtualenv&amp;图形界面</h1><h2 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h2><p>在开发Python应用程序的时候，系统安装的Python只有一个3.5版本。所有的第三方包都会被安装到Python3的<code>site-packages</code>目录下。</p>
<p>如果要同时开发多个应用程序，那么这些应用程序共用一个Python3.5，如果应用A需要jinja2.7，应用B需要jinja2.6，这时候需要用virtualenv来为一个应用创建一套隔离的Python运行环境。</p>
<p>第一步，创建项目文件夹myproject，在该文件夹中安装虚拟环境env：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">D:\笔记\Python\Notepad++&gt;mkdir myproject</div><div class="line">D:\笔记\Python\Notepad++&gt;cd myproject</div><div class="line">D:\笔记\Python\Notepad++\myproject&gt;dir</div><div class="line"> 驱动器 D 中的卷是 文件</div><div class="line"> 卷的序列号是 <span class="number">0</span>BE3<span class="number">-0E5</span>C</div><div class="line"></div><div class="line"> D:\笔记\Python\Notepad++\myproject 的目录</div><div class="line"></div><div class="line"><span class="number">2016</span>/<span class="number">11</span>/<span class="number">06</span>  <span class="number">20</span>:<span class="number">01</span>    &lt;DIR&gt;          .</div><div class="line"><span class="number">2016</span>/<span class="number">11</span>/<span class="number">06</span>  <span class="number">20</span>:<span class="number">01</span>    &lt;DIR&gt;          ..</div><div class="line">               <span class="number">0</span> 个文件              <span class="number">0</span> 字节</div><div class="line">               <span class="number">2</span> 个目录 <span class="number">104</span>,<span class="number">178</span>,<span class="number">057</span>,<span class="number">216</span> 可用字节</div><div class="line"></div><div class="line">D:\笔记\Python\Notepad++\myproject&gt;virtualenv env</div><div class="line">Using base prefix <span class="string">'c:\\users\\cdxu0\\appdata\\local\\programs\\python\\python35'</span></div><div class="line">New python executable <span class="keyword">in</span> D:\笔记\Python\Notepad++\myproject\env\Scripts\python.exe</div><div class="line">Installing setuptools, pip, wheel...done.</div></pre></td></tr></table></figure></p>
<p>第二步，启动虚拟环境，安装所需库类。在windows中虚拟环境的启动使用命令：your_env_dir\Scripts\activate，默认情况下，virtualenv已经安装好了pip。在启动虚拟环境后直接使用pip install命令就可以为该虚拟环境安装库类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">D:\笔记\Python\Notepad++\myproject&gt;cd env\Scripts</div><div class="line"></div><div class="line">D:\笔记\Python\Notepad++\myproject\env\Scripts&gt;activate</div><div class="line"></div><div class="line">(env) D:\笔记\Python\Notepad++\myproject\env\Scripts&gt;pip install flask==<span class="number">0.9</span></div></pre></td></tr></table></figure></p>
<p>第三步，在虚拟环境中可以运行脚本等操作，离开虚拟环境，使用deactivate命令。</p>
<hr>
<h2 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h2><p>Python支持多种图形界面的第三方库，比如：Tk，wxWidgets ，Qt，GTK等。但是Python自带的库是支持Tk的TKinter，使用Tkinter，无需安装任何包就可以直接使用。</p>
<p>使用TKinter十分简单，第一步导入TKinter包的所有内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</div></pre></td></tr></table></figure></p>
<p>第二步从<code>Frame</code>派生一个<code>Application</code>类，这是所有Widget的父容器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Application</span><span class="params">(Frame)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,master=None)</span>:</span></div><div class="line">		Frame.__init__(self,master)</div><div class="line">		self.pack()</div><div class="line">		self.createWidgets()</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">createWidgets</span><span class="params">(self)</span>:</span></div><div class="line">		self.helloLabel=Label(self, text=<span class="string">'Hello, world!'</span>)</div><div class="line">		self.helloLabel.pack()</div><div class="line">		self.quitButton=Button(self, text=<span class="string">'Quit'</span>, command=self.quit)</div><div class="line">		self.quitButton.pack()</div></pre></td></tr></table></figure></p>
<p>在GUI中，每个Button、Label、输入框等，都是一个Widget。Frame则是可以容纳其他Widget的Widget，所有的Widget组合起来就是一棵树。</p>
<p><code>pack()</code>方法把Widget加入到父容器中，并实现布局。<code>pack()</code>是最简单的布局，<code>grid()</code>可以实现更复杂的布局。</p>
<p>在<code>createWidgets()</code>方法中，我们创建一个<code>Label</code>和一个<code>Button</code>，当Button被点击时，触发<code>self.quit()</code>使得程序退出。</p>
<p>第三步，实例化<code>Application</code>，并启动消息循环：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>app=Application()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>app.master.title(<span class="string">'Hello world!'</span>)</div><div class="line"><span class="string">''</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>app.mainloop()</div></pre></td></tr></table></figure></p>
<p>GUI程序的主线负责监听来自操作系统的消息，并依次处理每一条消息。因此，如果消息处理非常耗时，就需要新线程中处理。运行这个GUI程序：<br><img src="/img/1478439318915.png" alt="Alt text"></p>
<p>点击Quit按钮或者窗口的x结束程序。</p>
<h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p>我们再对这个GUI程序改进一下，加入一个文本框，让用户可以输入文本，然后点按钮后，弹出消息对话框。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment">#-*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</div><div class="line"><span class="keyword">import</span> tkinter.messagebox <span class="keyword">as</span> messagebox</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span><span class="params">(Frame)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,master=None)</span>:</span></div><div class="line">		Frame.__init__(self,master)</div><div class="line">		self.pack()</div><div class="line">		self.createWidgets()</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">createWidgets</span><span class="params">(self)</span>:</span></div><div class="line">		self.nameInput=Entry(self)</div><div class="line">		self.nameInput.pack()</div><div class="line">		self.alterButton=Button(self, text=<span class="string">'Hello'</span>, command=self.hello)</div><div class="line">		self.alterButton.pack()</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></div><div class="line">		name=self.nameInput.get() <span class="keyword">or</span> <span class="string">'world'</span></div><div class="line">		messagebox.showinfo(<span class="string">'Message'</span>,<span class="string">'Hello, %s'</span> %name)</div><div class="line"></div><div class="line">app=Application()</div><div class="line">app.master.title(<span class="string">'Hello World'</span>)</div><div class="line">app.mainloop()</div></pre></td></tr></table></figure></p>
<p>当用户点击按钮时，出发<code>hello()</code>,通过<code>self.nameInput.get()</code>获得用户输入的文本后，使用<code>tkMessageBox.showinfo()</code>可以弹出消息对话框：<br><img src="/img/1478440468867.png" alt="Alt text"><br><img src="/img/1478440493401.png" alt="Alt text"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/08/17.异步IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/17.异步IO/" itemprop="url">17. 异步IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T17:58:50+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h1><p>在IO编程中我们知道CPU的速度远远快于磁盘网络等IO。在一个线程中，CPU执行代码的速度极快，然而一旦遇到IO操作，比如读写文件、发送网络数据时，就需要等待IO操作完成，才能进行下一步操作，这种情况称为同步IO。</p>
<p>在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。因为一个IO操作就阻塞了当前线程，导致代码无法执行，所以我们必须使用多线程或者多进程并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。</p>
<p>多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，线程一旦过多，CPU的时间就花在线程切换上了，导致性能下降。</p>
<p>由于我们要解决的问题是CPU告诉执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。另一种方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令并不等待IO结果。然后去执行其他代码，一段时间后，当IO结果返回时，再通知CPU进行处理。</p>
<p>可以知道，普通顺序写的代码是无法完成异步IO的，异步IO模型需要一个消息循环，在消息循环中，主线程不断的重复着“读取消息-处理消息”这一过程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">loop = get_event_loop()</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">	event = loop.get_event()</div><div class="line">	process_event(event)</div></pre></td></tr></table></figure></p>
<p>消息模型其实早就应用在桌面程序中了，一个GUI程序的主线程就负责不停地读取消息并处理消息。所有的键盘、鼠标等消息都被发送到GUI程序的消息队列中，然后由GUI程序的主线程处理。由于GUI线程处理键盘鼠标等消息的速度非常快、所以用户感觉不到延迟。某些情况下，GUI线程会在一个消息处理的过程中遇到问题导致一次消息处理时间过长，此时用户会感觉到整个GUI程序停止响应了，敲键盘鼠标都没有反应。这种情况说明在消息模型中，处理一个消息必须非常迅速，否则主线程将无法及时处理消息队列中的其他消息，导致程序看上去停止响应。</p>
<p>当遇到IO操作时，代码只负责发送IO请求，不等待IO结果，然后直接结束本轮消息处理，进入下一轮操作处理过程。当IO操作完成后，将受到一条IO完成的消息，处理该消息时就可以直接获取IO操作的结果。</p>
<p>在发出IO请求到受到IO完成这段时间里面，同步IO模型下，主线程只能挂起，但是异步IO模型下，主线程并没有休息，而是在消息循环中继续处理其他消息。这样在异步IO下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。对大多数IO密集型程序，异步IO会大大提高系统的多任务处理能力。</p>
<hr>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程，又称微线程、 钎程。英文名Coroutine。</p>
<p>子程序或者成为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口一个返回，调用顺序是明确的。而协程的调用和子程序不同。</p>
<p>协程看上去也是子程序，但是在执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。注意在一个子程序中中断，去执行其他子程序，不是调用函数，有点类似CPU中断。比如子程序A、B：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def A():</div><div class="line">    print(&apos;1&apos;)</div><div class="line">    print(&apos;2&apos;)</div><div class="line">    print(&apos;3&apos;)</div><div class="line"></div><div class="line">def B():</div><div class="line">    print(&apos;x&apos;)</div><div class="line">    print(&apos;y&apos;)</div><div class="line">    print(&apos;z&apos;)</div></pre></td></tr></table></figure></p>
<p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行中中断再去执行A，结果可能是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">x</div><div class="line">y</div><div class="line">3</div><div class="line">z</div></pre></td></tr></table></figure></p>
<p>但是再A总是没有调用B的，所以协程的调用比起函数调用理解要难。</p>
<p>看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行。和多线程相比，协程最大的优势就是极高的执行效率。因为子程序切换不是线程切换，而是程序自身控制的 ，因此没有线程切换的开销，和多线程相比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不休要多线程的锁机制，因为只有一个线程，也不存在同时写和变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>协程是一个线程执行，为了利用多核CPU，可以用多进程+协程，即充分利用多核，又充分发挥协程的高效率，可获得奇高的性能。</p>
<p>Python对协程的支持是通过generator实现的。</p>
<p>在generator中，我们不但可以通过<code>for</code>循环来迭代，还可以不断调用<code>next()</code>函数获取由<code>yield</code>语句返回下一个值。但是Python的<code>yield</code>不但可以返回一个值，还可以接收调用者发出的参数。</p>
<p>例如：传统的生产者-消费者模型就是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，等消费者执行完毕后，切换回生产者继续生产，效率极高：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    r=<span class="string">''</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line"><span class="meta">... </span>            n = <span class="keyword">yield</span> r</div><div class="line"><span class="meta">... </span>            <span class="keyword">if</span> <span class="keyword">not</span>  n:</div><div class="line"><span class="meta">... </span>                    <span class="keyword">return</span></div><div class="line"><span class="meta">... </span>            print(<span class="string">'[CONSUMER] Consuming %s...'</span> % n )</div><div class="line"><span class="meta">... </span>            r=<span class="string">'200 OK'</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(c)</span>:</span></div><div class="line"><span class="meta">... </span>    c.send(<span class="keyword">None</span>)</div><div class="line"><span class="meta">... </span>    n=<span class="number">0</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</div><div class="line"><span class="meta">... </span>            n = n + <span class="number">1</span></div><div class="line"><span class="meta">... </span>            print(<span class="string">'[PRODUCER] Producing %s...'</span> %n)</div><div class="line"><span class="meta">... </span>            r = c.send(n)</div><div class="line"><span class="meta">... </span>            print(<span class="string">'[PRODUCER] Consumer return: %s'</span> % r )</div><div class="line"><span class="meta">... </span>    c.close()</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = consumer()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>produce(c)</div><div class="line">[PRODUCER] Producing <span class="number">1.</span>..</div><div class="line">[CONSUMER] Consuming <span class="number">1.</span>..</div><div class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</div><div class="line">[PRODUCER] Producing <span class="number">2.</span>..</div><div class="line">[CONSUMER] Consuming <span class="number">2.</span>..</div><div class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</div><div class="line">[PRODUCER] Producing <span class="number">3.</span>..</div><div class="line">[CONSUMER] Consuming <span class="number">3.</span>..</div><div class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</div><div class="line">[PRODUCER] Producing <span class="number">4.</span>..</div><div class="line">[CONSUMER] Consuming <span class="number">4.</span>..</div><div class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</div><div class="line">[PRODUCER] Producing <span class="number">5.</span>..</div><div class="line">[CONSUMER] Consuming <span class="number">5.</span>..</div><div class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</div></pre></td></tr></table></figure></p>
<p>注意到<code>consumer</code>函数是一个<code>generator</code>，把一个<code>consumer</code>传入<code>produce</code>后：</p>
<p>1、首先调用<code>c.send(None)</code>启动生成器；<br>2、一旦产生了东西，通过<code>c.send(n)</code>切换到<code>consumer</code>执行<br>3、<code>consumer</code>通过<code>yield</code>拿到消息，处理，又通过<code>yield</code>把结果传回。<br>4、<code>produce</code>拿到<code>consumer</code>处理的结果，继续生产下一条消息<br>5、<code>produce</code>决定不生产了，通过<code>c.close()</code>关闭<code>consumer</code>整个过程结束。</p>
<p>整个流程无锁，由一个线程执行，<code>produce</code>和<code>consumer</code>协作完成任务，所以称为协程。</p>
<hr>
<h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p><code>asyncio</code>是python3.4版本引入的标准库，直接内置了对异步IO的支持。<code>asyncio</code>的编程模型就是一个消息循环。我们从<code>asyncio</code>模块中直接获取一个<code>Eventloop</code>的引用，然后把需要执行的协程扔到<code>Eventloop</code>中执行，就实现了异步IO。</p>
<p>用<code>asyncio</code>实现<code>Hello world</code>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>@asyncio.coroutine</div><div class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">"Hello world!!"</span>)</div><div class="line"><span class="meta">... </span>    r=<span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</div><div class="line"><span class="meta">... </span>    print(<span class="string">"Hello again!"</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>loop = asyncio.get_event_loop()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>loop.run_until_complete(hello())</div><div class="line">Hello world!!</div><div class="line">Hello again!</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>loop.close()</div></pre></td></tr></table></figure></p>
<p><code>@asyncio.coroutine</code>把一个generator标记为coroutine类型，然后，我们就把这个Coroutine扔到Eventloop中执行。</p>
<p><code>hello()</code>首先打印出<code>Hello world!!</code>，然后，<code>yield from</code>语法可以让我们方便的调用另一个<code>generator</code>。由于<code>asyncio.sleep()</code>也是一个Coroutine，所以线程不会等待<code>asyncio.sleep()</code>，而是直接中断并执行下一个消息循环。当<code>asyncio.sleep()</code>返回时，线程就可以从<code>yield from</code>拿到返回值，然后接着执行下一行语句。</p>
<p>把<code>asyncio.sleep(1)</code>看做一个耗时1秒的IO操作，在此期间，主线程并未等待，而是去执行<code>Eventloop</code>中其他可以执行的coroutine了，因此可以实现并发执行。</p>
<p>用Task封装两个<code>coroutine</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line"><span class="meta">@asyncio.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">	print(<span class="string">'Hello world! (%s)'</span> % threading.currentThread())</div><div class="line">	<span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</div><div class="line">	print(<span class="string">'Hello again! (%s)'</span> % threading.currentThread())</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">tasks = [hello(), hello()]</div><div class="line">loop.run_until_complete(asyncio.wait(tasks))</div><div class="line">loop.close()</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">D:\笔记\Python\Notepad++&gt;python 1.1.py</div><div class="line">Hello world! (&lt;_MainThread(MainThread, started 20036)&gt;)</div><div class="line">Hello world! (&lt;_MainThread(MainThread, started 20036)&gt;)</div><div class="line">#（停顿1s）</div><div class="line">Hello again! (&lt;_MainThread(MainThread, started 20036)&gt;)</div><div class="line">Hello again! (&lt;_MainThread(MainThread, started 20036)&gt;)</div></pre></td></tr></table></figure></p>
<p>由打印出来的当前线程可以看出，两个<code>continue</code>是由同一个线程并发执行的。如果把<code>asyncio.sleep()</code>换成真正的IO操作，则多个<code>coroutine</code>就可以由一个线程并发执行。我们用<code>asyncio</code>的异步网络连接来获取sina、sohu和163的网站首页：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line"><span class="meta">@asyncio.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wget</span><span class="params">(host)</span>:</span></div><div class="line">	print(<span class="string">'wget %s...'</span> % host)</div><div class="line">	connect = asyncio.open_connection(host, <span class="number">80</span>)</div><div class="line">	reader, writer = <span class="keyword">yield</span> <span class="keyword">from</span> connect</div><div class="line">	header = <span class="string">'GET / HTTP/1.0\r\nHost: %s\r\n\r\n'</span> %host</div><div class="line">	writer.write(header.encode(<span class="string">'utf-8'</span>))</div><div class="line">	<span class="keyword">yield</span> <span class="keyword">from</span> writer.drain()</div><div class="line">	<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">		line = <span class="keyword">yield</span> <span class="keyword">from</span> reader.readline()</div><div class="line">		<span class="keyword">if</span> line == <span class="string">b'\r\n'</span>:</div><div class="line">			<span class="keyword">break</span></div><div class="line">		print(<span class="string">'%s header &gt; %s'</span> %(host, line.decode(<span class="string">'utf-8'</span>).rstrip()))</div><div class="line">	writer.close()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">tasks = [wget(host) <span class="keyword">for</span> host <span class="keyword">in</span>[<span class="string">'www.sina.com.cn'</span>, <span class="string">'www.sohu.com'</span>, <span class="string">'www.163.com'</span>]]</div><div class="line">loop.run_until_complete(asyncio.wait(tasks))</div><div class="line">loop.close()</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">D:\笔记\Python\Notepad++&gt;python <span class="number">1.2</span>.py</div><div class="line">wget www.sina.com.cn...</div><div class="line">wget www<span class="number">.163</span>.com...</div><div class="line">wget www.sohu.com...</div><div class="line">www.sina.com.cn header &gt; HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line">www.sina.com.cn header &gt; Server: nginx</div><div class="line">www.sina.com.cn header &gt; Date: Mon, <span class="number">14</span> Nov <span class="number">2016</span> <span class="number">12</span>:<span class="number">17</span>:<span class="number">29</span> GMT</div><div class="line">www.sina.com.cn header &gt; Content-Type: text/html</div><div class="line">www.sina.com.cn header &gt; Last-Modified: Mon, <span class="number">14</span> Nov <span class="number">2016</span> <span class="number">12</span>:<span class="number">17</span>:<span class="number">02</span> GMT</div><div class="line">www.sina.com.cn header &gt; Vary: Accept-Encoding</div><div class="line">www.sina.com.cn header &gt; Expires: Mon, <span class="number">14</span> Nov <span class="number">2016</span> <span class="number">12</span>:<span class="number">18</span>:<span class="number">29</span> GMT</div><div class="line">www.sina.com.cn header &gt; Cache-Control: max-age=<span class="number">60</span></div><div class="line">www.sina.com.cn header &gt; X-Powered-By: shci_v1<span class="number">.03</span></div><div class="line">www.sina.com.cn header &gt; Age: <span class="number">50</span></div><div class="line">www.sina.com.cn header &gt; Content-Length: <span class="number">595123</span></div><div class="line">www.sina.com.cn header &gt; X-Cache: HIT <span class="keyword">from</span> ja108<span class="number">-181.</span>sina.com.cn</div><div class="line">www.sina.com.cn header &gt; Connection: close</div><div class="line">www<span class="number">.163</span>.com header &gt; HTTP/<span class="number">1.0</span> <span class="number">302</span> Moved Temporarily</div><div class="line">www<span class="number">.163</span>.com header &gt; Server: Cdn Cache Server V2<span class="number">.0</span></div><div class="line">www<span class="number">.163</span>.com header &gt; Date: Mon, <span class="number">14</span> Nov <span class="number">2016</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">18</span> GMT</div><div class="line">www<span class="number">.163</span>.com header &gt; Content-Length: <span class="number">0</span></div><div class="line">www<span class="number">.163</span>.com header &gt; Location: http://www<span class="number">.163</span>.com/special/<span class="number">0077j</span>t/error_isp.html</div><div class="line">www<span class="number">.163</span>.com header &gt; Connection: close</div><div class="line">www.sohu.com header &gt; HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line">www.sohu.com header &gt; Content-Type: text/html</div><div class="line">www.sohu.com header &gt; Content-Length: <span class="number">90665</span></div><div class="line">www.sohu.com header &gt; Connection: close</div><div class="line">www.sohu.com header &gt; Date: Mon, <span class="number">14</span> Nov <span class="number">2016</span> <span class="number">12</span>:<span class="number">18</span>:<span class="number">29</span> GMT</div><div class="line">www.sohu.com header &gt; Server: SWS</div><div class="line">www.sohu.com header &gt; Vary: Accept-Encoding</div><div class="line">www.sohu.com header &gt; Cache-Control: no-transform, max-age=<span class="number">120</span></div><div class="line">www.sohu.com header &gt; Expires: Mon, <span class="number">14</span> Nov <span class="number">2016</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">29</span> GMT</div><div class="line">www.sohu.com header &gt; Last-Modified: Mon, <span class="number">14</span> Nov <span class="number">2016</span> <span class="number">12</span>:<span class="number">04</span>:<span class="number">28</span> GMT</div><div class="line">www.sohu.com header &gt; Content-Encoding: gzip</div><div class="line">www.sohu.com header &gt; X-RS: <span class="number">10511343.19686393</span><span class="number">.11189627</span></div><div class="line">www.sohu.com header &gt; FSS-Cache: HIT <span class="keyword">from</span> <span class="number">9580427.16723861</span><span class="number">.11355128</span></div><div class="line">www.sohu.com header &gt; FSS-Proxy: Powered by <span class="number">3944245.5451583</span><span class="number">.5718860</span></div></pre></td></tr></table></figure></p>
<p>三个连接是由一个线程通过Coroutine并发完成。</p>
<p><code>asyncio</code>提供了完善的异步IO支持，异步操作需要在<code>coroutine</code>中通过<code>yield from</code>完成，多个<code>coroutine</code>可以封装一组Task然后并发执行。</p>
<hr>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>用<code>asyncio</code>提供的<code>@asyncio.coroutine</code>可以把一个generator标记为coroutine类型，然后在coroutine内部用<code>yield from</code>调用另一个coroutine实现异步操作。</p>
<p>为了简化并更好地标示异步IO，从python3.5开始引入了新的语法<code>async</code>和<code>await</code>，可以让Coroutine的代码更加简洁易读。</p>
<p><code>async</code>和<code>await</code>是针对coroutine的新语法，要使用新的语法，只需要做两步简单的替换：</p>
<blockquote>
<p>1、把<code>@asyncio.coroutine</code>替换为<code>async</code><br>2、把<code>yield from</code>替换为<code>await</code></p>
</blockquote>
<p>对比一下上一节的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#old</div><div class="line">@asyncio.coroutine</div><div class="line">def hello():</div><div class="line">	print(&apos;Hello world! (%s)&apos; % threading.currentThread())</div><div class="line">	yield from asyncio.sleep(1)</div><div class="line">	print(&apos;Hello again! (%s)&apos; % threading.currentThread())</div><div class="line"></div><div class="line">#new</div><div class="line">async def hello():</div><div class="line">	print(&apos;Hello world! (%s)&apos; % threading.currentThread())</div><div class="line">	await asyncio.sleep(1)</div><div class="line">	print(&apos;Hello again! (%s)&apos; % threading.currentThread())</div></pre></td></tr></table></figure></p>
<p>剩下代码保持不变。</p>
<hr>
<h2 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h2><p><code>asyncio</code>可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把<code>asyncio</code>用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+<code>cortinue</code>实现多用户的高并发支持。</p>
<p><code>asyncio</code>实现了TCP、UDP、SSL等协议，<code>aiohttp</code>则是基于<code>asyncio</code>实现了HTTP框架。</p>
<p>安装<code>aiohttp</code>然后编写一个HTTP服务器，分别处理以下URL：</p>
<blockquote>
<p><code>/</code>-首页返回<code>b&#39;&lt;h1&gt;Index&lt;/h1&gt;&#39;</code><br><code>/hello/{name}</code>-根据URL参数返回文本<code>hello, %s!</code></p>
</blockquote>
<p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</div><div class="line">    <span class="keyword">return</span> web.Response(body=<span class="string">b'&lt;h1&gt;Index&lt;/h1&gt;'</span>)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</div><div class="line">    text = <span class="string">'&lt;h1&gt;hello, %s!&lt;/h1&gt;'</span> % request.match_info[<span class="string">'name'</span>]</div><div class="line">    <span class="keyword">return</span> web.Response(body=text.encode(<span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(loop)</span>:</span></div><div class="line">    app = web.Application(loop=loop)</div><div class="line">    app.router.add_route(<span class="string">'GET'</span>, <span class="string">'/'</span>, index)</div><div class="line">    app.router.add_route(<span class="string">'GET'</span>, <span class="string">'/hello/&#123;name&#125;'</span>, hello)</div><div class="line">    srv = <span class="keyword">await</span> loop.create_server(app.make_handler(), <span class="string">'127.0.0.1'</span>, <span class="number">8000</span>)</div><div class="line">    print(<span class="string">'Server started at http://127.0.0.1:8000...'</span>)</div><div class="line">    <span class="keyword">return</span> srv</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(init(loop))</div><div class="line">loop.run_forever()</div></pre></td></tr></table></figure></p>
<p>注意<code>aiohttp</code>的初始化函数<code>init()</code>也是一个<code>coroutine</code>，<code>loop.creat_server()</code>则利用<code>asyncio</code>创建TCP服务。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/08/14.网络编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/14.网络编程/" itemprop="url">14. 网络编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T17:58:50+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>现在几乎所有的程序都是网络程序，很少有单机版的程序了。计算机网络就是把各个计算机连接到一起，让网络中的计算机可以互相通信。网络编程就是如何在程序中实现两台计算机的通信。比如当你使用浏览器浏览新浪网时，你的计算机就和新浪的某台服务器通过互联网连接起来了，然后新浪的服务器把网页内容作为数据通过互联网传输到你的电脑。由于电脑上有很多软件，不同的程序连接的别的计算机也会不同。网络通信是两台计算机上的两个进程之间的通信。</p>
<p>网络编程对所有开发语言都是一样的。用Python进行网络编程，就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信。</p>
<h3 id="TCP-IP简介"><a href="#TCP-IP简介" class="headerlink" title="TCP/IP简介"></a>TCP/IP简介</h3><p>计算机wield联网，必须规定通信协议，早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Micosoft都有各自的网络协议，互不兼容，同样的网络协议的计算机可以互相交流，不同协议的计算机就不可以。</p>
<p>为了实现所有不同类型的计算机都连接起来，互联网协议簇（Internet Protocol Suite）就是通用协议标准。最主要的两个协议是TCP协议和IP协议。</p>
<p>通信的时候，双方必须知道对方的标识，互联网中每一个计算机的唯一标识就是IP地址。如果一台计算机同时接入两个或两个以上的网络，比如路由器，它就会有两个或更多个IP地址，所以IP地址对应的实际上是计算机的网络接口，通常是网卡。</p>
<p>IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此路由器就负责决定如何把一个IP包转发出去。IP报的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺利到达。</p>
<p>TCP协议是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后对每个IP包进行编号，确保对方按顺序收到，如果包丢了，就自动重发。</p>
<p>一个IP包除了包含要传输的数据外，还包含源IP地址和目的IP地址，源端口和目的端口。</p>
<p>在两台计算机通信时，只发IP地址是不够的，因为同一台计算机上跑着多个网络程序。一个IP包来了之后，到底是交给浏览器还是QQ就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号这样，两个进程在两台计算机之间建立的网络连接就需要各自的IP地址和各自的端口号。一个进程也可能同时与多个计算机建立链接，因此会申请很多端口。</p>
<h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><p>Socket是网络编程的一个抽象概念。通常我们用一个Socket表示打开了一个网络链接，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动相应连接的叫服务器。当我们在浏览器中访问新浪时，我们自己的计算机就是客户端，浏览器会主动向新浪的服务器发起连接。如果一切顺利，新浪的服务器接受了我们的连接，一个TCP连接就建立起来了，后面的通信就是发送网页内容了。所以我们要创建一个基于TCP的Socket：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</div><div class="line">s.connect((<span class="string">'www.sina.com.cn'</span>,<span class="number">80</span>))</div></pre></td></tr></table></figure></p>
<p>创建<code>Socket</code>时，<code>AF_INET</code>指定使用IPv4协议，如果要用更先进的IPv6，就指定为<code>AF_INET6</code>。<code>SOCK_STREAM</code>指定使用面向流的TCP协议，这样一个<code>Socket</code>对象就创建成功，但是还没有建立连接。</p>
<p>客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。IP地址可以用域名自动转换得到，端口号需要服务器来提供。服务器提供什么样的服务，端口号就必须固定下来。80端口是WEB服务的标准端口。端口号小于1024的是Internet标准服务的端口，端口号大于1024的可以任意使用。</p>
<p>建立TCP连接后，我们可以向新浪服务器发送请求，要求返回首页的内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s.send(<span class="string">b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n'</span>)</div></pre></td></tr></table></figure></p>
<p>TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发怎么协调要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪返回的数据了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">buffer=[]</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">	d=s.recv(<span class="number">1024</span>)</div><div class="line">	<span class="keyword">if</span> d:</div><div class="line">		buffer.append(d)</div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		<span class="keyword">break</span></div><div class="line">data=<span class="string">b''</span>.join(buffer)</div></pre></td></tr></table></figure></p>
<p>接收数据时，调用<code>recv(max)</code>方法，一次最多接收指定的字节数，因此在一个while循环中反复接收，直到<code>recv()</code>返回空数据，表示接收完毕，退出循环。</p>
<p>当我们接收完出局后，调用<code>close()</code>方法关闭Socket，这样一次完整的网络通信就结束了。接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，吧HTTP头打印出来，网页内容保存到文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">header, html = data.split(<span class="string">b'\r\n\r\n'</span>, <span class="number">1</span>)</div><div class="line">print(header.decode(<span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(<span class="string">'sina.html'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</div><div class="line">	f.write(html)</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">D:\笔记\Python\Notepad++&gt;python <span class="number">11.</span>py</div><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line">Server: nginx</div><div class="line">Date: Mon, <span class="number">07</span> Nov <span class="number">2016</span> <span class="number">12</span>:<span class="number">24</span>:<span class="number">26</span> GMT</div><div class="line">Content-Type: text/html</div><div class="line">Last-Modified: Mon, <span class="number">07</span> Nov <span class="number">2016</span> <span class="number">12</span>:<span class="number">23</span>:<span class="number">13</span> GMT</div><div class="line">Vary: Accept-Encoding</div><div class="line">Expires: Mon, <span class="number">07</span> Nov <span class="number">2016</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">26</span> GMT</div><div class="line">Cache-Control: max-age=<span class="number">60</span></div><div class="line">X-Powered-By: shci_v1<span class="number">.03</span></div><div class="line">Age: <span class="number">31</span></div><div class="line">Content-Length: <span class="number">597288</span></div><div class="line">X-Cache: HIT <span class="keyword">from</span> ja180<span class="number">-183.</span>sina.com.cn</div><div class="line">Connection: close</div></pre></td></tr></table></figure></p>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>和客户端相比，服务器编程要复杂一些。服务器进程首先要绑定一份端口并监听来自其他客户端的连接。服务器会打开固定端口监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以服务器要能够区分一个Socket连接是和那个客户端绑定的。一个Socket依赖四项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。</p>
<p>每个连接都需要一个新的进程或者线程来处理，否则服务器一次就只能服务一个客户端了。我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上<code>Hello</code>再发回去。首先创建一个基于IPv4和TCP协议的Socket：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</div></pre></td></tr></table></figure></p>
<p>然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用<code>0.0.0.0</code>绑定到所有的网络地址，还可以用<code>127.0.0.1</code>绑定到本机地址。</p>
<p>端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号，小于1024的端口号必须有管理员权限才能绑定：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s.blind(<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>)</div></pre></td></tr></table></figure></p>
<p>紧接着，调用<code>listen()</code>方法开始监听，传入的参数指定等待连接的最大数量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s.listen(<span class="number">5</span>)</div><div class="line">print(<span class="string">'Waiting for connection...'</span>)</div></pre></td></tr></table></figure></p>
<p>接下来，服务器程序通过一个永久循环来接受来自客户端的连接，<code>accept()</code>会等待并返回一个客户端的连接：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">	sock.addr=s.accept()</div><div class="line">	t=threading.Thread(target==tcplink,args=(sock, addr))</div><div class="line">	t.start()</div></pre></td></tr></table></figure></p>
<p>每个连接都必须创建新的线程或进程来处理，否则，单线程在处理连接的过程中无法接受其他客户端的连接：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcplink</span><span class="params">(sock, addr)</span>:</span></div><div class="line">	print(<span class="string">'Accecpt new connection from %s:%s...'</span> %addr)</div><div class="line">	sock.send(<span class="string">b'Welcome!'</span>)</div><div class="line">	<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">		data=sock.recv(<span class="number">1024</span>)</div><div class="line">		time.sleep(<span class="number">1</span>)</div><div class="line">		<span class="keyword">if</span> <span class="keyword">not</span> data <span class="keyword">or</span> data.decode(<span class="string">'utf-8'</span>) == <span class="string">'exit'</span>:</div><div class="line">			<span class="keyword">break</span></div><div class="line">		sock.send((<span class="string">'Hello, %s!'</span> %data.decode(<span class="string">'utf-8'</span>)).encode(<span class="string">'utf-8'</span>))</div><div class="line">		sock.close()</div><div class="line">		print(<span class="string">'Connection from %s:%s closed.'</span> %addr)</div></pre></td></tr></table></figure></p>
<p>建立连接后，服务器首先发一条欢迎信息，然后等待客户端数据，并加上Hello再发送给客户端，如果客户端发送了exit字符串，就直接关闭连接。要测试这个程序，我们还需要编写一个客户端程序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line"><span class="comment"># 建立连接:</span></div><div class="line">s.connect((<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>))</div><div class="line"><span class="comment"># 接收欢迎消息:</span></div><div class="line">print(s.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</div><div class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b'Michael'</span>, <span class="string">b'Tracy'</span>, <span class="string">b'Sarah'</span>]:</div><div class="line">    <span class="comment"># 发送数据:</span></div><div class="line">    s.send(data)</div><div class="line">    print(s.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</div><div class="line">s.send(<span class="string">b'exit'</span>)</div><div class="line">s.close()</div></pre></td></tr></table></figure></p>
<p>用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后对每一个新的连接，创建一个线程或进程来处理。通常，服务器会无限运行下去。</p>
<hr>
<p>##UDP 编程</p>
<p>TCP建立的是可靠的连接，并且通信双方都可以以流的形式发送数据。UDP是面向无连接的协议。使用UDP时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包，但是能够到达就不知道了。UDP的有点在于速度快，对于不要求可靠到达的数据，就可以使用UDP协议。</p>
<p>和TCP类似，使用UDP的通信双方也分为客户端和服务器，服务器首先需要绑定端口：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class="line"><span class="comment"># 绑定端口:</span></div><div class="line">s.bind((<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>))</div></pre></td></tr></table></figure></p>
<p>创建Socket时，<code>SOCK_DGRAM</code>指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用<code>listen()</code>方法，而是直接接收来自任何客户端的数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Bind UDP on 9999...'</span>)</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="comment"># 接收数据:</span></div><div class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</div><div class="line">    print(<span class="string">'Received from %s:%s.'</span> % addr)</div><div class="line">    s.sendto(<span class="string">b'Hello, %s!'</span> % data, addr)</div></pre></td></tr></table></figure></p>
<p><code>recvform()</code>方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用<code>sendto()</code>就可以把数据用UDP发送给客户端了。</p>
<p>客户端使用UDP时，首先仍然创建基于UDP的Socket，然后不需要调用<code>connect()</code>直接通过<code>sendto()</code>给服务器发送数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b'Michael'</span>, <span class="string">b'Tracy'</span>, <span class="string">b'Sarah'</span>]:</div><div class="line">    <span class="comment"># 发送数据:</span></div><div class="line">    s.sendto(data, (<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>))</div><div class="line">    <span class="comment"># 接收数据:</span></div><div class="line">    print(s.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</div><div class="line">s.close()</div></pre></td></tr></table></figure></p>
<p>从服务器接收数据仍然调用<code>recv()</code>方法。</p>
<p>UDP的使用与TCP类似，但是不需要建立连接。此外，服务器绑定UDP端口和TCP端口互不冲突，也就是说，UDP的9999端口与TCP的9999端口可以各自绑定。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/07/struts2总结 五--interceptor拦截器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/struts2总结 五--interceptor拦截器/" itemprop="url">struts2总结（五）--interceptor</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-07T14:51:07+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Struts2/" itemprop="url" rel="index">
                    <span itemprop="name">Struts2</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="8-拦截器-interceptor"><a href="#8-拦截器-interceptor" class="headerlink" title="8 拦截器(interceptor)"></a>8 拦截器(interceptor)</h2><h3 id="8-1-Struts架构图"><a href="#8-1-Struts架构图" class="headerlink" title="8.1 Struts架构图"></a>8.1 Struts架构图</h3><p>  <img src="/img/struts_arch.jpg" alt="Alt text"></p>
<h3 id="8-2-Struts执行过程分析"><a href="#8-2-Struts执行过程分析" class="headerlink" title="8.2 Struts执行过程分析"></a>8.2 Struts执行过程分析</h3><p><img src="/img/struts.png" alt="Alt text"></p>
<blockquote>
<ul>
<li>拦截器：拦截器是struts2框架中提供的一种Java类</li>
<li>作用：<pre><code>* 可以拦截访问Action的请求
* 给这个Action加上新的丰富功能（上传，参数自动接收，类型自动转换等）需要配置之后，指明哪一个拦截器去拦截哪一个Action或者哪一些Action，这个拦截器才会去拦截我们的Action。
</code></pre></li>
<li>拦截器工作原理：<pre><code>1. 有一个拦截器的类（框架的或者自定义的）
2. 在配置文件中把这个拦截器类配置出来
3. 指明这个拦截器要拦截哪一个或者哪一些action
4. 客户端发送一个请求访问一个被拦截器拦截的Action
5. 这个请求首先会被struts2 的filter所拦截，filter会检查这个请求是不是请求的Action，如果是，会再检查这个Action有没有被定义的拦截器所拦截，如果有，那么把这个请求交给拦截器去处理
</code></pre></li>
</ul>
</blockquote>
<h3 id="8-3-Interceptor拦截器过程模拟"><a href="#8-3-Interceptor拦截器过程模拟" class="headerlink" title="8.3  Interceptor拦截器过程模拟"></a>8.3  Interceptor拦截器过程模拟</h3><ul>
<li>定义一个Interceptor接口，有一个intercept方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Inteceptor &#123;</div><div class="line">    public void intercept(ActionInvocation actionInvocation);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>创建两个interceptor实现了interceptor接口：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class FirstInterceptor implements Inteceptor&#123;</div><div class="line">    @Override</div><div class="line">    public void intercept(ActionInvocation actionInvocation) &#123;</div><div class="line">        System.out.println(1);</div><div class="line">        actionInvocation.invoke();</div><div class="line">        System.out.println(-1);</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class SecondInterceptor implements Inteceptor&#123;</div><div class="line">    @Override</div><div class="line">    public void intercept(ActionInvocation actionInvocation) &#123;</div><div class="line">        System.out.println(2);</div><div class="line">        actionInvocation.invoke();</div><div class="line">        System.out.println(-2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>定义一个Action</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class SecondInterceptor implements Inteceptor&#123;</div><div class="line">    @Override</div><div class="line">    public void intercept(ActionInvocation actionInvocation) &#123;</div><div class="line">        System.out.println(2);</div><div class="line">        actionInvocation.invoke();</div><div class="line">        System.out.println(-2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>定义ActionInvocation</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class ActionInvocation &#123;</div><div class="line">    List&lt;Inteceptor&gt; inteceptors = new ArrayList&lt;&gt;();</div><div class="line">    int index = -1;</div><div class="line">    Action a = new Action();</div><div class="line"></div><div class="line">    public ActionInvocation() &#123;</div><div class="line">        this.inteceptors.add(new FirstInterceptor());</div><div class="line">        this.inteceptors.add(new SecondInterceptor());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void invoke() &#123;</div><div class="line">        index++;</div><div class="line">        if (index &gt;= this.inteceptors.size()) &#123;</div><div class="line">            a.execute();</div><div class="line">        &#125; else &#123;</div><div class="line">            this.inteceptors.get(index).intercept(this);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行main文件:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new ActionInvocation().invoke();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>运行结果为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">execute</div><div class="line">-2</div><div class="line">-1</div></pre></td></tr></table></figure>
<blockquote>
<p>从而执行顺序为，首先main函数，创建ActionInvocation对象，初始化的时候讲两个Inteceptor加到interceptors这个列表中，调用其invoke()方法，当还有interceptor没有访问时，调用第一个interceptor的intercept方法，输出1，并调用ActionInvocation的invoke方法，此时会调用第二个Inteceptor的intercept方法，输出2，并调用ActionInvocation的invoke方法，此时不存在拦截器，执行Action输出execute，后面依次输出-2 -1， 完成这个模拟过程！</p>
</blockquote>
<h3 id="8-4-定义自己的拦截器"><a href="#8-4-定义自己的拦截器" class="headerlink" title="8.4 定义自己的拦截器"></a>8.4 定义自己的拦截器</h3><ul>
<li><p>struts2框架已经写好了很多个拦截器，同时也把这些拦截器配置在配置文件里面struts-default.xml中，除此之外，我们可以写自己的拦截器</p>
</li>
<li><p>首先实现一个Interceptor接口：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MyInterceptor implements Interceptor &#123;</div><div class="line"></div><div class="line">	public void destroy() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void init() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String intercept(ActionInvocation invocation) throws Exception &#123;</div><div class="line">		long start = System.currentTimeMillis();</div><div class="line">		String r = invocation.invoke();</div><div class="line">		long end = System.currentTimeMillis();</div><div class="line">		System.out.println(&quot;action time = &quot; + (end - start));</div><div class="line">		return r;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>然后在struts.xml文件中配置出这个拦截器：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;package name=&quot;test&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;</div><div class="line">		&lt;interceptors&gt;</div><div class="line">			&lt;interceptor name=&quot;my&quot; class=&quot;com.interceptor.MyInterceptor&quot;&gt;&lt;/interceptor&gt;</div><div class="line">		&lt;/interceptors&gt;</div><div class="line"></div><div class="line">		&lt;action name=&quot;test&quot; class=&quot;com.action.TestAction&quot;&gt;</div><div class="line">			&lt;result&gt;/test.jsp&lt;/result&gt;</div><div class="line">			&lt;interceptor-ref name=&quot;my&quot;&gt;&lt;/interceptor-ref&gt;</div><div class="line">			&lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt;</div><div class="line">		&lt;/action&gt;</div><div class="line"></div><div class="line">	&lt;/package&gt;</div></pre></td></tr></table></figure>
<h3 id="8-5-拦截器栈"><a href="#8-5-拦截器栈" class="headerlink" title="8.5 拦截器栈"></a>8.5 拦截器栈</h3><p>当一个Action需要被多个拦截器拦截的时候，正常情况下我们需要在这个Action中去引用要使用的多个拦截器，但是我们可以使用一个拦截器栈去包含那几个拦截器，然后直接在Action中引用这个拦截器栈就可以。</p>
<ul>
<li>一个拦截器栈可以包含多个拦截器</li>
<li>一个拦截器栈还可以包含其他拦截器栈</li>
<li>定义拦截器栈都要在<interceptors>标签中</interceptors></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;interceptors&gt;</div><div class="line">   &lt;interceptor name=&quot;myInterceptor&quot; class=&quot;com.interceptor.MyInterceptor&quot;&gt;&lt;/interceptor&gt;</div><div class="line">   &lt;interceptor-stack name=&quot;myStack&quot;&gt;</div><div class="line">   &lt;!-- 这是我们自己定义的一个拦截器 --&gt;</div><div class="line">      &lt;interceptor-ref name=&quot;myInterceptor&quot;&gt;&lt;/interceptor-ref&gt;</div><div class="line">     &lt;!-- 这是struts-default.xml文件中定义的一个拦截器 --&gt;</div><div class="line">      &lt;interceptor-ref name=&quot;params&quot;&gt;&lt;/interceptor-ref&gt;</div><div class="line">     &lt;!-- 这是struts-default.xml文件中定义的一个拦截器栈 --&gt;</div><div class="line">    &lt;interceptor-ref name=&quot;basicStack&quot;&gt;&lt;/interceptor-ref&gt;</div><div class="line">   &lt;/interceptor-stack&gt;</div><div class="line">  &lt;/interceptors&gt;</div></pre></td></tr></table></figure>
<h3 id="8-6-默认拦截器栈-拦截器"><a href="#8-6-默认拦截器栈-拦截器" class="headerlink" title="8.6 默认拦截器栈/拦截器"></a>8.6 默认拦截器栈/拦截器</h3><p>在一个package中，我们可以把一个拦截器或者拦截器栈的声明为一个默认的拦截器/拦截器栈。以后这个package中所有的Action都会被这个默认的拦截器/拦截器栈所拦截</p>
<ul>
<li>我们写的任何Action都会被一个叫做defaultStack的拦截器栈所拦截，这个拦截器栈包含了十几个拦截器，这些拦截器给我们的Action提供了很多丰富的功能，因为我们写的所有的package都是直接或者间接继承了struts-default.xml文件中的一个名字叫struts-default的package， struts-default包中又把名字叫做defaultStack的拦截器栈配置成了一个默认的拦截器栈，我们的package继承了这个，所有的Action都会被defaultStack所拦截。</li>
<li>但是如果我们指明了一个Action被我们所写的一个拦截器/拦截器栈所拦截，name这个Action就不会被defaultStack拦截了，所以我们需要在Action中主动的在声明这个Action被defaultStack所拦截，或者把defaultStack加入到我们自己定义的拦截器栈里面。</li>
<li>也可以专门定义一个package专门定义拦截器，拦截器栈，其他package继承这个拦截器栈package：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 在这个package中,我们只定义拦截器/拦截器栈 --&gt;</div><div class="line">    &lt;package name=&quot;MyInter&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt;</div><div class="line"></div><div class="line">    &lt;interceptors&gt;</div><div class="line">        &lt;interceptor name=&quot;myInterceptor&quot; class=&quot;com.briup.web.interceptor.MyInterceptor&quot;&gt;&lt;/interceptor&gt;</div><div class="line">        &lt;interceptor-stack name=&quot;myStack&quot;&gt;</div><div class="line">            &lt;interceptor-ref name=&quot;myInterceptor&quot;&gt;&lt;/interceptor-ref&gt;</div><div class="line">            &lt;!-- 这是struts-default.xml文件中定义的一个拦截器栈 --&gt;</div><div class="line">            &lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt;</div><div class="line">        &lt;/interceptor-stack&gt;</div><div class="line">    &lt;/interceptors&gt;</div><div class="line"></div><div class="line">    &lt;!-- 声明默认拦截器/拦截器栈 --&gt;</div><div class="line">    &lt;!-- 当前包中所有的action都会被这个myStack所拦截器 --&gt;</div><div class="line">    &lt;!-- 继承了当前包的其他包里面的所有action也会被这个myStack所拦截器 --&gt;</div><div class="line">    &lt;default-interceptor-ref name=&quot;myStack&quot;&gt;&lt;/default-interceptor-ref&gt;</div><div class="line"></div><div class="line">    &lt;/package&gt;</div></pre></td></tr></table></figure>
<h3 id="8-7-类型转换"><a href="#8-7-类型转换" class="headerlink" title="8.7 类型转换"></a>8.7 类型转换</h3><p>类型转换：解析HTTP请求参数，将HTTP请求参数赋值给Action属性，当其类型不一致时进行的类型转换操作。struts2完成了String和基本类型的类型转换，只要Action属性有get set 方法。同时其还支持自定义的类型转换。</p>
<p>struts2类型转换时通过Params拦截器进行转换的；如果转换失败，则conversionError拦截器拦截该异常，并封装到fieldError中，放入ActionContext中。</p>
<h4 id="8-7-1-基础类型转换："><a href="#8-7-1-基础类型转换：" class="headerlink" title="8.7.1 基础类型转换："></a>8.7.1 基础类型转换：</h4><p>testAction：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">public class TestAction extends ActionSupport&#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">    private Date d;</div><div class="line">    Set&lt;String&gt; interests;</div><div class="line">    Map&lt;String, String&gt; users;</div><div class="line"></div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getAge() &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAge(int age) &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Date getD() &#123;</div><div class="line">        return d;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setD(Date d) &#123;</div><div class="line">        this.d = d;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Set&lt;String&gt; getInterests() &#123;</div><div class="line">        return interests;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setInterests(Set&lt;String&gt; interests) &#123;</div><div class="line">        this.interests = interests;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Map&lt;String, String&gt; getUsers() &#123;</div><div class="line">        return users;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setUsers(Map&lt;String, String&gt; users) &#123;</div><div class="line">        this.users = users;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String execute() throws Exception &#123;</div><div class="line">        return super.execute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>test.jsp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">name:&lt;s:property value=&quot;name&quot;/&gt;&lt;br/&gt;</div><div class="line">age:&lt;s:property value=&quot;age&quot;/&gt;&lt;br/&gt;</div><div class="line">date:&lt;s:property value=&quot;d&quot;/&gt;&lt;br/&gt;</div><div class="line">&lt;s:date name=&quot;d&quot; format=&quot;yyyy/MM/dd HH:mm:ss&quot;/&gt;&lt;br/&gt;</div><div class="line">&lt;s:property value=&quot;interests&quot;/&gt;&lt;br/&gt;</div><div class="line">&lt;s:property value=&quot;users&quot;/&gt;&lt;br/&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<h4 id="8-7-2自定义类型转换"><a href="#8-7-2自定义类型转换" class="headerlink" title="8.7.2自定义类型转换"></a>8.7.2自定义类型转换</h4><p>自定义类型转换器方法:</p>
<h5 id="继承DefaultTypeConverter，重写convertValue方法，这个方法的功能是完成双向转换-Sting数组转换到Action属性。函数模板为："><a href="#继承DefaultTypeConverter，重写convertValue方法，这个方法的功能是完成双向转换-Sting数组转换到Action属性。函数模板为：" class="headerlink" title="继承DefaultTypeConverter，重写convertValue方法，这个方法的功能是完成双向转换,Sting数组转换到Action属性。函数模板为："></a>继承DefaultTypeConverter，重写convertValue方法，这个方法的功能是完成双向转换,Sting数组转换到Action属性。函数模板为：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class MyPointConverter extends DefaultTypeConverter&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Object convertValue(Object value, Class toType) &#123;</div><div class="line">		if(toType == Point.class) &#123;</div><div class="line">			Point p = new Point();</div><div class="line">			String[] strs = (String[])value;</div><div class="line">			String[] xy = strs[0].split(&quot;,&quot;);</div><div class="line">			p.x = Integer.parseInt(xy[0]);</div><div class="line">			p.y = Integer.parseInt(xy[1]);</div><div class="line">			return p;</div><div class="line">		&#125;</div><div class="line">		if(toType == String.class) &#123;</div><div class="line">			return value.toString();</div><div class="line">		&#125;</div><div class="line">		return super.convertValue(value, toType);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="继承StrutsTypeConverter"><a href="#继承StrutsTypeConverter" class="headerlink" title="继承StrutsTypeConverter"></a>继承StrutsTypeConverter</h5><ul>
<li>StrutsTypeConverter是DefaultTypeConverter的子类。在两个方向的类型转换上分别实现：</li>
</ul>
<p>MyPointerConverter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MyPointConverter extends StrutsTypeConverter&#123;</div><div class="line">    @Override</div><div class="line">    public Object convertFromString(Map map, String[] strings, Class aClass) &#123;</div><div class="line">        Point point = new Point();</div><div class="line">        String[] strings1 = (String[])strings;</div><div class="line">        String[] xy = strings1[0].split(&quot;,&quot;);</div><div class="line">        point.x = Integer.parseInt(xy[0]);</div><div class="line">        point.y = Integer.parseInt(xy[1]);</div><div class="line">        return point;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String convertToString(Map map, Object o) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TestAction:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class TestAction extends ActionSupport&#123;</div><div class="line">    Point p;</div><div class="line">    List&lt;Point&gt; ps;</div><div class="line">    Map&lt;String, Point&gt; points;</div><div class="line"></div><div class="line">    public Point getP() &#123;</div><div class="line">        return p;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setP(Point p) &#123;</div><div class="line">        this.p = p;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public List&lt;Point&gt; getPs() &#123;</div><div class="line">        return ps;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setPs(List&lt;Point&gt; ps) &#123;</div><div class="line">        this.ps = ps;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Map&lt;String, Point&gt; getPoints() &#123;</div><div class="line">        return points;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setPoints(Map&lt;String, Point&gt; points) &#123;</div><div class="line">        this.points = points;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String execute() throws Exception &#123;</div><div class="line">        return super.execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>jsp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;s:property value=&quot;p&quot;/&gt;&lt;br/&gt;</div><div class="line">&lt;s:property value=&quot;ps&quot;/&gt;&lt;br/&gt;</div><div class="line">points:&lt;s:property value=&quot;points&quot;/&gt;&lt;br/&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<h5 id="注册方式："><a href="#注册方式：" class="headerlink" title="注册方式："></a>注册方式：</h5><ul>
<li>第一种配置方法为在具备类型转换文件中配置，局部类型转换文件命名为<code>ActionName-conversion.properties</code>,位置放在特定的Action目录下，文件内容格式为：<code>typeName=ConverClass</code>仅针对特定的Action的特定属性有效</li>
<li>第二种配置方法为全局类型转换文件中红配置，文件名为xwork-conversion.properties,在<code>WEB-INF\classes</code>下，文件内容格式为：<code>attributeName=ConvertClass</code>, 对某个类型都有效，比如对Point类型注册了类型转换器。</li>
<li><p>注解</p>
<h3 id="8-8-拦截器和过滤器的比较"><a href="#8-8-拦截器和过滤器的比较" class="headerlink" title="8.8 拦截器和过滤器的比较"></a>8.8 拦截器和过滤器的比较</h3></li>
<li>相同点：<ul>
<li>都是一种Java类</li>
<li>都能拦截客户端发给服务端的请求</li>
<li>拦截到请求之后都可以做一些相应的处理，最后还可以把这个请求放行</li>
<li>都需要实现各自相应的接口记忆在相应的配置文件中配置</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li>拦截器是Struts2框架中定义的，过滤器是web里面的对象，是J2EE标准定义的</li>
<li>拦截器只会拦截访问Action的请求，过滤器可以拦截所有的请求</li>
<li>拦截器定义在struts.xml文件中，过滤器定义在web.xml中</li>
<li>拦截器对象的创建、调用、销毁时struts2框架负责的，过滤器对象的创建、调用、销毁时服务器负责的。</li>
</ul>
<p><em>我们自己定义的filter也可以拦截struts2框架中的Action，需要在web.xml文件中把我们自己的filter配置在struts2的filter上面才可以，因为web.xml文件中的filter配置的先后顺序控制filter起作用的顺序，如果struts的filter先拦截到访问action的请求后，不会把这个请求交给下面的filter，而是交给它内部的拦截器。如果我们自己的filter拦截到请求之后，还是会交给下一个filter，也就是交给struts2的filter</em></p>
</li>
</ul>
<h2 id="9-注解Annotation"><a href="#9-注解Annotation" class="headerlink" title="9 注解Annotation"></a>9 注解Annotation</h2><h3 id="9-1-注解使用方式"><a href="#9-1-注解使用方式" class="headerlink" title="9.1 注解使用方式"></a>9.1 注解使用方式</h3><ol>
<li>引入支持struts2框架注解开发的jar包 struts2-convention-plugin-2.3.4.1</li>
<li>struts.xml <code>&lt;constant name=&quot;struts.convention.action.suffix&quot; value=&quot;Action&quot;/&gt;</code></li>
<li><p>Struts2使用注解开发需要遵循一定的规范：</p>
<ul>
<li>Action要必须继承ActionSupport父类</li>
<li>Action所在的包名必须以Action结尾</li>
<li>package-info.java <em>在这里配置这个包下所有的类都可以用</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> @Namespace(&quot;/&quot;)</div><div class="line">@ParentPackage(&quot;struts-default&quot;)</div><div class="line">@DefaultInterceptorRef(&quot;authStack&quot;)//authStack自定义的拦截器</div><div class="line"> package com.briup.action.manager;</div><div class="line">import org.apache.struts2.convention.annotation.Namespace;</div><div class="line">import org.apache.struts2.convention.annotation.ParentPackage;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="9-2-Action常用注解"><a href="#9-2-Action常用注解" class="headerlink" title="9.2 Action常用注解"></a>9.2 Action常用注解</h3><ul>
<li><p>Namespace Annotation</p>
<ul>
<li>通过在ActionClass上定义@Namespace(“/custom”)</li>
<li>通过package0info.java定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Namespace(&quot;/manager&quot;)</div><div class="line">@ParentPackage(&quot;default&quot;)</div><div class="line">@DefaultInterceptorRef(&quot;authStack&quot;)</div><div class="line">package com.example.actions;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Action Annotation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1. @Action(interceptorRefs=&#123;</div><div class="line">                @InterceptorRef(&quot;validation&quot;),</div><div class="line">                @InterceptorRef(&quot;defaultStack&quot;)</div><div class="line">            &#125;)</div><div class="line"></div><div class="line">2.      chain</div><div class="line">        @Action(&quot;foo&quot;)</div><div class="line">        public String foo() &#123;</div><div class="line">            return &quot;bar&quot;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Action(&quot;foo-bar&quot;)</div><div class="line">        public String bar() &#123;</div><div class="line">            return SUCCESS;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Result Annotation</p>
<ul>
<li>全局， 整个类可以访问</li>
<li>局部， 某个方法可以访问<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> @Results(&#123;</div><div class="line">    @Result(name=&quot;failure&quot;, location=&quot;fail.jsp&quot;)</div><div class="line">&#125;)</div><div class="line">public class HelloWorld extends ActionSupport &#123;</div><div class="line">    @Action(value=&quot;/different/url&quot;,results=&#123;@Result(name=&quot;success&quot;, location=&quot;http://struts.apache.org&quot;, type=&quot;redirect&quot;)&#125;          )</div><div class="line">    public String execute() &#123;</div><div class="line">        return SUCCESS;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><em>参考：<a href="http://www.jianshu.com/p/a884504a8863" target="_blank" rel="external">http://www.jianshu.com/p/a884504a8863</a></em></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/avatar.gif"
              alt="cdx" />
          
            <p class="site-author-name" itemprop="name">cdx</p>
            <p class="site-description motion-element" itemprop="description">Be a better man!</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">65</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/cdx0312" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:cdxu0312@outlook.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cdx</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
