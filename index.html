<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Be a better man!">
<meta property="og:type" content="website">
<meta property="og:title" content="小黄">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小黄">
<meta property="og:description" content="Be a better man!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小黄">
<meta name="twitter:description" content="Be a better man!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>小黄</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小黄</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">黄小黄的幸福生活！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-java">
          <a href="/Java/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Java
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/20/JDK1.8新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/20/JDK1.8新特性/" itemprop="url">JDK1.8 新特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-20T13:44:42+08:00">
                2018-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/img/jdk1.8.png" alt="Alt text"></p>
<h1 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h1><p>Java8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征被称作扩展方法。</p>
<p>首先我们定义一个接口，该接口有一个抽象方法print和一个具体方法defaultPrint();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface InterfaceEnhancement &#123;</div><div class="line">    void print();</div><div class="line">    default void defaultPrint(String string) &#123;</div><div class="line">        System.out.println( string + &quot;接口可以添加default修饰的非抽象方法了&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现了该接口一个类如下，并对其进行调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class InterfaceEnhancementDemo implements InterfaceEnhancement &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void print() &#123;</div><div class="line">        System.out.println(&quot;实现类实现了InterfaceEnhancement中的print方法&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        InterfaceEnhancementDemo IED = new InterfaceEnhancementDemo();</div><div class="line">        IED.print();</div><div class="line">        IED.defaultPrint(&quot;传给接口中的方法的字符串&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">实现类实现了InterfaceEnhancement中的print方法</div><div class="line">传给接口中的方法的字符串接口可以添加default修饰的非抽象方法了</div></pre></td></tr></table></figure>
<p>考虑到Java中只有单继承，如果需要给一个类赋予新特性，通常是使用接口来实现。允许接口中写具体的实现方法，实现对接口功能的扩展，避免了单继承的弊端。</p>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Java中对字符串进行排序，可以通过传入一个List对象和一个比较器来制定顺序排列。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class LambdaDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        List&lt;String&gt; strings = Arrays.asList(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;11&quot;,&quot;12&quot;,&quot;5&quot;);</div><div class="line">        System.out.println(strings.toString());</div><div class="line">        Collections.sort(strings, new Comparator&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public int compare(String o1, String o2) &#123;</div><div class="line">                return o1.compareTo(o2);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        System.out.println(strings.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Lambda表达式提供了更加简洁的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Collections.sort(strings, (o1, o2) -&gt; o1.compareTo(o2));</div><div class="line">//或者</div><div class="line">Collections.sort(strings, String::compareTo);</div></pre></td></tr></table></figure>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>每一个Lambda表达式对应着一个类型，通常是接口类型。函数式接口指的是仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法中，该接口也可以添加默认方法。</p>
<p>因此实际上，我们可以把Lambda当成任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，只需要给接口添加@FunctionalInterface注解，编译时会检查接口中是否只存在一个抽象方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface FunctionalInterfaceDemo&lt;K,V&gt; &#123;</div><div class="line">    V get(K key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class FITest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        FunctionalInterfaceDemo&lt;String, String&gt; functionalInterfaceDemo = key -&gt; key + &quot;12&quot;;</div><div class="line">        String result = functionalInterfaceDemo.get(&quot;functionInterface&quot;);</div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上不添加注解，程序也是可以正确执行的。而将Lambda表达式映射到一个但方法的接口上，在其他语言中已经有实现了。单一方法的接口使得Lambda表达式更加的简洁。</p>
<h1 id="方法与构造函数引用"><a href="#方法与构造函数引用" class="headerlink" title="方法与构造函数引用"></a>方法与构造函数引用</h1><p>Java中允许你使用<code>::</code>关键字来传递方法或者构造函数的引用，下面有一个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">    String name;</div><div class="line">    int age;</div><div class="line"></div><div class="line">    Person()&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Person(String name, int age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface PersonFactory&lt;P extends Person&gt; &#123;</div><div class="line">    P create(String name, int age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class PersonTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        PersonFactory&lt;Person&gt; personPersonFactory = Person::new;</div><div class="line">        Person person = personPersonFactory.create(&quot;Peter&quot;, 18);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出Person::new获取Person类的构造函数的引用，Java编译器会根据create方法的签名来选取合适的构造方法。</p>
<h1 id="Lambda作用域"><a href="#Lambda作用域" class="headerlink" title="Lambda作用域"></a>Lambda作用域</h1><p>Lambda表达式中访问外层作用域和匿名方法中的方式类似，可以直接访问final修饰的外层局部变量，实例的字段及静态变量。</p>
<h2 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class LocalDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final int num = 123;</div><div class="line">        FunctionalInterfaceDemo&lt;String, String&gt; functionalInterfaceDemo = key -&gt; key + num;</div><div class="line">        System.out.println(functionalInterfaceDemo.get(&quot;123&quot;));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>final不强制要求添加</li>
<li>不添加final，num也不能被后面的程序修改，隐式的final。</li>
</ul>
<h2 id="访问字段和静态变量"><a href="#访问字段和静态变量" class="headerlink" title="访问字段和静态变量"></a>访问字段和静态变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class FieldAndStaticFieldDemo &#123;</div><div class="line">    static int staticNum;</div><div class="line">    int normalNum;</div><div class="line"></div><div class="line">    void testScope() &#123;</div><div class="line">        FunctionalInterfaceDemo&lt;Integer, Integer&gt; f = (key) -&gt; &#123;</div><div class="line">            normalNum = 513;</div><div class="line">            return key +12;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        FunctionalInterfaceDemo&lt;Integer, Integer&gt; f1 = (key) -&gt; &#123;</div><div class="line">            staticNum = 1234455;</div><div class="line">            return key + 12;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="访问接口的默认方法"><a href="#访问接口的默认方法" class="headerlink" title="访问接口的默认方法"></a>访问接口的默认方法</h1><p>JDK1.8中包含了很多内建的函数式接口，如之前常用的Comparator或者Runnable接口，这些接口都增加了@FunctionInterface注解以便可以使用Lambda表达式。同样提供了很多全新的Lambda接口。</p>
<ul>
<li>Predicate接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Predicate&lt;T&gt; &#123;</div><div class="line">    boolean test(T t);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该接口只有一个参数，返回boolean类型的值。改接口包含多种默认方式来将Predicate组合成其他复杂的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Predicate&lt;String&gt; predicate = s -&gt; s.length() &gt; 0;</div><div class="line">System.out.println(predicate.test(&quot;foo&quot;));</div><div class="line">System.out.println(predicate.negate().test(&quot;foo&quot;));</div><div class="line"></div><div class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</div><div class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</div></pre></td></tr></table></figure>
<ul>
<li>Function接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Function&lt;T, R&gt; &#123;</div><div class="line">    R apply(T t);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有一个参数并且返回一个结果，附带了一些组合方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Function&lt;String, Integer&gt; function = Integer::valueOf;</div><div class="line">Function&lt;String, String&gt; function1 = s -&gt; s + 11;</div></pre></td></tr></table></figure>
<ul>
<li>Supplier接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Supplier&lt;T&gt; &#123;</div><div class="line">    T get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回一个任意范式的值。</p>
<ul>
<li>Consumer接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Consumer&lt;T&gt; &#123;</div><div class="line">    void accept(T t);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Comparator接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Comparator&lt;T&gt; &#123;</div><div class="line">    int compare(T o1, T o2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Optional接口</li>
</ul>
<p>不是函数式接口，是用来放置空指针异常的辅助类型。</p>
<ul>
<li>Stream接口</li>
</ul>
<p>表示能应用中哎一组元素上一次执行的操作序列。Stream操作分为中间操作或者最终操作两种，最终操作返回以特定类型的计算结果，而中间操作返回Stream本身。可以将多个操作穿起来。Stream创建过程中需要指定一个数据源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class StreamFuture &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();</div><div class="line">        stringCollection.add(&quot;ddd2&quot;);</div><div class="line">        stringCollection.add(&quot;aaa2&quot;);</div><div class="line">        stringCollection.add(&quot;bbb1&quot;);</div><div class="line">        stringCollection.add(&quot;aaa1&quot;);</div><div class="line">        stringCollection.add(&quot;bbb3&quot;);</div><div class="line">        stringCollection.add(&quot;ccc&quot;);</div><div class="line">        stringCollection.add(&quot;bbb2&quot;);</div><div class="line">        stringCollection.add(&quot;ddd1&quot;);</div><div class="line">        System.out.println(stringCollection.toString());</div><div class="line">        //Filter过滤</div><div class="line">        stringCollection.stream().filter(s -&gt; s.startsWith(&quot;b&quot;)).forEach(System.out::println);</div><div class="line">        //Sort排序</div><div class="line">        stringCollection.stream().sorted().filter(s -&gt; s.startsWith(&quot;b&quot;)).forEach(System.out::println);</div><div class="line">        // map操作</div><div class="line">        stringCollection.stream().map(String::toUpperCase).sorted().forEach(System.out::println);</div><div class="line">        //Match 匹配操作</div><div class="line">        System.out.println(stringCollection.stream().anyMatch(s -&gt; s.startsWith(&quot;a&quot;)));</div><div class="line">        System.out.println(stringCollection.stream().allMatch(s -&gt; s.length() &gt; 0));</div><div class="line">        System.out.println(stringCollection.stream().noneMatch(s -&gt; s.startsWith(&quot;h&quot;)));</div><div class="line">        // count计数</div><div class="line">        long count = stringCollection.stream().filter(s -&gt; s.startsWith(&quot;b&quot;)).count();</div><div class="line">        System.out.println(count);</div><div class="line">        // reduce规约</div><div class="line">        Optional&lt;String&gt; reduce = stringCollection.stream().sorted().reduce((s1,s2) -&gt; s1 + &quot;##&quot; + s2);</div><div class="line">        reduce.ifPresent(System.out::println);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>* Filter过滤：通过一个Predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以在过滤后可以将结果来应用其他Stream操作。forEach需要一个函数来对过滤后的 元素依次执行。forEach时一个最终操作，不能在其之后再执行Stream操作。

* Sort排序：排序是一个中间操作。

* Map映射：中间操作map，会将元素根据指定的Function接口来依次将元素转换成另外的对象，如将小写转换成大写

* Match匹配：检测指定的Predicate是否匹配整个Stream，最终操作。

* Count计数，最终操作，返回Stream中元素的个数，返回值为long

* Reduce规约，将stream中的多个元素规约为一个元素，通过Optional接口来接收结果
</code></pre><p>上述的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1]</div><div class="line">bbb1</div><div class="line">bbb3</div><div class="line">bbb2</div><div class="line">bbb1</div><div class="line">bbb2</div><div class="line">bbb3</div><div class="line">AAA1</div><div class="line">AAA2</div><div class="line">BBB1</div><div class="line">BBB2</div><div class="line">BBB3</div><div class="line">CCC</div><div class="line">DDD1</div><div class="line">DDD2</div><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line">3</div><div class="line">aaa1##aaa2##bbb1##bbb2##bbb3##ccc##ddd1##ddd2</div></pre></td></tr></table></figure>
<h1 id="并行Stream"><a href="#并行Stream" class="headerlink" title="并行Stream"></a>并行Stream</h1><p>多个线程并行计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class MultiStreams &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        List&lt;String&gt; strings = new ArrayList&lt;&gt;(1000000);</div><div class="line">        for (int i = 0 ; i &lt; strings.size(); i++) &#123;</div><div class="line">            UUID uuid = UUID.randomUUID();</div><div class="line">            strings.add(uuid.toString());</div><div class="line">        &#125;</div><div class="line">        //串行计算</div><div class="line">        long time1 = System.nanoTime();</div><div class="line">        strings.stream().sorted();</div><div class="line">        long end1 = System.nanoTime();</div><div class="line">        long mills = TimeUnit.NANOSECONDS.toMillis(end1 - time1);</div><div class="line">        System.out.println(&quot;串行Stream排序1000万个数的时间为&quot; + mills + &quot;ms&quot;);</div><div class="line"></div><div class="line">        //并行计算</div><div class="line">        long time2 = System.nanoTime();</div><div class="line">        strings.stream().sorted();</div><div class="line">        long end2 = System.nanoTime();</div><div class="line">        long mill2 = TimeUnit.NANOSECONDS.toMillis(end2 - time2);</div><div class="line">        System.out.println(&quot;串行Stream排序1000万个数的时间为&quot; + mill2 + &quot;ms&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">串行Stream排序1000万个数的时间为1ms</div><div class="line">串行Stream排序1000万个数的时间为0ms</div></pre></td></tr></table></figure>
<p>实际上，并行计算不一定会快于串行运算，影响的因素很多：</p>
<ul>
<li>数据大小输入数据的大小会影响并行化处理对性能的提升。将问题分解之后并行化处理， 再将结果合并会带来额外的开销。 因此只有数据足够大、 每个数据处理管道花费的时间足够多<br>时， 并行化处理才有意义。</li>
<li>源数据结构，每个管道的操作都基于一些初始数据源，通常是集合。将不同的数据源分割相对容易,这里的开销影响了在管道中并行处理数据时到底能带来多少性能上的提升。</li>
<li>装箱,处理基本类型比处理装箱类型要快。</li>
<li>核的数量，极端情况下，只有一个核，因此完全没必要并行化。显然，拥有的核越多，获得潜在性能提升的幅度就越大。在实践中，核的数量不单指你的机器上有多少核，更是指运行时你的机器能使用多少核。这也就是说同时运行的其他进程，或者线程关联性（强制线程在某些核或CPU上运行）会影响性能。</li>
<li>单元处理开销，比如数据大小，这是一场并行执行花费时间和分解合并操作开销之间的战争。花在流中每个元素身上的时间越长，并行操作带来的性能提升越明显。</li>
</ul>
<h1 id="Date-API"><a href="#Date-API" class="headerlink" title="Date API"></a>Date API</h1><p>Java8中包含了一组全新的时间日期API，简单介绍下：</p>
<ul>
<li>Clock时钟：访问当前日期和时间的方法，对时区敏感。</li>
<li>Timezones时区：ZoneID来标志时区。</li>
<li>LocalTime本地时间：没有时区信息的时间</li>
<li>LocalDate本地日期</li>
<li>LocalDateTime：本地日期时间</li>
</ul>
<h1 id="Annotation注解"><a href="#Annotation注解" class="headerlink" title="Annotation注解"></a>Annotation注解</h1><ul>
<li>Java8中吃吃了多重注解。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@interface Hints &#123;</div><div class="line">    Hint[] value();</div><div class="line">&#125;</div><div class="line">@Repeatable(Hints.class)</div><div class="line">@interface Hint &#123;</div><div class="line">    String value();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Java8中允许一个类型的注解使用多次</li>
</ul>
<p>使用包装类当容器来存多个注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)</div><div class="line">class Person &#123;&#125;</div></pre></td></tr></table></figure>
<p>使用多重注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Hint(&quot;hint1&quot;)</div><div class="line">@Hint(&quot;hint2&quot;)</div><div class="line">class Person &#123;&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/19/Java 反射/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/19/Java 反射/" itemprop="url">Java 反射</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-19T21:49:38+08:00">
                2018-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h1><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能过调用他的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法的功能成为Java语言的反射机制。</p>
<p>反射其实就是把Java类中的各种成分映射成一个个Java的对象。比如一个类包括成员变量，方法，构造方法，接口，包等信息，利用反射技术可以对一个类进行解剖，把各个组成部分映射成一个个对象进行操作。首先需要了解类的加载过程，</p>
<h1 id="类加载过程和对象创建过程"><a href="#类加载过程和对象创建过程" class="headerlink" title="类加载过程和对象创建过程"></a>类加载过程和对象创建过程</h1><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><ol>
<li><p>JVM会先去方法区中找有没有相应类的.class存在，如果有直接使用就可以，如果没有，需要把相关类的.class文件加载到方法区。</p>
</li>
<li><p>.class文件加载到方法区时，会分成两部分加载，先加载非静态内容，再加载静态内容</p>
</li>
<li><p>加载非静态内容：把.class中的所有非静态内容加载到方法区下的非静态区域内</p>
</li>
<li><p>加载静态内容：</p>
<ul>
<li><p>把.class文件中的所有静态内容加载到方法区的静态区域内</p>
</li>
<li><p>静态内容加载完成后，对所有静态变量进行默认初始化</p>
</li>
<li><p>所有的静态变量默认初始化完成之后，再进行显示初始化。</p>
</li>
<li><p>当静态区域下的所有静态变量显示初始化完后，执行静态代码段。</p>
</li>
</ul>
</li>
<li><p>静态区域下的静态代码快执行完毕之后，整个类的加载就完成了。</p>
</li>
</ol>
<h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><ol>
<li><p>在堆内存中开辟一块空间</p>
</li>
<li><p>给开辟的空间分配一个地址</p>
</li>
<li><p>把对象的所有非静态成员变量加载到所开辟的空间下</p>
</li>
<li><p>所有的非静态成员加载完成之后，对所有的非静态成员变量进行默认初始化</p>
</li>
<li><p>默认初始化完成之后，调用构造函数</p>
</li>
<li><p>构造函数入栈执行时，先执行构造函数中的隐式三步，再执行构造函数。</p>
<ul>
<li><p>隐式三步：</p>
<ul>
<li><p>执行super语句</p>
</li>
<li><p>对开辟空间下所有非静态成员变量进行显示初始化</p>
</li>
<li><p>执行构造代码块</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>构造函数执行完毕并弹栈之后，把空间分配的地址赋值给一个引用对象。</p>
</li>
</ol>
<h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><ol>
<li><p>Class类实现了Serializable, AnnotatedElement, GenericDeclaration, Type这四个接口</p>
</li>
<li><p>final函数头，不可继承</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public final class Class&lt;T&gt;</div><div class="line">extends Object</div><div class="line">implements Serializable, GenericDeclaration, Type, AnnotatedElement</div></pre></td></tr></table></figure>
</li>
<li><p>Class类实例表示Java程序中运行的类或者接口，枚举是类的一种而注解是接口的一种。同样数组也是一个可以被反射为Class对象，从而被所有数组来共享其维度和数据。8种基本类型也可以看做为class对象。</p>
</li>
<li><p>需要注意的是Class类没有公有的构造方法，Class对象是有JVM及ClassLoader记载类的过程中自动创建的。</p>
</li>
<li><p>方法列表</p>
<ul>
<li>静态方法</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>返回值</th>
<th style="text-align:center">方法及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>static Class&lt;?&gt;</td>
<td style="text-align:center">forName(String className) Returns the Class object associated with the class or interface with the given string name.</td>
</tr>
<tr>
<td>static Class&lt;?&gt;</td>
<td style="text-align:center">forName(String name, boolean initialize, ClassLoader loader) Returns the Class object associated with the class or interface with the given string name, using the given class loader.</td>
</tr>
</tbody>
</table>
<ul>
<li>常用实例方法</li>
</ul>
<table>
<thead>
<tr>
<th>返回值</th>
<th style="text-align:center">方法及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Class&lt;?&gt;[]</td>
<td style="text-align:center">getClasses() Returns an array containing Class objects representing all the public classes and interfaces that are members of the class represented by this Class object</td>
</tr>
<tr>
<td>ClassLoader</td>
<td style="text-align:center">getClassLoader() Returns the class loader for the class.</td>
</tr>
<tr>
<td>Constructor<t></t></td>
<td style="text-align:center">getConstructor(Class&lt;?&gt;… parameterTypes) Returns a Constructor object that reflects the specified public constructor of the class represented by this Class object.</td>
</tr>
<tr>
<td>Field</td>
<td style="text-align:center">getField(String name) Returns a Field object that reflects the specified public member field of the class or interface represented by this Class object.</td>
</tr>
<tr>
<td>Class&lt;?&gt;[]</td>
<td style="text-align:center">getInterfaces() Determines the interfaces implemented by the class or interface represented by this object.</td>
</tr>
<tr>
<td>Method</td>
<td style="text-align:center">getMethod(String name, Class&lt;?&gt;… parameterTypes) Returns a Method object that reflects the specified public member method of the class or interface represented by this Class object.</td>
</tr>
<tr>
<td>T</td>
<td style="text-align:center">newInstance() Creates a new instance of the class represented by this Class object.</td>
</tr>
</tbody>
</table>
<h1 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h1><p>实际上，我们获取Class对象的方法有三种:</p>
<ol>
<li><p>Object对象的getClass()方法</p>
</li>
<li><p>任何数据类型都有一个都有一个“静态”的class属性</p>
</li>
<li><p>通过Class类的静态方法：forName(String className)</p>
</li>
</ol>
<p>实际中我们需要使用反射来动态的生成对象，而如果已经有了对象也就不需要反射了，多以第一种很少用，第二种需要提前有类的包，同样导入了类的包可以直接创建。因此常用的是第三种，通过一个字符串来将要反射的类的信息传递进来动态生成对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package reflect;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/20</div><div class="line"> */</div><div class="line">public class GetClassMethod &#123;</div><div class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</div><div class="line">        //通过getClass方法</div><div class="line">        Student s1 = new Student();</div><div class="line">        Class stuClass = s1.getClass();</div><div class="line">        System.out.println(stuClass.getName());</div><div class="line"></div><div class="line">        //通过类来获得Class对象</div><div class="line">        Class stuClass2 = Student.class;</div><div class="line">        System.out.println(stuClass2.getName());</div><div class="line"></div><div class="line">        // 通过forName来获取</div><div class="line">        Class stuClass3 = Class.forName(&quot;reflect.Student&quot;);</div><div class="line">        System.out.println(stuClass3.getName());</div><div class="line">        System.out.println(stuClass3 == stuClass2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="通过反射获取构造方法并使用"><a href="#通过反射获取构造方法并使用" class="headerlink" title="通过反射获取构造方法并使用"></a>通过反射获取构造方法并使用</h2><p>Student类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">package reflect;</div><div class="line"></div><div class="line">import java.lang.reflect.Constructor;</div><div class="line">import java.lang.reflect.InvocationTargetException;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/20</div><div class="line"> */</div><div class="line">public class Student &#123;</div><div class="line"></div><div class="line">    //（默认的构造方法）</div><div class="line">    Student(String str)&#123;</div><div class="line">        System.out.println(&quot;(默认)的构造方法 s = &quot; + str);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //无参构造方法</div><div class="line">    public Student()&#123;</div><div class="line">        System.out.println(&quot;调用了公有、无参构造方法执行了。。。&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //有一个参数的构造方法</div><div class="line">    public Student(char name)&#123;</div><div class="line">        System.out.println(&quot;姓名：&quot; + name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //有多个参数的构造方法</div><div class="line">    public Student(String name ,int age)&#123;</div><div class="line">        System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //受保护的构造方法</div><div class="line">    protected Student(boolean n)&#123;</div><div class="line">        System.out.println(&quot;受保护的构造方法 n = &quot; + n);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //私有构造方法</div><div class="line">    private Student(int age)&#123;</div><div class="line">        System.out.println(&quot;私有的构造方法   年龄：&quot;+ age);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</div><div class="line">        Object obj;</div><div class="line">        // 1. 加载Class对象</div><div class="line">        Class&lt;?&gt; aClass = Class.forName(&quot;reflect.Student&quot;);</div><div class="line">        // 2. 获取所有的公有构造方法</div><div class="line">        Constructor&lt;?&gt;[] constructors = aClass.getConstructors();</div><div class="line">        System.out.println(&quot;公有的构造方法：&quot;);</div><div class="line">        for (Constructor constructor : constructors)</div><div class="line">            System.out.println(constructor);</div><div class="line">        //3. 获得所有的构造方法</div><div class="line">        Constructor&lt;?&gt;[] declaredConstructors = aClass.getDeclaredConstructors();</div><div class="line">        System.out.println(&quot;所有声明的构造方法：&quot;);</div><div class="line">        for (Constructor constructor : declaredConstructors)</div><div class="line">            System.out.println(constructor);</div><div class="line">        //4. 获得无参构造方法</div><div class="line">        Constructor constructor1 = aClass.getConstructor(null);</div><div class="line">        System.out.println(&quot;所有公有无参构造方法：&quot;);</div><div class="line">        System.out.println(constructor1);</div><div class="line"></div><div class="line">        obj = constructor1.newInstance();</div><div class="line">        System.out.println(&quot;obj = &quot; + obj);</div><div class="line"></div><div class="line">        //5. 获得私有的构造方法</div><div class="line">        Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor(int.class);</div><div class="line">        System.out.println(&quot;私有的构造方法：&quot;);</div><div class="line">        System.out.println(declaredConstructor);</div><div class="line"></div><div class="line">        declaredConstructor.setAccessible(true);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">公有的构造方法：</div><div class="line">public reflect.Student(java.lang.String,int)</div><div class="line">public reflect.Student()</div><div class="line">public reflect.Student(char)</div><div class="line">所有声明的构造方法：</div><div class="line">private reflect.Student(int)</div><div class="line">protected reflect.Student(boolean)</div><div class="line">public reflect.Student(java.lang.String,int)</div><div class="line">reflect.Student(java.lang.String)</div><div class="line">public reflect.Student()</div><div class="line">public reflect.Student(char)</div><div class="line">所有公有无参构造方法：</div><div class="line">public reflect.Student()</div><div class="line">调用了公有、无参构造方法执行了。。。</div><div class="line">obj = reflect.Student@4554617c</div><div class="line">私有的构造方法：</div><div class="line">private reflect.Student(int)</div></pre></td></tr></table></figure>
<h2 id="获得成员变量并调用"><a href="#获得成员变量并调用" class="headerlink" title="获得成员变量并调用"></a>获得成员变量并调用</h2><ol>
<li>批量的：<br>  public Method[] getMethods():获取所有”公有方法”；（包含了父类的方法也包含Object类）<br>  public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</li>
<li><p>获取单个的：<br>   public Method getMethod(String name,Class&lt;?&gt;… parameterTypes)，name : 方法名；Class … : 形参的Class类型对象<br>   public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes)</p>
</li>
<li><p>调用方法：<br>   Method –&gt; public Object invoke(Object obj,Object… args): obj : 要调用方法的对象，args:调用方式时所传递的实参</p>
</li>
</ol>
<p>Student1类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package reflect;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/20</div><div class="line"> */</div><div class="line">public class Student1 &#123;</div><div class="line">    public void show1(String s)&#123;</div><div class="line">        System.out.println(&quot;调用了：公有的，String参数的show1(): s = &quot; + s);</div><div class="line">    &#125;</div><div class="line">    protected void show2()&#123;</div><div class="line">        System.out.println(&quot;调用了：受保护的，无参的show2()&quot;);</div><div class="line">    &#125;</div><div class="line">    void show3()&#123;</div><div class="line">        System.out.println(&quot;调用了：默认的，无参的show3()&quot;);</div><div class="line">    &#125;</div><div class="line">    private String show4(int age)&#123;</div><div class="line">        System.out.println(&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot; + age);</div><div class="line">        return &quot;abcd&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">package reflect;</div><div class="line"></div><div class="line">import java.lang.reflect.Method;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/20</div><div class="line"> */</div><div class="line">public class MethodInvoke &#123;</div><div class="line">    public static void main(String[] args) throws Exception&#123;</div><div class="line">        // 1. 获取Class对象</div><div class="line">        Class clazz = Class.forName(&quot;reflect.Student1&quot;);</div><div class="line">        // 2. 获取所有公有方法并打印</div><div class="line">        System.out.println(&quot;***************获取所有的”公有“方法*******************&quot;);</div><div class="line">        Method[] methods = clazz.getMethods();</div><div class="line">        for (Method method : methods)</div><div class="line">            System.out.println(method);</div><div class="line">        // 3. 获取所有方法并打印</div><div class="line">        System.out.println(&quot;***************获取所有的方法*******************&quot;);</div><div class="line">        methods = clazz.getDeclaredMethods();</div><div class="line">        for (Method method : methods)</div><div class="line">            System.out.println(method);</div><div class="line">        // 4. 获取所有公有show1方法并调用</div><div class="line">        System.out.println(&quot;***************获取show1()方法*******************&quot;);</div><div class="line">        Method show1 = clazz.getMethod(&quot;show1&quot;, String.class);</div><div class="line">        System.out.println(show1);</div><div class="line">        Object o = clazz.getConstructor().newInstance();</div><div class="line">        show1.invoke(o, &quot;haha&quot;);</div><div class="line"></div><div class="line">        System.out.println(&quot;***************获取私有show4()方法*******************&quot;);</div><div class="line">        Method show4 = clazz.getDeclaredMethod(&quot;show4&quot;, int.class);</div><div class="line">        System.out.println(show4);</div><div class="line">        show4.setAccessible(true);</div><div class="line">        Object invoke = show4.invoke(o, 188);</div><div class="line">        System.out.println(invoke);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">package reflect;</div><div class="line"></div><div class="line">import java.lang.reflect.Method;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/20</div><div class="line"> */</div><div class="line">public class MethodInvoke &#123;</div><div class="line">    public static void main(String[] args) throws Exception&#123;</div><div class="line">        // 1. 获取Class对象</div><div class="line">        Class clazz = Class.forName(&quot;reflect.Student1&quot;);</div><div class="line">        // 2. 获取所有公有方法并打印</div><div class="line">        System.out.println(&quot;***************获取所有的”公有“方法*******************&quot;);</div><div class="line">        Method[] methods = clazz.getMethods();</div><div class="line">        for (Method method : methods)</div><div class="line">            System.out.println(method);</div><div class="line">        // 3. 获取所有方法并打印</div><div class="line">        System.out.println(&quot;***************获取所有的方法*******************&quot;);</div><div class="line">        methods = clazz.getDeclaredMethods();</div><div class="line">        for (Method method : methods)</div><div class="line">            System.out.println(method);</div><div class="line">        // 4. 获取所有公有show1方法并调用</div><div class="line">        System.out.println(&quot;***************获取show1()方法*******************&quot;);</div><div class="line">        Method show1 = clazz.getMethod(&quot;show1&quot;, String.class);</div><div class="line">        System.out.println(show1);</div><div class="line">        Object o = clazz.getConstructor().newInstance();</div><div class="line">        show1.invoke(o, &quot;haha&quot;);</div><div class="line"></div><div class="line">        System.out.println(&quot;***************获取私有show4()方法*******************&quot;);</div><div class="line">        Method show4 = clazz.getDeclaredMethod(&quot;show4&quot;, int.class);</div><div class="line">        System.out.println(show4);</div><div class="line">        show4.setAccessible(true);</div><div class="line">        Object invoke = show4.invoke(o, 188);</div><div class="line">        System.out.println(invoke);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="反射main方法"><a href="#反射main方法" class="headerlink" title="反射main方法"></a>反射main方法</h2><p>Student2类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package reflect;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/20</div><div class="line"> */</div><div class="line">public class Student3 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(&quot;Main 方法执行&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package reflect;</div><div class="line"></div><div class="line">import java.lang.reflect.Method;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/20</div><div class="line"> */</div><div class="line">public class MainInvoke &#123;</div><div class="line">    public static void main(String[] args) throws Exception&#123;</div><div class="line">        Class clazz = Class.forName(&quot;reflect.Student3&quot;);</div><div class="line">        Method main = clazz.getMethod(&quot;main&quot;, String[].class);</div><div class="line">        main.invoke(null, (Object) new String[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中调用main方法时，第一个参数是对象的类型，由于为静态类，则设置为null就可以，第二个参数是方法参数，注意强制转换。</p>
<h2 id="通过反射运行配置文件的内容"><a href="#通过反射运行配置文件的内容" class="headerlink" title="通过反射运行配置文件的内容"></a>通过反射运行配置文件的内容</h2><p>Student4类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package reflect;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/20</div><div class="line"> */</div><div class="line">public class Studnet4 &#123;</div><div class="line">    public void show() &#123;</div><div class="line">        System.out.println(&quot;show&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>a.txt文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">className = reflect.Studnet4</div><div class="line">methodName = show</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package reflect;</div><div class="line"></div><div class="line">import java.io.FileReader;</div><div class="line">import java.io.IOException;</div><div class="line">import java.lang.reflect.Method;</div><div class="line">import java.util.Properties;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/20</div><div class="line"> */</div><div class="line">public class TxtInvoke &#123;</div><div class="line">    public static void main(String[] args) throws Exception&#123;</div><div class="line">        //通过反射获取Class对象</div><div class="line">        Class clazz = Class.forName(getValue(&quot;className&quot;));</div><div class="line">        //2获取show()方法</div><div class="line">        Method method = clazz.getMethod(getValue(&quot;methodName&quot;));</div><div class="line">        //3.调用show()方法</div><div class="line">        method.invoke(clazz.getDeclaredConstructor().newInstance());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //此方法接收一个key，在配置文件中获取相应的value</div><div class="line">    public static String getValue(String key) throws IOException &#123;</div><div class="line">        //获取配置文件的对象</div><div class="line">        Properties properties = new Properties();</div><div class="line">        //获取输入流</div><div class="line">        FileReader in = new FileReader(&quot;E:\\Java_Code\\JavaSE\\ConsistenceHash\\src\\reflect\\a.txt&quot;);</div><div class="line">        //将流加载到配置文件对象中</div><div class="line">        properties.load(in);</div><div class="line">        in.close();</div><div class="line">        //返回根据key获取的value值</div><div class="line">        return properties.getProperty(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更新要反射的类只操作配置文件就可以，便于后期维护和更新。</p>
<h2 id="反射越过泛型检查"><a href="#反射越过泛型检查" class="headerlink" title="反射越过泛型检查"></a>反射越过泛型检查</h2><p>泛型用于编译器，编译过后进行泛型擦除，可以通过反射来越过泛型检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package reflect;</div><div class="line"></div><div class="line">import java.lang.reflect.Method;</div><div class="line">import java.util.ArrayList;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/20</div><div class="line"> */</div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) throws Exception&#123;</div><div class="line">        ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;();</div><div class="line">        strList.add(&quot;aaa&quot;);</div><div class="line">        strList.add(&quot;bbb&quot;);</div><div class="line"></div><div class="line">        //  strList.add(100);</div><div class="line">        //获取ArrayList的Class对象，反向的调用add()方法，添加数据</div><div class="line">        Class clazz = strList.getClass(); //得到 strList 对象的字节码 对象</div><div class="line">        //获取add()方法</div><div class="line">        Method m = clazz.getMethod(&quot;add&quot;, Object.class);</div><div class="line">        //调用add()方法</div><div class="line">        m.invoke(strList, 100);</div><div class="line"></div><div class="line">        //遍历集合</div><div class="line">        for(Object obj : strList)&#123;</div><div class="line">            System.out.println(obj);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/19/Java Enum的用法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/19/Java Enum的用法总结/" itemprop="url">Java Enum用法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-19T16:51:17+08:00">
                2018-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>枚举类可以用来当做常量使用，非常的方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public enum Color &#123;</div><div class="line">    RED, GREEN, BLACK, YELLOW</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="枚举类可以做switch中的判定类型"><a href="#枚举类可以做switch中的判定类型" class="headerlink" title="枚举类可以做switch中的判定类型"></a>枚举类可以做switch中的判定类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class Aweek &#123;</div><div class="line">    Day day = Day.MONDAY;</div><div class="line">    public void getDay() &#123;</div><div class="line">        switch (day) &#123;</div><div class="line">            case MONDAY:</div><div class="line">                day = Day.MONDAY;</div><div class="line">                break;</div><div class="line">            case TUESDAY:</div><div class="line">                day = Day.TUESDAY;</div><div class="line">                break;</div><div class="line">            case WEDSDAY:</div><div class="line">                day = Day.WEDSDAY;</div><div class="line">                break;</div><div class="line">            case THURSDAY:</div><div class="line">                day = Day.THURSDAY;</div><div class="line">                break;</div><div class="line">            case SATURDAY:</div><div class="line">                day = Day.SATURDAY;</div><div class="line">                break;</div><div class="line">            case SUNDAY:</div><div class="line">                day = Day.SUNDAY;</div><div class="line">                break;</div><div class="line">            case FRIDAY:</div><div class="line">                day = Day.FRIDAY;</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        System.out.println(day);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new Aweek().getDay();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum Day &#123;</div><div class="line">    MONDAY, TUESDAY, WEDSDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="枚举中可以添加方法，也可以覆盖方法"><a href="#枚举中可以添加方法，也可以覆盖方法" class="headerlink" title="枚举中可以添加方法，也可以覆盖方法"></a>枚举中可以添加方法，也可以覆盖方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public enum Colors&#123;</div><div class="line">    RED(&quot;red&quot;, 1), GREEN(&quot;green&quot;, 2), BLANK(&quot;blank&quot;, 3), YELLOW(&quot;yellow&quot;, 4);</div><div class="line"></div><div class="line">    //成员变量</div><div class="line">    private String name;</div><div class="line">    private int index;</div><div class="line"></div><div class="line">    // 构造方法</div><div class="line">    Colors(String name, int index) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.index = index;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 覆盖方法</div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return this.index + &quot;&quot; + this.name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getIndex() &#123;</div><div class="line">        return index;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setIndex(int index) &#123;</div><div class="line">        this.index = index;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //普通方法</div><div class="line">    public static String getName(int index) &#123;</div><div class="line">        for (Colors colors : Colors.values()) &#123;</div><div class="line">            if (colors.getIndex() == index)</div><div class="line">                return colors.getName();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="枚举类可以实现接口，但是不能继承类"><a href="#枚举类可以实现接口，但是不能继承类" class="headerlink" title="枚举类可以实现接口，但是不能继承类"></a>枚举类可以实现接口，但是不能继承类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public interface Print &#123;</div><div class="line">    void print();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public enum Colors implements Print&#123;</div><div class="line">    RED(&quot;red&quot;, 1), GREEN(&quot;green&quot;, 2), BLANK(&quot;blank&quot;, 3), YELLOW(&quot;yellow&quot;, 4);</div><div class="line"></div><div class="line">    //成员变量</div><div class="line">    private String name;</div><div class="line">    private int index;</div><div class="line"></div><div class="line">    // 构造方法</div><div class="line">    Colors(String name, int index) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.index = index;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void print() &#123;</div><div class="line">        System.out.println(&quot;haha&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="使用接口来组织枚举的结构"><a href="#使用接口来组织枚举的结构" class="headerlink" title="使用接口来组织枚举的结构"></a>使用接口来组织枚举的结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public interface Food &#123;</div><div class="line">    enum Coffee implements Food &#123;</div><div class="line">        BLACK_COFFEE, DECAF_CAFFEE, LATTE, CAPPUCCINO</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    enum Dessert implements Food&#123;</div><div class="line">        FRUIT, CAKE, GELATO</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/19/JDK源码之ArrayList源码剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/19/JDK源码之ArrayList源码剖析/" itemprop="url">JDK源码之ArrayList源码剖析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-19T10:07:11+08:00">
                2018-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ArrayList是Java集合类中一个非常重要的实现类，低层实现为数组，在随机存储方面性能很高，但是在增删数据方面性能一般。平常使用的很多，但是还没有系统的取读取其源码。</p>
<h1 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</div><div class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>ArrayLis继承了AbstractList抽象类</p>
</li>
<li><p>ArrayList实现了List接口，RandomAccess接口，Cloneable接口和Serializable接口。</p>
<ul>
<li><p>List接口：一开始以为List接口都是很熟悉的东西，结果注释了下源码，发现还是有很多新加的特性，比如可分割迭代器这种，从来没有用过，不过今天的重点不在这里。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;</div><div class="line">    //返回列表的长度</div><div class="line">    int size();</div><div class="line">    //列表是否为空</div><div class="line">    boolean isEmpty();</div><div class="line">    //列表中是否包含某个元素</div><div class="line">    boolean contains(Object o);</div><div class="line">    //获取列表的迭代器</div><div class="line">    Iterator&lt;E&gt; iterator();</div><div class="line">    //将列表转换成一个Object数组</div><div class="line">    Object[] toArray();</div><div class="line">    //将列表转换成任意类型的数组</div><div class="line">    &lt;T&gt; T[] toArray(T[] a);</div><div class="line">    //向列表中添加元素e</div><div class="line">    boolean add(E e);</div><div class="line">    //从列表中移除元素o</div><div class="line">    boolean remove(Object o);</div><div class="line">    //看列表中是否包含另一个集合的全部元素</div><div class="line">    boolean containsAll(Collection&lt;?&gt; c);</div><div class="line">    //将一个集合加入到列表中</div><div class="line">    boolean addAll(Collection&lt;? extends E&gt; c);</div><div class="line">    //将一个集合在指定位置加入到列表中</div><div class="line">    boolean addAll(int index, Collection&lt;? extends E&gt; c);</div><div class="line">    //将列表中属于另一个集合的元素都移除</div><div class="line">    boolean removeAll(Collection&lt;?&gt; c);</div><div class="line">    //移除所有不在另一个集合中的元素，取交集</div><div class="line">    boolean retainAll(Collection&lt;?&gt; c);</div><div class="line">    //对所有元素进行统一操作</div><div class="line">    default void replaceAll(UnaryOperator&lt;E&gt; operator) &#123;</div><div class="line">        Objects.requireNonNull(operator);</div><div class="line">        final ListIterator&lt;E&gt; li = this.listIterator();</div><div class="line">        while (li.hasNext()) &#123;</div><div class="line">            li.set(operator.apply(li.next()));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //根据给定的比较器对列表进行排序</div><div class="line">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</div><div class="line">    default void sort(Comparator&lt;? super E&gt; c) &#123;</div><div class="line">        Object[] a = this.toArray();</div><div class="line">        Arrays.sort(a, (Comparator) c);</div><div class="line">        ListIterator&lt;E&gt; i = this.listIterator();</div><div class="line">        for (Object e : a) &#123;</div><div class="line">            i.next();</div><div class="line">            i.set((E) e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //清空列表</div><div class="line">    void clear();</div><div class="line">    // 判断两个列表是否相等</div><div class="line">    boolean equals(Object o);</div><div class="line">    //返回列表的哈希值</div><div class="line">    int hashCode();</div><div class="line">    //获取index位置的元素</div><div class="line">    E get(int index);</div><div class="line">    //将index位置元素的值设定为element</div><div class="line">    E set(int index, E element);</div><div class="line">    //在指定位置添加元素</div><div class="line">    void add(int index, E element);</div><div class="line">    //移除index位置的元素</div><div class="line">    E remove(int index);</div><div class="line">    //元素o的最靠前的下标</div><div class="line">    int indexOf(Object o);</div><div class="line">    //元素o最靠后的下标</div><div class="line">    int lastIndexOf(Object o);</div><div class="line">    //返回迭代器列表</div><div class="line">    ListIterator&lt;E&gt; listIterator();</div><div class="line">    //返回指定位置之后的迭代器列表</div><div class="line">    ListIterator&lt;E&gt; listIterator(int index);</div><div class="line">    //返回字列表</div><div class="line">    List&lt;E&gt; subList(int fromIndex, int toIndex);</div><div class="line">    //返回并行迭代器列表</div><div class="line">    @Override</div><div class="line">    default Spliterator&lt;E&gt; spliterator() &#123;</div><div class="line">        return Spliterators.spliterator(this, Spliterator.ORDERED);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>RandomAccess接口：是一个空的接口，目的是为了标明实现该接口的List是否支持随机访问，支持的话访问会更加高效。Java中有很多空接口是为了起到标记的作用，看ArrayList源码时需要注意这一点的作用。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public interface RandomAccess &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Cloneable接口：目的是为了表明实现了该接口的对象可以调用clone方法来实现对象的复制，设计模式中原型模式就是用的这个特性，该特性jdk1.0就已经支持了，可以说很Java了。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public interface Cloneable &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Serializable接口：序列化接口是为了标记一个对象的状态是否能序列化到文件，提供了一种内存中对象的保存和加载机制，也是个标记接口。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public interface Serializable &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>可以看出，ArrayList除了三个标记接口外，最重要的还是List接口方法的实现。</p>
<h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//序列化接口的VersionID，序列化时记录到文件中，反序列化过程中进行版本校验。</div><div class="line">private static final long serialVersionUID = 8683452581122892189L;</div><div class="line"></div><div class="line">//ArrayList初始的列表大小</div><div class="line">private static final int DEFAULT_CAPACITY = 10;</div><div class="line"></div><div class="line">//共享的空数组</div><div class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"> //共享空数组，专门给默认大小使用的。</div><div class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"> //ArrayList数据保存的位置，不参与序列化</div><div class="line">transient Object[] elementData; // non-private to simplify nested class access</div><div class="line"></div><div class="line">//ArrayList中元素的个数</div><div class="line">private int size;</div></pre></td></tr></table></figure>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>总结来说，ArrayList的构造方法有啥三个，默认长度的，指定长度的，根据集合类生成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// 创建一个指定大小的ArrayList</div><div class="line">public ArrayList(int initialCapacity) &#123;</div><div class="line">    if (initialCapacity &gt; 0) &#123;</div><div class="line">        this.elementData = new Object[initialCapacity];</div><div class="line">    &#125; else if (initialCapacity == 0) &#123;</div><div class="line">        this.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125; else &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</div><div class="line">                                           initialCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 创建一个默认大小（10）的ArrayList</div><div class="line">public ArrayList() &#123;</div><div class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 根据给定的集合，创建包含该集合的所有元素的ArrayList</div><div class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</div><div class="line">    // 将给定集合元素存储到elementData数组中</div><div class="line">    elementData = c.toArray();</div><div class="line">    if ((size = elementData.length) != 0) &#123;</div><div class="line">        // 返回的不是Object数组时，进行数组复制操作</div><div class="line">        if (elementData.getClass() != Object[].class)</div><div class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 空数组时，为elementData赋值</div><div class="line">        this.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="trimToSize-方法"><a href="#trimToSize-方法" class="headerlink" title="trimToSize()方法"></a>trimToSize()方法</h1><p>该方法是将ArrayList的容量设置为当前size的大小。目的是为了缩减ArrayList的存储空间，ArrayList的容量为开辟的数组长度，size为存进去的元素个数。当我们只需要对ArrayList做查询操作，而不需要进行新增操作，则可以trim节省内存空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void trimToSize() &#123;</div><div class="line">    // 继承自AbstractList，防止多线程操作情况下，List发生结构性变化。</div><div class="line">    modCount++;</div><div class="line">    if (size &lt; elementData.length) &#123;</div><div class="line">        elementData = (size == 0)</div><div class="line">          ? EMPTY_ELEMENTDATA</div><div class="line">          : Arrays.copyOf(elementData, size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JDK源码里面三元表达式用的比较多，if判断用的比较少，以后需要多使用三元表达式，很简洁直观。</p>
<h1 id="size-方法"><a href="#size-方法" class="headerlink" title="size()方法"></a>size()方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 返回列表中的元素个数</div><div class="line">public int size() &#123;</div><div class="line">    return size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="isEmpty-方法"><a href="#isEmpty-方法" class="headerlink" title="isEmpty()方法"></a>isEmpty()方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 判断ArrayList是否为空</div><div class="line">public boolean isEmpty() &#123;</div><div class="line">    return size == 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="contains-Object-o-方法"><a href="#contains-Object-o-方法" class="headerlink" title="contains(Object o)方法"></a>contains(Object o)方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//调用indexof方法来判断一个对象是否在ArrayList中</div><div class="line">public boolean contains(Object o) &#123;</div><div class="line">    return indexOf(o) &gt;= 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="indexOf-Object-o-方法"><a href="#indexOf-Object-o-方法" class="headerlink" title="indexOf(Object o) 方法"></a>indexOf(Object o) 方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//判断一个元素是否在列表中，如果存在，返回第一个靠前位置的下标，如果不存在，返回-1。</div><div class="line">public int indexOf(Object o) &#123;</div><div class="line">    // 如果传入的对象为null,则看有没有对象为null在列表中</div><div class="line">    if (o == null) &#123;</div><div class="line">        for (int i = 0; i &lt; size; i++)</div><div class="line">            if (elementData[i]==null)</div><div class="line">                return i;</div><div class="line">    // 调用Object的equals方法来进行比较两个元素是否相等</div><div class="line">    &#125; else &#123;</div><div class="line">        for (int i = 0; i &lt; size; i++)</div><div class="line">            if (o.equals(elementData[i]))</div><div class="line">                return i;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="lastIndexOf-Object-o-方法"><a href="#lastIndexOf-Object-o-方法" class="headerlink" title="lastIndexOf(Object o) 方法"></a>lastIndexOf(Object o) 方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//找到一个元素在列表中最后一个出现的索引并返回，没找到返回-1，和indexOf方法，只是遍历数组时倒叙遍历而已，不赘述。</div><div class="line">public int lastIndexOf(Object o) &#123;</div><div class="line">    if (o == null) &#123;</div><div class="line">        for (int i = size-1; i &gt;= 0; i--)</div><div class="line">            if (elementData[i]==null)</div><div class="line">                return i;</div><div class="line">    &#125; else &#123;</div><div class="line">        for (int i = size-1; i &gt;= 0; i--)</div><div class="line">            if (o.equals(elementData[i]))</div><div class="line">                return i;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone()方法"></a>clone()方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// clone方法是Object类的方法，返回当前ArrayList的一个副本</div><div class="line">public Object clone() &#123;</div><div class="line">    try &#123;</div><div class="line">        // v为赋值的实例属性</div><div class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</div><div class="line">        //数据和modCount赋值</div><div class="line">        v.elementData = Arrays.copyOf(elementData, size);</div><div class="line">        v.modCount = 0;</div><div class="line">        return v;</div><div class="line">    &#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">        // this shouldn&apos;t happen, since we are Cloneable</div><div class="line">        throw new InternalError(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="toArray-方法"><a href="#toArray-方法" class="headerlink" title="toArray()方法"></a>toArray()方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//返回一个Object数组，直接调用Arrays中的copyof方法</div><div class="line">public Object[] toArray() &#123;</div><div class="line">    return Arrays.copyOf(elementData, size);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="toArray-T-a-方法"><a href="#toArray-T-a-方法" class="headerlink" title="toArray(T[] a)方法"></a>toArray(T[] a)方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 将ArrayList中的元素赋值到一个数组中去</div><div class="line">@SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</div><div class="line">    if (a.length &lt; size)</div><div class="line">        // 如果a的长度小于ArrayList的长度，返回一个包含ArrayList所有元素的数组</div><div class="line">        return (T[]) Arrays.copyOf(elementData, size, a.getClass());</div><div class="line">    // 将ArrayList额elementData数组复制到a数组，然后将a数组的size位置赋值为空。</div><div class="line">    System.arraycopy(elementData, 0, a, 0, size);</div><div class="line">    if (a.length &gt; size)</div><div class="line">        a[size] = null;</div><div class="line">    return a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="get-int-index-方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index)方法"></a>get(int index)方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 获取指定下标的元素并返回，可以看出get方法其实就是两个方法的封装</div><div class="line">public E get(int index) &#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    return elementData(index);</div><div class="line">&#125;</div><div class="line"></div><div class="line"> // 检查index是否超出了ArrayList的size。</div><div class="line">private void rangeCheck(int index) &#123;</div><div class="line">    if (index &gt;= size)</div><div class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 从elementData中返回index位置的元素。</div><div class="line">@SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">E elementData(int index) &#123;</div><div class="line">    return (E) elementData[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="set-int-index-E-element-方法"><a href="#set-int-index-E-element-方法" class="headerlink" title="set(int index, E element)方法"></a>set(int index, E element)方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 将指定index下的元素设置为element，并返回旧的值。</div><div class="line">public E set(int index, E element) &#123;</div><div class="line">    // index的范围检验</div><div class="line">    rangeCheck(index);</div><div class="line">    // 获取旧的值</div><div class="line">    E oldValue = elementData(index);</div><div class="line">    // 更新elementData中的值</div><div class="line">    elementData[index] = element;</div><div class="line">    return oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="add-E-e-方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e)方法"></a>add(E e)方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 将元素e添加到ArrayList的末尾</div><div class="line">public boolean add(E e) &#123;</div><div class="line">    // 校验size+1是否超过了ArrayList的大小</div><div class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div class="line">    // 在elementData中赋值</div><div class="line">    elementData[size++] = e;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>add之前，首先需要检查是否存在数组越界的问题，这个由ensureCapacityInternal来确保，如果发生了越界则进行扩容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">// 验证minCapacity是否需要扩容</div><div class="line">private void ensureCapacityInternal(int minCapacity) &#123;</div><div class="line">    // elementData为默认的空值时，也就是第一次插入元素，最小容量为两者的较大值</div><div class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line">    // 验证是否需要对elementData进行扩容</div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    // 需要进行扩容，调用grow方法进行扩容</div><div class="line">    if (minCapacity - elementData.length &gt; 0)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// elementData的最大值</div><div class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</div><div class="line"></div><div class="line">// 进行必要的扩容操作，确保elementData可以存放所有的元素</div><div class="line">private void grow(int minCapacity) &#123;</div><div class="line">    // overflow-conscious code</div><div class="line">    int oldCapacity = elementData.length;</div><div class="line">    // 新的容量为原来容量的1.5倍</div><div class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</div><div class="line">    // 不够的话，直接将需要的元素数设置为数组长度</div><div class="line">    if (newCapacity - minCapacity &lt; 0)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    // 将原来的数组元素复制到新的数组中</div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static int hugeCapacity(int minCapacity) &#123;</div><div class="line">    if (minCapacity &lt; 0) // overflow</div><div class="line">        throw new OutOfMemoryError();</div><div class="line">    return (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">        Integer.MAX_VALUE :</div><div class="line">        MAX_ARRAY_SIZE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="add-int-index-E-element-方法"><a href="#add-int-index-E-element-方法" class="headerlink" title="add(int index, E element)方法"></a>add(int index, E element)方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 在指定位置index处添加指定元素element</div><div class="line">public void add(int index, E element) &#123;</div><div class="line">    // 检查index是否小于elementData的长度</div><div class="line">    rangeCheckForAdd(index);</div><div class="line">    // 检查elementData中添加一个元素是否需要扩容</div><div class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div class="line">    // 将elementData数组index位置之后的元素向后移动，在index位置添加element，size++</div><div class="line">    System.arraycopy(elementData, index, elementData, index + 1,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="remove-int-index-方法"><a href="#remove-int-index-方法" class="headerlink" title="remove(int index)方法"></a>remove(int index)方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 移除指定index位置的元素并返回该元素</div><div class="line">public E remove(int index) &#123;</div><div class="line">    // 检查index是否小于elementData长度</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    // 旧值</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    int numMoved = size - index - 1;</div><div class="line">    if (numMoved &gt; 0)</div><div class="line">        // 将index位置的元素顺次向前移动一位</div><div class="line">        System.arraycopy(elementData, index+1, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = null; // clear to let GC do its work</div><div class="line">    // 返回旧值</div><div class="line">    return oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="remove-Object-o-方法"><a href="#remove-Object-o-方法" class="headerlink" title="remove(Object o)方法"></a>remove(Object o)方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// 从ArrayList中删除从0开始第一个遇到的o元素，成功返回true，失败返回false</div><div class="line">public boolean remove(Object o) &#123;</div><div class="line">    if (o == null) &#123;</div><div class="line">        for (int index = 0; index &lt; size; index++)</div><div class="line">            if (elementData[index] == null) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        for (int index = 0; index &lt; size; index++)</div><div class="line">            // 找到o的下标</div><div class="line">            if (o.equals(elementData[index])) &#123;</div><div class="line">                // 移除元素index</div><div class="line">                fastRemove(index);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 快速移除index下标处的元素</div><div class="line">private void fastRemove(int index) &#123;</div><div class="line">    modCount++;</div><div class="line">    int numMoved = size - index - 1;</div><div class="line">    if (numMoved &gt; 0)</div><div class="line">        // 将index位置的元素顺次向前移动一位</div><div class="line">        System.arraycopy(elementData, index+1, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = null; // clear to let GC do its work</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 从ArrayList中移除所有元素</div><div class="line">public void clear() &#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    // 将elementData中所有元素设置为空</div><div class="line">    for (int i = 0; i &lt; size; i++)</div><div class="line">        elementData[i] = null;</div><div class="line"></div><div class="line">    size = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="addAll-Collection-lt-extends-E-gt-c-方法"><a href="#addAll-Collection-lt-extends-E-gt-c-方法" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)方法"></a>addAll(Collection&lt;? extends E&gt; c)方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 将指定集合c中的所有元素都添加到列表尾部，成功返回true，失败返回false</div><div class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</div><div class="line">    // 将集合c转换成数组a存储</div><div class="line">    Object[] a = c.toArray();</div><div class="line">    int numNew = a.length;</div><div class="line">    // 扩容检查</div><div class="line">    ensureCapacityInternal(size + numNew);  // Increments modCount</div><div class="line">    // 将数组a添加到elementData数组之后</div><div class="line">    System.arraycopy(a, 0, elementData, size, numNew);</div><div class="line">    size += numNew;</div><div class="line">    return numNew != 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="addAll-int-index-Collection-lt-extends-E-gt-c-方法"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c-方法" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)方法"></a>addAll(int index, Collection&lt;? extends E&gt; c)方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 将指定集合c中的所有元素都添加到列表指定位置index只有，成功返回true，失败返回false</div><div class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</div><div class="line">    // index合法性检查</div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    Object[] a = c.toArray();</div><div class="line">    int numNew = a.length;</div><div class="line">    // 扩容检查</div><div class="line">    ensureCapacityInternal(size + numNew);  // Increments modCount</div><div class="line">    // 原数组需要移动的数量</div><div class="line">    int numMoved = size - index;</div><div class="line">    if (numMoved &gt; 0)</div><div class="line">        // 将原数组index位置之后的元素，后移newNum个位置</div><div class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</div><div class="line">                         numMoved);</div><div class="line">    // 将数组a复制到index位置之后的空间</div><div class="line">    System.arraycopy(a, 0, elementData, index, numNew);</div><div class="line">    // size更新</div><div class="line">    size += numNew;</div><div class="line">    return numNew != 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="removeAll-Collection-lt-gt-c"><a href="#removeAll-Collection-lt-gt-c" class="headerlink" title="removeAll(Collection&lt;?&gt; c)"></a>removeAll(Collection&lt;?&gt; c)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 从ArrayList中移除集合c中的所有元素</div><div class="line">public boolean removeAll(Collection&lt;?&gt; c) &#123;</div><div class="line">    Objects.requireNonNull(c);</div><div class="line">    return batchRemove(c, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;</div><div class="line">    final Object[] elementData = this.elementData;</div><div class="line">    int r = 0, w = 0;</div><div class="line">    boolean modified = false;</div><div class="line">    try &#123;</div><div class="line">        for (; r &lt; size; r++)</div><div class="line">            // 将ArrayList和c的交集元素保存或者丢弃，到局部变量elementData，最后一个下标为w</div><div class="line">            if (c.contains(elementData[r]) == complement)</div><div class="line">                elementData[w++] = elementData[r];</div><div class="line">    &#125; finally &#123;</div><div class="line">        // 出现异常，没有完全遍历完</div><div class="line">        if (r != size) &#123;</div><div class="line">            // 将r右边的元素直接复制到w右边</div><div class="line">            System.arraycopy(elementData, r,</div><div class="line">                             elementData, w,</div><div class="line">                             size - r);</div><div class="line">            w += size - r;</div><div class="line">        &#125;</div><div class="line">        if (w != size) &#123;</div><div class="line">            // 将w下标之后的元素设置为null</div><div class="line">            for (int i = w; i &lt; size; i++)</div><div class="line">                elementData[i] = null;</div><div class="line">            modCount += size - w;</div><div class="line">            size = w;</div><div class="line">            modified = true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return modified;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="retainAll-Collection-lt-gt-c-方法"><a href="#retainAll-Collection-lt-gt-c-方法" class="headerlink" title="retainAll(Collection&lt;?&gt; c) 方法"></a>retainAll(Collection&lt;?&gt; c) 方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 取并集</div><div class="line">public boolean retainAll(Collection&lt;?&gt; c) &#123;</div><div class="line">    // 非空检查</div><div class="line">    Objects.requireNonNull(c);</div><div class="line">    // 返回差集</div><div class="line">    return batchRemove(c, true);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">// 序列化方法，将列表状态写入数据流中</div><div class="line">private void writeObject(java.io.ObjectOutputStream s)</div><div class="line">    throws java.io.IOException&#123;</div><div class="line">    // Write out element count, and any hidden stuff</div><div class="line">    int expectedModCount = modCount;</div><div class="line">    s.defaultWriteObject();</div><div class="line"></div><div class="line">    // Write out size as capacity for behavioural compatibility with clone()</div><div class="line">    s.writeInt(size);</div><div class="line"></div><div class="line">    // Write out all elements in the proper order.</div><div class="line">    for (int i=0; i&lt;size; i++) &#123;</div><div class="line">        s.writeObject(elementData[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (modCount != expectedModCount) &#123;</div><div class="line">        throw new ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 反序列化方法</div><div class="line">private void readObject(java.io.ObjectInputStream s)</div><div class="line">    throws java.io.IOException, ClassNotFoundException &#123;</div><div class="line">    elementData = EMPTY_ELEMENTDATA;</div><div class="line"></div><div class="line">    // Read in size, and any hidden stuff</div><div class="line">    s.defaultReadObject();</div><div class="line"></div><div class="line">    // Read in capacity</div><div class="line">    s.readInt(); // ignored</div><div class="line"></div><div class="line">    if (size &gt; 0) &#123;</div><div class="line">        // be like clone(), allocate array based upon size not capacity</div><div class="line">        ensureCapacityInternal(size);</div><div class="line"></div><div class="line">        Object[] a = elementData;</div><div class="line">        // Read in all elements in the proper order.</div><div class="line">        for (int i=0; i&lt;size; i++) &#123;</div><div class="line">            a[i] = s.readObject();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="listIterator-int-index-方法"><a href="#listIterator-int-index-方法" class="headerlink" title="listIterator(int index)方法"></a>listIterator(int index)方法</h1><p>这部分内容没有仔细去看，暂不注解，后面会进行完善。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line">// 获取列表指定位置的迭代器对象</div><div class="line">public ListIterator&lt;E&gt; listIterator(int index) &#123;</div><div class="line">    if (index &lt; 0 || index &gt; size)</div><div class="line">        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);</div><div class="line">    return new ListItr(index);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取list开头的迭代器对象</div><div class="line">public ListIterator&lt;E&gt; listIterator() &#123;</div><div class="line">    return new ListItr(0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Itr 内部类</div><div class="line">private class Itr implements Iterator&lt;E&gt; &#123;</div><div class="line">    int cursor;       // index of next element to return</div><div class="line">    int lastRet = -1; // index of last element returned; -1 if no such</div><div class="line">    int expectedModCount = modCount;</div><div class="line"></div><div class="line">    public boolean hasNext() &#123;</div><div class="line">        return cursor != size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    public E next() &#123;</div><div class="line">        checkForComodification();</div><div class="line">        int i = cursor;</div><div class="line">        if (i &gt;= size)</div><div class="line">            throw new NoSuchElementException();</div><div class="line">        Object[] elementData = ArrayList.this.elementData;</div><div class="line">        if (i &gt;= elementData.length)</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">        cursor = i + 1;</div><div class="line">        return (E) elementData[lastRet = i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void remove() &#123;</div><div class="line">        if (lastRet &lt; 0)</div><div class="line">            throw new IllegalStateException();</div><div class="line">        checkForComodification();</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            ArrayList.this.remove(lastRet);</div><div class="line">            cursor = lastRet;</div><div class="line">            lastRet = -1;</div><div class="line">            expectedModCount = modCount;</div><div class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;</div><div class="line">        Objects.requireNonNull(consumer);</div><div class="line">        final int size = ArrayList.this.size;</div><div class="line">        int i = cursor;</div><div class="line">        if (i &gt;= size) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        final Object[] elementData = ArrayList.this.elementData;</div><div class="line">        if (i &gt;= elementData.length) &#123;</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">        while (i != size &amp;&amp; modCount == expectedModCount) &#123;</div><div class="line">            consumer.accept((E) elementData[i++]);</div><div class="line">        &#125;</div><div class="line">        // update once at end of iteration to reduce heap write traffic</div><div class="line">        cursor = i;</div><div class="line">        lastRet = i - 1;</div><div class="line">        checkForComodification();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    final void checkForComodification() &#123;</div><div class="line">        if (modCount != expectedModCount)</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ListItr内部类</div><div class="line">private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123;</div><div class="line">    // 构造方法</div><div class="line">    ListItr(int index) &#123;</div><div class="line">        super();</div><div class="line">        cursor = index;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 是否有上一个迭代对象</div><div class="line">    public boolean hasPrevious() &#123;</div><div class="line">        return cursor != 0;</div><div class="line">    &#125;</div><div class="line">    // 获取当前迭代对象的下标</div><div class="line">    public int nextIndex() &#123;</div><div class="line">        return cursor;</div><div class="line">    &#125;</div><div class="line">    // 获取上一个迭代对象的下标</div><div class="line">    public int previousIndex() &#123;</div><div class="line">        return cursor - 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    public E previous() &#123;</div><div class="line">        checkForComodification();</div><div class="line">        int i = cursor - 1;</div><div class="line">        if (i &lt; 0)</div><div class="line">            throw new NoSuchElementException();</div><div class="line">        Object[] elementData = ArrayList.this.elementData;</div><div class="line">        if (i &gt;= elementData.length)</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">        cursor = i;</div><div class="line">        return (E) elementData[lastRet = i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void set(E e) &#123;</div><div class="line">        if (lastRet &lt; 0)</div><div class="line">            throw new IllegalStateException();</div><div class="line">        checkForComodification();</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            ArrayList.this.set(lastRet, e);</div><div class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void add(E e) &#123;</div><div class="line">        checkForComodification();</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            int i = cursor;</div><div class="line">            ArrayList.this.add(i, e);</div><div class="line">            cursor = i + 1;</div><div class="line">            lastRet = -1;</div><div class="line">            expectedModCount = modCount;</div><div class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="subList-int-fromIndex-int-toIndex-方法"><a href="#subList-int-fromIndex-int-toIndex-方法" class="headerlink" title="subList(int fromIndex, int toIndex)方法"></a>subList(int fromIndex, int toIndex)方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">// 从列表中取出指定位置的子列表</div><div class="line">public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</div><div class="line">    // 起点和终点的下标检查</div><div class="line">    subListRangeCheck(fromIndex, toIndex, size);</div><div class="line">    // 调用SubList内部类来实现字列表的实现</div><div class="line">    return new SubList(this, 0, fromIndex, toIndex);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 起点和终点的下标检查</div><div class="line">static void subListRangeCheck(int fromIndex, int toIndex, int size) &#123;</div><div class="line">    if (fromIndex &lt; 0)</div><div class="line">        throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex);</div><div class="line">    if (toIndex &gt; size)</div><div class="line">        throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex);</div><div class="line">    if (fromIndex &gt; toIndex)</div><div class="line">        throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +</div><div class="line">                                           &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// SubList内部类，对ArrayList数组直接进行增删改查，只是为其限定了边界</div><div class="line">private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123;</div><div class="line">    private final AbstractList&lt;E&gt; parent;</div><div class="line">    private final int parentOffset;</div><div class="line">    private final int offset;</div><div class="line">    int size;</div><div class="line">    // 构造方法，父列表，偏移量，fromIndex，toIndex</div><div class="line">    SubList(AbstractList&lt;E&gt; parent,</div><div class="line">            int offset, int fromIndex, int toIndex) &#123;</div><div class="line">        this.parent = parent;</div><div class="line">        this.parentOffset = fromIndex;</div><div class="line">        this.offset = offset + fromIndex;</div><div class="line">        this.size = toIndex - fromIndex;</div><div class="line">        this.modCount = ArrayList.this.modCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public E set(int index, E e) &#123;</div><div class="line">        rangeCheck(index);</div><div class="line">        checkForComodification();</div><div class="line">        E oldValue = ArrayList.this.elementData(offset + index);</div><div class="line">        ArrayList.this.elementData[offset + index] = e;</div><div class="line">        return oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public E get(int index) &#123;</div><div class="line">        rangeCheck(index);</div><div class="line">        checkForComodification();</div><div class="line">        return ArrayList.this.elementData(offset + index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int size() &#123;</div><div class="line">        checkForComodification();</div><div class="line">        return this.size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void add(int index, E e) &#123;</div><div class="line">        rangeCheckForAdd(index);</div><div class="line">        checkForComodification();</div><div class="line">        parent.add(parentOffset + index, e);</div><div class="line">        this.modCount = parent.modCount;</div><div class="line">        this.size++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public E remove(int index) &#123;</div><div class="line">        rangeCheck(index);</div><div class="line">        checkForComodification();</div><div class="line">        E result = parent.remove(parentOffset + index);</div><div class="line">        this.modCount = parent.modCount;</div><div class="line">        this.size--;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void removeRange(int fromIndex, int toIndex) &#123;</div><div class="line">        checkForComodification();</div><div class="line">        parent.removeRange(parentOffset + fromIndex,</div><div class="line">                           parentOffset + toIndex);</div><div class="line">        this.modCount = parent.modCount;</div><div class="line">        this.size -= toIndex - fromIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</div><div class="line">        return addAll(this.size, c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</div><div class="line">        rangeCheckForAdd(index);</div><div class="line">        int cSize = c.size();</div><div class="line">        if (cSize==0)</div><div class="line">            return false;</div><div class="line"></div><div class="line">        checkForComodification();</div><div class="line">        parent.addAll(parentOffset + index, c);</div><div class="line">        this.modCount = parent.modCount;</div><div class="line">        this.size += cSize;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="forEach-Consumer-lt-super-E-gt-action-方法"><a href="#forEach-Consumer-lt-super-E-gt-action-方法" class="headerlink" title="forEach(Consumer&lt;? super E&gt; action)方法"></a>forEach(Consumer&lt;? super E&gt; action)方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Collection方法中的增强型for循环</div><div class="line">@Override</div><div class="line">public void forEach(Consumer&lt;? super E&gt; action) &#123;</div><div class="line">    Objects.requireNonNull(action);</div><div class="line">    final int expectedModCount = modCount;</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    final E[] elementData = (E[]) this.elementData;</div><div class="line">    final int size = this.size;</div><div class="line">    for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</div><div class="line">        action.accept(elementData[i]);</div><div class="line">    &#125;</div><div class="line">    if (modCount != expectedModCount) &#123;</div><div class="line">        throw new ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Sort方法"><a href="#Sort方法" class="headerlink" title="Sort方法"></a>Sort方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 传入比较器，对ArrayList进行排序</div><div class="line">@Override</div><div class="line">@SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">public void sort(Comparator&lt;? super E&gt; c) &#123;</div><div class="line">    final int expectedModCount = modCount;</div><div class="line">    Arrays.sort((E[]) elementData, 0, size, c);</div><div class="line">    if (modCount != expectedModCount) &#123;</div><div class="line">        throw new ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/18/一致性哈希算法及其Java实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/一致性哈希算法及其Java实现/" itemprop="url">一致性哈希及其Java实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T20:22:17+08:00">
                2018-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Consistent-Hash/" itemprop="url" rel="index">
                    <span itemprop="name">Consistent Hash</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一致性哈希概念"><a href="#一致性哈希概念" class="headerlink" title="一致性哈希概念"></a>一致性哈希概念</h1><ul>
<li>维基百科的定义</li>
</ul>
<p>一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对K/n 个关键字重新映射，其中K是关键字的数量，n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p>
<p>一致性哈希算法提出了动态变化的Cache环境中，判定哈希算法好坏的四个定义：</p>
<ol>
<li>平衡性：哈希的结果尽可能分布到所有的缓存中，充分利用缓存空间。</li>
<li>单调性：举例说吧，本来有ABC三个缓存，数据1存储在B中，现在添加了D缓存进去，则数据1只会分布在B或者D中，不会分配到AC中。</li>
<li>分散性：分散性是同一个数据被映射到不同的缓存中，需要避免</li>
<li>负载：一个缓冲区被多个用户映射为不同的内容，需要降低缓冲的负载。</li>
</ol>
<h1 id="传统哈希算法"><a href="#传统哈希算法" class="headerlink" title="传统哈希算法"></a>传统哈希算法</h1><p>针对分布式场景，假定有1000W个数据项，100个存储接待你，一个数据的存储位置为该数据的Hash值对服务器数量取余，这样可以将数据尽可能的分散到各个服务器上。</p>
<p>  <img src="/img/cons-Hash-1.png" alt="Alt text"></p>
<p>这种哈希方案的优点是每个节点的的数据量是相仿的，相对均衡，但是当在集群里面增加一台服务器，或者减少一台服务器的话，几乎所有的缓存都会失效，需要重新哈希。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/18\</div><div class="line"> * 传统哈希方法</div><div class="line"> * 100000000个数据项，100个存储节点</div><div class="line"> */</div><div class="line">public class NormalHashMethod &#123;</div><div class="line">    //数据数</div><div class="line">    public static final int NUMBER_OF_DATA = 10000000;</div><div class="line">    //节点数</div><div class="line">    public static final int NUMBER_OF_NODE = 100;</div><div class="line">    //节点中存放的数据个数</div><div class="line">    private static int[] record = new int[NUMBER_OF_NODE];</div><div class="line"></div><div class="line">    //将节点放入对应的服务器中</div><div class="line">    public static void hashProcess() &#123;</div><div class="line">        for (int i = 0; i &lt; NUMBER_OF_DATA; i++) &#123;</div><div class="line">            int result = getHash(i+&quot;&quot;);</div><div class="line">            record[result%100]++;</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;平均节点中的数据量： &quot; + NUMBER_OF_DATA/NUMBER_OF_NODE);</div><div class="line">        System.out.println(&quot;最多的一个节点的数量： &quot; + getMax(record));</div><div class="line">        System.out.println(&quot;最少的一个节点的数量： &quot; + getMin(record));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //添加一个节点或者减少一个节点时，需要移动的节点数</div><div class="line">    public static void afterAddOrDeleteOneNode() &#123;</div><div class="line">        int count = 0;</div><div class="line">        int count1 = 0;</div><div class="line">        //对所有数据进行hash，对新的服务器数量取余</div><div class="line">        for (int i = 0; i &lt; NUMBER_OF_DATA; i++) &#123;</div><div class="line">            int result = getHash(i+&quot;&quot;);</div><div class="line">            if (result % NUMBER_OF_NODE != result % (NUMBER_OF_NODE + 1))</div><div class="line">                count++;</div><div class="line">            if (result % NUMBER_OF_NODE != result % (NUMBER_OF_NODE - 1))</div><div class="line">                count1++;</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;添加一个节点数据移动的数量： &quot; + count);</div><div class="line">        System.out.println(&quot;减少一个节点数据移动的数量： &quot; + count1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //使用FNV1_32_HASH算法</div><div class="line">    private static int getHash(String str) &#123;</div><div class="line">        final int p = 16777619;</div><div class="line">        int hash = (int) 2166136261L;</div><div class="line">        for (int i = 0; i &lt; str.length(); i++)</div><div class="line">            hash = (hash ^ str.charAt(i)) * p;</div><div class="line">        hash += hash &lt;&lt; 13;</div><div class="line">        hash ^= hash &gt;&gt; 7;</div><div class="line">        hash += hash &lt;&lt; 3;</div><div class="line">        hash ^= hash &gt;&gt; 17;</div><div class="line">        hash += hash &lt;&lt; 5;</div><div class="line"></div><div class="line">        // 如果算出来的值为负数则取其绝对值</div><div class="line">        if (hash &lt; 0)</div><div class="line">            hash = Math.abs(hash);</div><div class="line">        return hash;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static int getMax(int[] arr) &#123;</div><div class="line">        int max = arr[0];</div><div class="line">        for (int x = 1; x &lt; arr.length; x++) &#123;</div><div class="line">            if (arr[x] &gt; max)</div><div class="line">                max = arr[x];</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return max;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static int getMin(int[] arr) &#123;</div><div class="line">        int min = arr[0];</div><div class="line">        for (int x = 1; x &lt; arr.length; x++) &#123;</div><div class="line">            if (arr[x] &lt; min)</div><div class="line">                min = arr[x];</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return min;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        hashProcess();</div><div class="line">        afterAddOrDeleteOneNode();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子中是用普通哈希方法来做的，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">平均节点中的数据量： 100000</div><div class="line">最多的一个节点的数量： 100653</div><div class="line">最少的一个节点的数量： 99160</div><div class="line">添加一个节点数据移动的数量： 9900492</div><div class="line">减少一个节点数据移动的数量： 9899656</div></pre></td></tr></table></figure>
<p>可以看出，一共1000万个数据，添加或者减少一个节点，进行重新哈希，则990万个数据需要改变存储位置。也就是说990万个缓存不能命中，实际场景中这明显是不能接受的，因此提出了一致性哈希来解决这个问题。</p>
<h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>唤醒hash空间：按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，也就是0-2^32-1的数字空间中，将其收尾相连，形成一个环空间。</li>
</ul>
<p>Hash(object1) = key1；<br>Hash(object2) = key2；<br>Hash(object3) = key3；<br>Hash(object4) = key4；</p>
<p>  <img src="/img/cons-Hash-2.png" alt="Alt text"></p>
<ul>
<li><p>将数据通过一定的哈希算法处理后映射到环上</p>
<p><img src="/img/cons-Hash-3.png" alt="Alt text"></p>
</li>
<li><p>将服务器通过哈希算法映射到环上,和数据的哈希算法是一样的，环上的数据，顺时针遇到的第一个服务器就是该数据的存储位置。假定有三个服务器节点。</p>
</li>
</ul>
<p>Hash(NODE1) = KEY1;<br>Hash(NODE2) = KEY2;<br>Hash(NODE3) = KEY3;</p>
<p>  <img src="/img/cons-Hash-4.png" alt="Alt text"></p>
<p>由于哈希环是不会变更的，因此一个数据可以快速的知道他的真正的存储位置。</p>
<h2 id="服务器的删除与添加"><a href="#服务器的删除与添加" class="headerlink" title="服务器的删除与添加"></a>服务器的删除与添加</h2><p>不同于传统哈希求余方法，一致性哈希算法在增加或者删除服务器节点是，需要换位置的节点很少，性能很高。</p>
<ol>
<li><p>删除服务器节点,如果NODE2出现故障，则从集群里面溢出，那么object3会迁移到Node3中，其他数据的位置不变。</p>
<p><img src="/img/cons-Hash-5.png" alt="Alt text"></p>
</li>
<li><p>添加服务器节点，向集群里面添加新的 首先将其映射到环中，通过顺时针迁移的规则，object2会迁移到NODE4中，其他对象不会发生改变。数据迁移的数量很小，很适合分布式集群。</p>
<p><img src="/img/cons-Hash-6.png" alt="Alt text"></p>
</li>
<li><p>java示范</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">import java.util.Objects;</div><div class="line">import java.util.SortedMap;</div><div class="line">import java.util.TreeMap;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/18\</div><div class="line"> * 一致性哈希方法</div><div class="line"> * 100000000个数据项，100个存储节点</div><div class="line"> */</div><div class="line">public class ConsistentHashMethod &#123;</div><div class="line">    public static final int NUMBER_OF_DATA = 10000000;</div><div class="line">    public static final int NUMBER_OF_NODE = 100;</div><div class="line">    //记录服务器要添加的环上的位置，默认为均匀分布的</div><div class="line">    private static int[] servers = new int[NUMBER_OF_NODE];</div><div class="line">    //key-服务器的哈希值，value表示服务器的位置</div><div class="line">    private static SortedMap&lt;Integer, Integer&gt; sortedMap = new TreeMap&lt;&gt;();</div><div class="line">    //记录每个服务器节点放置的数据数</div><div class="line">    private static int[] record = new int[NUMBER_OF_NODE];</div><div class="line"></div><div class="line">    //初始化，将服务器放入环中</div><div class="line">    public static void init() &#123;</div><div class="line">        int div = (Integer.MAX_VALUE) / NUMBER_OF_NODE;</div><div class="line">        for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">            servers[i] = i * div;</div><div class="line">        &#125;</div><div class="line">        //将所有服务器放入SortedMap中</div><div class="line">        for (int i = 0; i &lt; servers.length; i++) &#123;</div><div class="line">            int hash = getHash(servers[i] + &quot;&quot;);</div><div class="line">            sortedMap.put(hash, servers[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void hashProcess() &#123;</div><div class="line">        int div = 21474836;</div><div class="line">        for (int i = 0; i &lt; NUMBER_OF_DATA; i++) &#123;</div><div class="line">            int hash = getHash(i+&quot;&quot;);</div><div class="line">            //得到大于该Hash值的所有Map</div><div class="line">            SortedMap&lt;Integer, Integer&gt; subMap = sortedMap.tailMap(hash);</div><div class="line">            //将节点放入对应的服务器中</div><div class="line">            if (subMap.isEmpty()) &#123;</div><div class="line">                Integer index = sortedMap.firstKey();</div><div class="line">                record[sortedMap.get(index) / div]++;</div><div class="line">            &#125; else &#123;</div><div class="line">                Integer index = subMap.firstKey();</div><div class="line">                record[sortedMap.get(index)/div]++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;平均节点中的数据量： &quot; + NUMBER_OF_DATA/NUMBER_OF_NODE);</div><div class="line">        System.out.println(&quot;最多的一个节点的数量： &quot; + getMax(record));</div><div class="line">        System.out.println(&quot;最少的一个节点的数量： &quot; + getMin(record));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void afterAddOneNode() &#123;</div><div class="line">        int count = 0;</div><div class="line">        int div1 = (Integer.MAX_VALUE) / NUMBER_OF_NODE;</div><div class="line">        SortedMap&lt;Integer, Integer&gt; addNode = new TreeMap&lt;&gt;(sortedMap);</div><div class="line">        addNode.put(getHash(&quot;2333&quot;), 2333);</div><div class="line">        for (int i = 0; i &lt; NUMBER_OF_DATA; i++) &#123;</div><div class="line">            int hash = getHash(i + &quot;&quot;);</div><div class="line">            SortedMap&lt;Integer, Integer&gt; sub = sortedMap.tailMap(hash);</div><div class="line">            SortedMap&lt;Integer, Integer&gt; sub1 = addNode.tailMap(hash);</div><div class="line">            if (sub.isEmpty() &amp;&amp; sub1.isEmpty() ) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            if (!sub.isEmpty() &amp;&amp; !sub1.isEmpty() &amp;&amp; !Objects.equals(sub.firstKey(), sub1.firstKey())) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;添加一个节点数据移动的数量： &quot; + count);</div><div class="line">    &#125;</div><div class="line">    //使用FNV1_32_HASH算法</div><div class="line">    private static int getHash(String str) &#123;</div><div class="line">        final int p = 16777619;</div><div class="line">        int hash = (int) 2166136261L;</div><div class="line">        for (int i = 0; i &lt; str.length(); i++)</div><div class="line">            hash = (hash ^ str.charAt(i)) * p;</div><div class="line">        hash += hash &lt;&lt; 13;</div><div class="line">        hash ^= hash &gt;&gt; 7;</div><div class="line">        hash += hash &lt;&lt; 3;</div><div class="line">        hash ^= hash &gt;&gt; 17;</div><div class="line">        hash += hash &lt;&lt; 5;</div><div class="line"></div><div class="line">        // 如果算出来的值为负数则取其绝对值</div><div class="line">        if (hash &lt; 0)</div><div class="line">            hash = Math.abs(hash);</div><div class="line">        return hash;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static int getMax(int[] arr) &#123;</div><div class="line">        int max = arr[0];</div><div class="line">        for (int x = 1; x &lt; arr.length; x++) &#123;</div><div class="line">            if (arr[x] &gt; max)</div><div class="line">                max = arr[x];</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return max;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static int getMin(int[] arr) &#123;</div><div class="line">        int min = arr[0];</div><div class="line">        for (int x = 1; x &lt; arr.length; x++) &#123;</div><div class="line">            if (arr[x] &lt; min)</div><div class="line">                min = arr[x];</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return min;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        init();</div><div class="line">        hashProcess();</div><div class="line">        afterAddOneNode();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">平均节点中的数据量： 100000</div><div class="line">最多的一个节点的数量： 479784</div><div class="line">最少的一个节点的数量： 1367</div><div class="line">添加一个节点数据移动的数量： 138303</div></pre></td></tr></table></figure>
<p>可以看出添加一个节点之后，要修改的数据只有十万个，效率很高。</p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>上面可以明确看出，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，平衡性的体现通过虚拟节点来实现。哈希算法是不保证平衡的，如值部署了NODE1和NODE3的情况，object1存储到NODE1中，其他的都存到NODE3中，这样就非常不平衡了。因此引入了虚拟节点。</p>
<ul>
<li><p>虚拟节点：实际上是及其在哈希空间中的复制品，一个实际的节点对应了若干个虚拟节点，这样对应个数也成为复制个数，虚拟节点在哈希空间中以哈希值排列。新建两个复制节点之后可以看到节点分配变得很均衡。</p>
<p><img src="/img/cons-Hash-7.png" alt="Alt text"></p>
</li>
</ul>
<p>其中涉及了哈希虚拟节点到实际节点的转换，其实只是一个简单的映射：</p>
<p>  <img src="/img/cons-Hash-8.png" alt="Alt text"></p>
<p>而在实际的场景中，可以通过对真实节点进行编号来生成相应的虚拟节点。如真实节点的IP为192.168.10.11，则虚拟节点可以设置为192.168.10.11#1,192.168.10.11#2。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/18/ActiveMQ学习总结（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/ActiveMQ学习总结（三）/" itemprop="url">ActiveMQ学习总结（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T14:49:20+08:00">
                2018-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JMS/" itemprop="url" rel="index">
                    <span itemprop="name">JMS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JMS/ActiveMQ/" itemprop="url" rel="index">
                    <span itemprop="name">ActiveMQ</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>总结一下消息队列面试过程中遇到的问题，各个互联网公司对于消息队列还是很感兴趣的，问的问题很多，深度也够，一遍面试一边学习的效率其实很高，希望可以通过整理更加了解ActiveMQ这个消息队列，后续计划对RocketMQ，RabbitMQ，kafka学习一下。</p>
<h1 id="ActiveMQ的存储机制"><a href="#ActiveMQ的存储机制" class="headerlink" title="ActiveMQ的存储机制"></a>ActiveMQ的存储机制</h1><ol>
<li>通常情况下，非持久化消息时存储在内存中的，持久化消息时存储在日志文件中的，最大限制可以配置。</li>
<li>内存中的非持久化消息堆积到一定程度会影响内存的空间，此时ActiveMQ会将内存中的非持久化消息写入临时文件中，以释放内存。重启后非持久化的临时文件会直接删除。</li>
</ol>
<h1 id="ActiveMQ挂掉怎么办"><a href="#ActiveMQ挂掉怎么办" class="headerlink" title="ActiveMQ挂掉怎么办"></a>ActiveMQ挂掉怎么办</h1><ul>
<li><p>ActiveMQ采用持久化方案的时候，当日志文件达到最大限制时会造成生产者阻塞，此时生产者不可以再生产新的服务，但是消费者可以正常连接并消费消息，当消费掉一部分消息之后，文件删除之后生产者可以继续生产消息，服务会自动回复正常运行。</p>
</li>
<li><p>ActiveMQ采用非持久化方案的时候，当临时文件大小达到上限时会产生生产者阻塞，消费者可以正常连接却不能正常消费消息，整个系统可连接，但是无法提供服务，ActiveMQ挂掉。</p>
</li>
<li><p>解决方案：尽量不要用非持久化消息，如果要用的话，需要将临时文件限制尽可能调大。</p>
</li>
</ul>
<h1 id="为什么选择ActiveMQ？"><a href="#为什么选择ActiveMQ？" class="headerlink" title="为什么选择ActiveMQ？"></a>为什么选择ActiveMQ？</h1><ul>
<li>降低分布式系统之间的耦合度</li>
<li>产品很成熟，在很多公司得到了应用</li>
<li>文档众多，协议支持的很好，有封装好的Java客户端</li>
<li>ActiveMQ性能不如RabbitMQ，kafka等，后期计划更新消息队列。</li>
</ul>
<h1 id="ActiveMQ丢失消息怎么处理？"><a href="#ActiveMQ丢失消息怎么处理？" class="headerlink" title="ActiveMQ丢失消息怎么处理？"></a>ActiveMQ丢失消息怎么处理？</h1><ul>
<li>ActiveMQ每隔10s会发送一个心跳包，用来检测客户端是否存活。而如果采用非持久化方案的消息队列，消息堆积之后会触发一次写过程，这个过程会阻塞所有的活动，持续20-30s，并且会随着内存增大而增加。</li>
<li>此时客户端发完消息会关闭连接，发送的消息存在服务端的缓存里面，服务器直接读取缓存时不会造成消息丢失的，但是由于心跳包的存在，发生了SocketException异常，缓存区数据失效，从而造成消息丢失。</li>
<li>解决方案：使用持久化消息，或者非持久化消息及时处理不要堆积，或者启动事务，启动事务之后，commit方法会负责等待服务器的返回，不会关闭连接导致消息丢失。</li>
</ul>
<h1 id="消息的不均匀消费问题？"><a href="#消息的不均匀消费问题？" class="headerlink" title="消息的不均匀消费问题？"></a>消息的不均匀消费问题？</h1><ul>
<li>ActiveMQ的prefetch机制，消费者去获取消息时，会一次获取一批，默认1000。这些消息在没被消费之前，管理控制台可以看见这些消息，但是无法将其分配给其他消费者。消费成功，在服务器端删除对应消息，消费失败，退回服务端重新分配。</li>
<li>解决方案，将prefetch设置为1</li>
</ul>
<h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><ul>
<li><p>由于AUTO_ACKNOWLWDGE只是确保消费者收到消息，不保证消息能够正确执行。因此实际中一般采用CLIEND_ACKNOWLEDGE，自己去处理什么时候返回确认信息。</p>
</li>
<li><p>使用了AUTO_ACKNOWLWDGE时，如果消费消息采用的是consumer.receive()方法，则直接确认。但是如果采用Listener回调函数，则消息到达会执行Listener接口的onMessage方法。这种情况下，只有执行完onMessage方法才会确认消息。此时如果报错，消息不会被删除，而是退回服务器。重试6次之后，会进入死信队列。</p>
</li>
</ul>
<h1 id="ActiveMQ中的消息重发时间间隔和重发次数"><a href="#ActiveMQ中的消息重发时间间隔和重发次数" class="headerlink" title="ActiveMQ中的消息重发时间间隔和重发次数"></a>ActiveMQ中的消息重发时间间隔和重发次数</h1><ul>
<li>消息接受者在处理完一条消息的处理过程后没有对MOM进行应答，则该消息由MOM重发。</li>
<li>如果某个队列设置了预读参数，如果消息接受者在处理第一条消息时就宕机了，则预读数量的所有消息都会被重发。</li>
<li>如果session是事务的，只要消息接受者有一条消息没有确认，或者发送期间MOM或者客户端宕机，则该事务范围中的所有消息都将重发。</li>
<li>重发侧率可以自定义配置，比如配置最大重传数量，默认为6，最大传送延迟等。。。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/17/ActiveMQ学习总结（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/ActiveMQ学习总结（二）/" itemprop="url">ActiveMQ学习总结（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-17T21:57:07+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JMS/" itemprop="url" rel="index">
                    <span itemprop="name">JMS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JMS/ActiveMQ/" itemprop="url" rel="index">
                    <span itemprop="name">ActiveMQ</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一节总结了ActiveMQ的使用，主要的还是总结了在项目中直接使用和用Spring集成使用。这一节要进一步深入ActiveMQ，学习其内部的原理性的东西。</p>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>ActiveMQ消息的发送和接收到离不开Session的建立，首先查看Session的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public interface Session extends Runnable &#123;</div><div class="line">    int AUTO_ACKNOWLEDGE = 1;</div><div class="line">    int CLIENT_ACKNOWLEDGE = 2;</div><div class="line">    int DUPS_OK_ACKNOWLEDGE = 3;</div><div class="line">    int SESSION_TRANSACTED = 0;</div><div class="line"></div><div class="line">    BytesMessage createBytesMessage() throws JMSException;</div><div class="line">    //omit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而ActiveMQ的Session的创建需要通过Connection的createSession方法,该方法需要设置两个参数，第一个参数表示是否支持事务，第二个参数表示签收模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Connection &#123;</div><div class="line">    Session createSession(boolean var1, int var2) throws JMSException;</div><div class="line">    //omit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所谓的签收模式也就是消费者在收到消息之后，需要通知消息服务器收到了消息。当消息服务器收到回执之后，本条消息将失效。而如果消费者收到了消息却并不签收，则本条消息继续有效，可能会被其他消费者消费。</p>
<ul>
<li>AUTO_ACKNOWLEDGE ：表示消费者接收到消息时自动签收</li>
<li>CLIENT_ACKNOWLEDGE ：消费者接收消息之后需要手动签收</li>
<li>DUPS_OK_ACKNOWLEDGE ：签收不签收都可以，要求消费者可以容忍重复消费。</li>
</ul>
<p>实际中更加推荐采用手动签收，理论上说，消费者收到消息不代表消息传递的结束，只有当消费者正确处理了消息才是整个消息传递流程的终点。因此如果自动签却没有成功处理收会导致消息丢失。</p>
<h1 id="消息顺序消费"><a href="#消息顺序消费" class="headerlink" title="消息顺序消费"></a>消息顺序消费</h1><h2 id="消息优先级"><a href="#消息优先级" class="headerlink" title="消息优先级"></a>消息优先级</h2><p>MessageProvider的send方法存在多个重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// Source code recreated from a .class file by IntelliJ IDEA</div><div class="line">// (powered by Fernflower decompiler)</div><div class="line">//</div><div class="line"></div><div class="line">package javax.jms;</div><div class="line"></div><div class="line">public interface MessageProducer &#123;</div><div class="line">    //omit above</div><div class="line">    void send(Message var1) throws JMSException;</div><div class="line"></div><div class="line">    void send(Message var1, int var2, int var3, long var4) throws JMSException;</div><div class="line"></div><div class="line">    void send(Destination var1, Message var2) throws JMSException;</div><div class="line"></div><div class="line">    void send(Destination var1, Message var2, int var3, int var4, long var5) throws JMSException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>而我们在创建生产者时指定了Destination，也可以在send的时候指定。而且实际工程中的业务逻辑会更加复杂，可能会存在各种判断决定消息发往哪个地址，因此不推荐在创建MessageProducer的时候创建Destination。</p>
</li>
<li><p>消息优先级，0-9。其中0-4为普通消息，5-9为加急消息，消息的默认级别是4。但是实际上，优先级只是个理论上的概念，ActiveMQ并不能保证消费的顺序性。</p>
</li>
</ul>
<h2 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h2><p>当我们需要对传入的消息设定一个固定的顺序的时候，比如商城项目中用户下单，支付，发货就是有严格的先后顺序的，不可能先发货在支付。这是或我们需要保证ActiveMQ的顺序执行。</p>
<ul>
<li>一个简单的思路是根据用户ID做一个哈希表，将消息定位到不同的队列上，从而可以使得同一个用户的消息将发往同一个队列。 然后对于同一个队列三个消息，比如订单消息，支付消息，发货消息，将其先后交付给订单系统，支付系统，物流系统进行处理。这个处理过程是同步的，但是在分布式场景下，并不会降低系统的处理性能。</li>
</ul>
<h1 id="消息的同步与异步"><a href="#消息的同步与异步" class="headerlink" title="消息的同步与异步"></a>消息的同步与异步</h1><p>接收消息，可以通过消费者的receive方法，这种方法是client端主动接收消息，也就是同步接收。需要写一个死循环来不停的接受消息。而ActiveMQ提供了异步接收的方法。其实在上一节已经使用了，但是这次单独写出来。原理很简单，我们设置一个消息监听的机制，当队列上有消息了，则回调追星messageListener接口的onMessage方法。这次贴一个我商城里面使用的Listener实现类，实现后台商品添加和索引库的同步，简单逻辑是收到商品添加事件消息之后，根据id去数据库里面查询，然后添加到document中，加到索引库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 监听商品添加事件，同步索引库</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/3/9</div><div class="line"> */</div><div class="line">public class ItemAddMessageListener implements MessageListener&#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 注入DAO</div><div class="line">     */</div><div class="line">    @Autowired</div><div class="line">    private SearchItemMapper searchItemMapper;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 注入SolrServer对象</div><div class="line">     */</div><div class="line">    @Autowired</div><div class="line">    private SolrServer solrServer;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onMessage(Message message) &#123;</div><div class="line">        try &#123;</div><div class="line">            //从消息中取商品id</div><div class="line">            TextMessage textMessage = (TextMessage) message;</div><div class="line">            String text = textMessage.getText();</div><div class="line">            long itemId = Long.parseLong(text);</div><div class="line">            //根据商品id查询数据库，取商品信息,需要设置等待时间，等待事务提交</div><div class="line">            Thread.sleep(1000);</div><div class="line">            SearchItem searchItem = searchItemMapper.getItemById(itemId);</div><div class="line">            //创建文档对象</div><div class="line">            SolrInputDocument document = new SolrInputDocument();</div><div class="line">            //向文档对象中添加域</div><div class="line">            document.addField(&quot;id&quot;, searchItem.getId());</div><div class="line">            document.addField(&quot;item_title&quot;, searchItem.getTitle());</div><div class="line">            document.addField(&quot;item_sell_point&quot;, searchItem.getSell_point());</div><div class="line">            document.addField(&quot;item_price&quot;, searchItem.getPrice());</div><div class="line">            document.addField(&quot;item_image&quot;, searchItem.getImage());</div><div class="line">            document.addField(&quot;item_category_name&quot;, searchItem.getCategory_name());</div><div class="line">            document.addField(&quot;item_desc&quot;, searchItem.getItem_desc());</div><div class="line">            //把文档对象写入索引库</div><div class="line">            solrServer.add(document);</div><div class="line">            //提交</div><div class="line">            solrServer.commit();</div><div class="line">        &#125; catch (JMSException | InterruptedException | SolrServerException | IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="P2P-和-Pub-Sub"><a href="#P2P-和-Pub-Sub" class="headerlink" title="P2P 和 Pub/Sub"></a>P2P 和 Pub/Sub</h1><p>两种消息模式，去网上找了两张图，上一节其实已经介绍了，但是没有图还是不直观</p>
<ul>
<li>一对一通信，一个生产者一个消费者</li>
</ul>
<p><img src="/img/ActiveMQ-1.png" alt="Alt text"></p>
<ul>
<li>发布订阅模式，发布一条消息，所有订阅了该目标的消费者都会收到消息。</li>
</ul>
<p><img src="/img/ActiveMQ-2.png" alt="Alt text"></p>
<p>如果消费者重启了，这个消费者会丢失一些消息，为了避免消息丢失，ActiveMQ采用了持久化机制来保存消息。</p>
<h2 id="消息化订阅"><a href="#消息化订阅" class="headerlink" title="消息化订阅"></a>消息化订阅</h2><p>持久化订阅就是如果消费者宕机，则将消息暂存在ActiveMQ中，等待消费者正常工作再发送给消费者。首先为消费者设定一个标识ID，然后创建爱你消费者的时候调用session的createDurableSubscriber方法来进行持久化订阅。</p>
<h1 id="ActiveMQ持久化机制"><a href="#ActiveMQ持久化机制" class="headerlink" title="ActiveMQ持久化机制"></a>ActiveMQ持久化机制</h1><p>为了避免意外宕机丢失信息，需要做到重启后可以恢复消息队列，消息系统一般都会采用持久化机制。ActiveMQ的持久化消息机制有JDBC、AMQ、KahaDB和LevelDB。在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库，然后试图将消息发送给接受者，发送成功则将消息从存储中删除，失败则继续尝试。</p>
<p>消息中心启动之后首先要检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。</p>
<h2 id="JDBC持久化方式"><a href="#JDBC持久化方式" class="headerlink" title="JDBC持久化方式"></a>JDBC持久化方式</h2><p>使用JDBC持久化方式，数据库会创建三个表：activemq_msgs，activemq_acks，activem_lock。其中activemq_msgs用来存储消息，Queue和Topic都存储在这个表中。</p>
<ul>
<li>配置方式</li>
</ul>
<p>配置持久化的方式，需要修改conf/activemq.xml文件，首先定义一个mysql-ds的MySQL数据源，然后在persistenceAdapter节点中配置JDBCPersistenceAdapter并且引用刚才的数据源。dataSource指定持久化数据库的Bean，createTablesOnStartup的核定是否在启动时创建数据库表，默认值为true，一般第一次启动设置为true，后面改成false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line">    &lt;broker brokerName=&quot;test-broker&quot; persistent=&quot;true&quot; xmlns=&quot;http://activemq.apache.org/schema/core&quot;&gt;</div><div class="line">        &lt;persistenceAdapter&gt;</div><div class="line">            &lt;jdbcPersistenceAdapter dataSource=&quot;#mysql-ds&quot; createTablesOnStartup=&quot;false&quot;/&gt;</div><div class="line">        &lt;/persistenceAdapter&gt;</div><div class="line">    &lt;/broker&gt;</div><div class="line">    &lt;bean id=&quot;mysql-ds&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</div><div class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</div><div class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/activemq?relaxAutoCommit=true&quot;/&gt;</div><div class="line">        &lt;property name=&quot;username&quot; value=&quot;activemq&quot;/&gt;</div><div class="line">        &lt;property name=&quot;password&quot; value=&quot;activemq&quot;/&gt;</div><div class="line">        &lt;property name=&quot;maxActive&quot; value=&quot;200&quot;/&gt;</div><div class="line">        &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<ul>
<li>数据库表信息</li>
</ul>
<p>activemq_msgs用于存储消息，Queue和Topic都存储在这个表中：</p>
<table>
<thead>
<tr>
<th>列明</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID</td>
<td style="text-align:center">自增的数据库主键</td>
</tr>
<tr>
<td>CONTAINER</td>
<td style="text-align:center">消息的Destination</td>
</tr>
<tr>
<td>MSGID_PORD</td>
<td style="text-align:center">消息发送者客户端的主键</td>
</tr>
<tr>
<td>MSG_SEQ</td>
<td style="text-align:center">发送消息的顺序，MSGID_PORD+MSG_SEQ可以组成JMS的MessageID</td>
</tr>
<tr>
<td>EXPIRATION</td>
<td style="text-align:center">消息的过期时间， 存储的是从1970-01-01到现在的毫秒数</td>
</tr>
<tr>
<td>MSG</td>
<td style="text-align:center">消息本体的Java序列化对象的二进制数据</td>
</tr>
<tr>
<td>PRIORITY</td>
<td style="text-align:center">优先级 0-9</td>
</tr>
</tbody>
</table>
<p>activemq_acks用于存储订阅关系。如果是持久化Topic，订阅者和服务器的订阅关系在这个表保存：</p>
<table>
<thead>
<tr>
<th>列明</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONTAINER</td>
<td style="text-align:center">消息的Destination</td>
</tr>
<tr>
<td>SUB_DEST</td>
<td style="text-align:center">如果是使用Static集群，这个字段会有集群其他系统的信息</td>
</tr>
<tr>
<td>CLIENT_ID</td>
<td style="text-align:center">每个订阅者都必须有一个唯一的客户端ID用以区分</td>
</tr>
<tr>
<td>SUB_NAME</td>
<td style="text-align:center">订阅者名称</td>
</tr>
<tr>
<td>SELECTOR</td>
<td style="text-align:center">选择器，可以选择只消费满足条件的消息。条件可以用自定义属性实现，可支持多属性AND和OR操作</td>
</tr>
<tr>
<td>LAST_ACKED_ID</td>
<td style="text-align:center">记录消费过的消息的ID</td>
</tr>
</tbody>
</table>
<p>表activemq_lock在集群环境中才有用，只有一个Broker可以获得消息，称为Master Broker，其他的只能作为备份等待Master Broker不可用，才可能成为下一个Master Broker。这个表用于记录哪个Broker是当前的Master Broker。</p>
<h2 id="AMQ方式"><a href="#AMQ方式" class="headerlink" title="AMQ方式"></a>AMQ方式</h2><ul>
<li><p>性能高于JDBC，写入消息时，会将消息写入日志文件，由于是顺序追加写，性能很高。为了提升性能，创建消息主键索引，并且提供缓存机制，进一步提升性能。</p>
</li>
<li><p>每个日志文件的大小是有限制的，默认为32M,可以自行配置。当超过这个大小，系统会重新建立一个文件，当所有消息都消费完成，系统会删除这个文件或者归档。</p>
</li>
<li><p>主要缺点在于AMQ Message会为每一个Destination创建一个索引，如果使用了大量的Queue，索引文件的大小会占用很多磁盘空间，而由于索引巨大，Broker崩溃，重建索引的速度非常慢。</p>
</li>
<li><p>配置方法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">     &lt;amqPersistenceAdapter directory=&quot;$&#123;activemq.data&#125;/activemq-data&quot; maxFileLength=&quot;32mb&quot;/&gt;</div><div class="line">&lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure>
<p>虽然AMQ性能高于KahaDb方式，但是由于重建索引时间过长，索引占用磁盘空间过大，实际项目中并不推荐使用，了解即可。</p>
<h2 id="KahaDB方式"><a href="#KahaDB方式" class="headerlink" title="KahaDB方式"></a>KahaDB方式</h2><p>KahaDB是从ActiveMQ5.4开始默认的持久化插件。KahaDB恢复时间远远小于其前身AMQ并且使用更少的数据文件，可以完全替代AMQ。</p>
<p>KahaDB的持久化同样是基于日志文件，索引和缓存的。</p>
<ul>
<li>配置方式如下，其中directory用来指定持久化消息的存储目录，journalMaxFileLength用来指定保存消息的日志文件大小，具体根据你的实际应用配置。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">    &lt;kahaDB directory=&quot;$&#123;activemq.data&#125;/activemq-data&quot; journalMaxFileLength=&quot;16mb&quot;/&gt;</div><div class="line">&lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>KahaDB主要特性：</p>
<ul>
<li>日志形式存储消息</li>
<li>消息索引以B-Tree结构存储</li>
<li>完全支持JMS事务</li>
<li>支持多种恢复机制</li>
</ul>
</li>
<li><p>KahaDB的结构</p>
</li>
</ul>
<p>消息存储在基于文件的的数据日志中。如果消息发送成功，变标记为可删除。系统会周期性的清除或者归档日志文件。消息文件的位置索引存储在内存中，这样能快速定位到文件。定期将内存中的消息索引保存到metadata store中，避免大量消息未发送时，消息索引占用过多内存。</p>
<p><img src="/img/ActiveMQ-3.png" alt="Alt text"></p>
<ul>
<li><p>Data logs:Data logs用于存储消息日志，消息的去哪补内容都在Data logs中。同AMQ一样，一个Data logs文件大小超过规定的最大值，会新建一个文件，同样是在文件尾部追加，写入性能很快。每个消息在Data logs中有计数引用，所以当一个文件里所有的消息都不需要了，系统会自动删除文件或放入归档文件夹。</p>
</li>
<li><p>Metadata cache:缓存用于存放在线消费者消息。如果消费者已经快速的消费完成，name这些消息就不需要写入磁盘了。Btree索引会根据MessageID创建索引，用于快速的查找消息，这个索引同样维护持久化订阅者与Destination的关系，以及每个消费者消费消息的指针。</p>
</li>
<li><p>Metadata store：在db.data文件中保存消息日志中消息的元数据，也是一B-Tree结构存储的，定时从Metadata cache更新数据。Metadata store也会备份一些在消息日志中存在的信息，这样可以让broker实例快速启动。几遍metadata store文件被破坏或者删除了，broker可以读取data logs恢复过来，只是速度回很慢。</p>
</li>
</ul>
<h2 id="LevelDB"><a href="#LevelDB" class="headerlink" title="LevelDB"></a>LevelDB</h2><ul>
<li>ActiveMQ5.6之后推出的持久化引擎LevelDB。</li>
<li>默认方式仍然是KahaDB，LevelDB的持久化性能要高于KahaDB。</li>
<li>LevelDB主要用于Master-Slave方式的主从复制数据。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/17/ActiveMQ学习总结（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/ActiveMQ学习总结（一）/" itemprop="url">ActiveMQ学习总结（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-17T19:10:14+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JMS/" itemprop="url" rel="index">
                    <span itemprop="name">JMS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JMS/ActiveMQ/" itemprop="url" rel="index">
                    <span itemprop="name">ActiveMQ</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自己写的网上商城项目中使用了ActiveMQ，虽然相比于RabbitMQ，kafka，RocketMQ等相比，ActiveMQ可能性能方面不是最好的选择，不过消息队列其实原理区别不大，这里对学过的关于消息队列的知识进行一下总结，并结合自己面试中关于这方面遇到的问题做一个整理，为后面秋招找工作做准备。这一篇主要介绍一下JMS，ActiveMQ安装及其常用接口，两种队列模式，如何集成到Spring项目，面试总结等。</p>
<h1 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h1><ul>
<li><p>Java Message Service，Java消息服务应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个程序之间，或分布式系统中发送消息，进行异步通信，JMS是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。这是比较详细的关于JMS的定义，而比较直观的说，JMS是一组消息服务的API，也就是说JMS只有接口，其具体实现类交给了各种MOM厂家来做。</p>
</li>
<li><p>JMS使用场景，应用程序A部署在北京，应用程序B部署在上海，每当A触发某个事件之后，B向获取A中的一些信息，也可能有很多个B都想获取A中的信息。这种情况下，Java提供了最佳的解决方案-JMS。JMS同样适用于基于事件的应用程序，如聊天服务，他需要一种发布事件机制向所有与服务器连接的客户端发送消息。JMS与RMI不同，不需要接受者在线。也就是服务器发送完消息，这个事件就与他无关了。</p>
</li>
<li><p>JMS的优势：</p>
<ul>
<li>异步，JMS天生就是异步的，客户端获取消息的时候，不需要主动发送请求，消息会自动发送给可用的客户端。</li>
<li>可靠，JMS保证消息只会被递送一次。大家都遇到过重复创建消息的问题，JMS可以帮你避免这个问题，但是不能杜绝，需要MOM厂家来做更加完备的机制来改善。</li>
</ul>
</li>
<li><p>JMS常用的一些概念：</p>
<ul>
<li>Provider/MessageProvider：生产者</li>
<li>Consumer/MessageConsumer：消费者</li>
<li>PTP：Point To Point，点对点通信消息模型</li>
<li>Pub/Sub：Publish/Subscribe，发布订阅消息模型</li>
<li>Queue：队列，目标类型之一，和PTP结合</li>
<li>Topic：主题，目标类型之一，和Pub/Sub结合</li>
<li>ConnectionFactory：连接工厂，JMS用它创建连接</li>
<li>Connnection：JMS Client到JMS Provider的连接</li>
<li>Destination：消息目的地，由Session创建</li>
<li>Session：会话，由Connection创建，实质上就是发送、接受消息的一个线程，因此生产者、消费者都是Session创建的</li>
</ul>
</li>
</ul>
<h1 id="ActiveMQ简介"><a href="#ActiveMQ简介" class="headerlink" title="ActiveMQ简介"></a>ActiveMQ简介</h1><p>ActiveMQ是Apache出品的，最流行的，能力强劲的开源消息总线。ActiveMQ是一个完全支持JMS1.1和J2EE1.4规范的JMS Provider实现，JMS上面已经有了简单的介绍。</p>
<h2 id="ActiveMQ的特点："><a href="#ActiveMQ的特点：" class="headerlink" title="ActiveMQ的特点："></a>ActiveMQ的特点：</h2><ul>
<li>多种语言和协议编写客户端，语言包括Java、C、C++、C#、Ruby、Perl、Python、PHP，协议包括OpenWire、Stomp、REST、WS Notification、XMPP、AMQP</li>
<li>完全支持JMS1.1和J2EE1.4规范</li>
<li>对Spring的支持，使得ActiveMQ集成到Spring里面很方便</li>
<li>支持多种传送协议：in-VM、TCP、SSL、NIO、UDP、JGroups、JXTA</li>
<li>支持通过JDBC和journal提供高速的消息持久化</li>
<li>从设计上保证了高性能的集群，客户端-服务器点对点</li>
<li>支持Ajax</li>
<li>支持与Axis的整合</li>
</ul>
<h2 id="ActiveMQ的消息形式"><a href="#ActiveMQ的消息形式" class="headerlink" title="ActiveMQ的消息形式"></a>ActiveMQ的消息形式</h2><ul>
<li><p>点对点，也就是一个省车按着对一个消费者的一对一</p>
</li>
<li><p>发布/订阅模式，一个生产者产生消息并进行发送后，可以由多个消费者进行接收</p>
</li>
</ul>
<p>JMS中定义了五种不同的消息正文格式以及调用的消息信息，允许你发送并接收以一些不同形式的数据：</p>
<pre><code>* StreamMessage --- 数据流
* MapMessage --- key-value
* TextMessage --- 字符串
* ObjectMessage --- 序列化的Java对象
* BytesMessage --- 一个字节的数据流
</code></pre><h2 id="ActiveMQ的安装"><a href="#ActiveMQ的安装" class="headerlink" title="ActiveMQ的安装"></a>ActiveMQ的安装</h2><ol>
<li>activemq.apache.org下载ActiveMQ</li>
<li>解压缩</li>
<li>启动， ./activemq start， 关闭 ./activemq stop, 查看状态 ./activemq status</li>
</ol>
<p>后台管理页面：<a href="http://192.168.25.168:8161/admin，" target="_blank" rel="external">http://192.168.25.168:8161/admin，</a> 用户名admin，密码admin</p>
<h1 id="ActiveMQ的使用"><a href="#ActiveMQ的使用" class="headerlink" title="ActiveMQ的使用"></a>ActiveMQ的使用</h1><p>添加jar包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!--引入ActiveMQ的jar包--&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h2 id="使用Queue形式的消息队列"><a href="#使用Queue形式的消息队列" class="headerlink" title="使用Queue形式的消息队列"></a>使用Queue形式的消息队列</h2><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * ActiveMQ队列模式生产者</div><div class="line"> * @throws JMSException</div><div class="line"> */</div><div class="line">@Test</div><div class="line">public void testQueueProducer() throws JMSException &#123;</div><div class="line">    //1.创建一个连接工厂对象、需要指定IP和端口/消息服务端口为61616</div><div class="line">    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://192.168.25.128:61616&quot;);</div><div class="line">    //2.使用连接工厂来创建连接</div><div class="line">    Connection connection = connectionFactory.createConnection();</div><div class="line">    //3.开启连接</div><div class="line">    connection.start();</div><div class="line">    //4.创建一个会话，</div><div class="line">    //第一个参数为是否开启ActiveMQ的事务，一般不使用事务</div><div class="line">    //如果开启事务，第二个参数自动忽略，不开启事务，第二个参数表示消息的应答模式，自动应答、手动应答</div><div class="line">    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</div><div class="line">    //5.使用Session对象来创建一个Destination对象，topic或者queue</div><div class="line">    Queue queue = session.createQueue(&quot;test-Queue&quot;);</div><div class="line">    //6.使用Session对象来创建一个生产者</div><div class="line">    MessageProducer producer = session.createProducer(queue);</div><div class="line">    //7.创建一个TextMessage对象</div><div class="line">    TextMessage textMessage = new ActiveMQTextMessage();</div><div class="line">    textMessage.setText(&quot;hello!&quot;);</div><div class="line">    //8.发送消息</div><div class="line">    producer.send(textMessage);</div><div class="line">    //9.关闭资源</div><div class="line">    producer.close();</div><div class="line">    session.close();</div><div class="line">    connection.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出生产者和消费者之间传递的对象，由三个主要部分构成：消息头+消息属性+消息体。当然创建过程中也可以对消息进行持久化的选择等配置。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * ActiveMQ队列模式消费者</div><div class="line"> * @throws JMSException</div><div class="line"> */</div><div class="line">@Test</div><div class="line">public void testQueueConsumer() throws JMSException, IOException &#123;</div><div class="line">    //1.创建一个连接工厂对象、需要指定IP和端口/消息服务端口为61616</div><div class="line">    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://192.168.25.128:61616&quot;);</div><div class="line">    //2.使用连接工厂来创建连接</div><div class="line">    Connection connection = connectionFactory.createConnection();</div><div class="line">    //3.开启连接</div><div class="line">    connection.start();</div><div class="line">    //4.创建一个会话，</div><div class="line">    //第一个参数为是否开启ActiveMQ的事务，一般不使用事务</div><div class="line">    //如果开启事务，第二个参数自动忽略，不开启事务，第二个参数表示消息的应答模式，自动应答、手动应答</div><div class="line">    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</div><div class="line">    //5.使用Session对象来创建一个Destination对象，topic或者queue</div><div class="line">    Queue queue = session.createQueue(&quot;test-Queue&quot;);</div><div class="line">    //6.使用Session对象来创建一个消费者</div><div class="line">    MessageConsumer consumer = session.createConsumer(queue);</div><div class="line">    //7.接收消息</div><div class="line">    consumer.setMessageListener(new MessageListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onMessage(Message message) &#123;</div><div class="line">            TextMessage textMessage = (TextMessage) message;</div><div class="line">            String text = null;</div><div class="line">            try &#123;</div><div class="line">                text = textMessage.getText();</div><div class="line">            &#125; catch (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(text);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    //8.关闭资源</div><div class="line">    System.in.read();</div><div class="line">    consumer.close();</div><div class="line">    session.close();</div><div class="line">    connection.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注释基本解释清楚了基本的流程，唯一要注意的是接收消息的时候，我们先查看setMessageListener这个方法,其接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void setMessageListener(MessageListener var1) throws JMSException;</div></pre></td></tr></table></figure>
<p>也就是说需要传入一个实现了MessageListener接口的对象，而MessageListener接口如下只有一个onMessage方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">package javax.jms;</div><div class="line"></div><div class="line">public interface MessageListener &#123;</div><div class="line">    void onMessage(Message var1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>采用匿名类的方法来对test-Queue队列进行监控，只要有消息进来，就立即执行onMessage方法。</p>
<h2 id="Topic模式"><a href="#Topic模式" class="headerlink" title="Topic模式"></a>Topic模式</h2><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * ActiveMQ的订阅模式生产者</div><div class="line"> */</div><div class="line">@Test</div><div class="line">public void testTopicProducer() throws Exception &#123;</div><div class="line">    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://192.168.25.128:61616&quot;);</div><div class="line">    Connection connection = connectionFactory.createConnection();</div><div class="line">    connection.start();</div><div class="line">    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</div><div class="line">    Topic topic = session.createTopic(&quot;test-topic&quot;);</div><div class="line">    MessageProducer producer = session.createProducer(topic);</div><div class="line">    TextMessage activeMQ_topic = session.createTextMessage(&quot;activeMQ topic&quot;);</div><div class="line">    producer.send(activeMQ_topic);</div><div class="line"></div><div class="line">    producer.close();</div><div class="line">    session.close();</div><div class="line">    connection.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和队列模式相比，只是由session生成的消息队列模式编程了订阅发布模式，其他完全一样。</p>
<h3 id="Consumer-1"><a href="#Consumer-1" class="headerlink" title="Consumer"></a>Consumer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * ActiveMQ的订阅者模式消费者</div><div class="line"> */</div><div class="line">@Test</div><div class="line">public void testTopicConsumer() throws Exception&#123;</div><div class="line">    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://192.168.25.128:61616&quot;);</div><div class="line">    Connection connection = connectionFactory.createConnection();</div><div class="line">    connection.start();</div><div class="line">    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</div><div class="line">    Topic topic = session.createTopic(&quot;test-topic&quot;);</div><div class="line">    MessageConsumer consumer = session.createConsumer(topic);</div><div class="line">    consumer.setMessageListener(new MessageListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onMessage(Message message) &#123;</div><div class="line">            if (message instanceof TextMessage) &#123;</div><div class="line">                TextMessage textMessage = (TextMessage) message;</div><div class="line">                try &#123;</div><div class="line">                    String text = textMessage.getText();</div><div class="line">                    System.out.println(text);</div><div class="line">                &#125; catch (JMSException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    System.in.read();</div><div class="line">    consumer.close();</div><div class="line">    session.close();</div><div class="line">    connection.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="ActiveMQ在Spring中的使用"><a href="#ActiveMQ在Spring中的使用" class="headerlink" title="ActiveMQ在Spring中的使用"></a>ActiveMQ在Spring中的使用</h1><p>上一节介绍的在项目中直接使用消息队列的方式，可以看出存在很大的重复代码，而且步骤很多，将ActiveMQ整合到Spring中可以大大改善这两个问题。</p>
<ol>
<li>引入JMS相关jar包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<ol>
<li>配置ActiveMQ整合Spring，配置ConnectionFactory</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!--ConnectionFactory,JMS服务厂商提供的ConnectionFactory--&gt;</div><div class="line">&lt;bean id=&quot;targetConnecctionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;</div><div class="line">    &lt;constructor-arg name=&quot;brokerURL&quot; value=&quot;tcp://192.168.25.128:61616&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;!--spring对ConnectionFactory的封装--&gt;</div><div class="line">&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.SingleConnectionFactory&quot;&gt;</div><div class="line">    &lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;targetConnecctionFactory&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<ol>
<li>配置生产者，使用JMSTemplate对象，发送消息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--配置JMSTemplate--&gt;</div><div class="line">&lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;</div><div class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<ol>
<li>配置Destination</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!--消息的目的地--&gt;</div><div class="line">&lt;bean id=&quot;test-queue&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;</div><div class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;test-queue&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean id=&quot;item-add-topic&quot; class=&quot;org.apache.activemq.command.ActiveMQTopic&quot;&gt;</div><div class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;item-add-topic&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<ul>
<li>完整的配置文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</div><div class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</div><div class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</div><div class="line">	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</div><div class="line">	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd</div><div class="line">	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd&quot;&gt;</div><div class="line"></div><div class="line">    &lt;!--ConnectionFactory,JMS服务厂商提供的ConnectionFactory--&gt;</div><div class="line">    &lt;bean id=&quot;targetConnecctionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;</div><div class="line">        &lt;constructor-arg name=&quot;brokerURL&quot; value=&quot;tcp://192.168.25.128:61616&quot;/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    &lt;!--spring对ConnectionFactory的封装--&gt;</div><div class="line">    &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.SingleConnectionFactory&quot;&gt;</div><div class="line">        &lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;targetConnecctionFactory&quot;/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    &lt;!--配置JMSTemplate--&gt;</div><div class="line">    &lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;</div><div class="line">        &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    &lt;!--消息的目的地--&gt;</div><div class="line">    &lt;bean id=&quot;test-queue&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;</div><div class="line">        &lt;constructor-arg name=&quot;name&quot; value=&quot;test-queue&quot;/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    &lt;bean id=&quot;item-add-topic&quot; class=&quot;org.apache.activemq.command.ActiveMQTopic&quot;&gt;</div><div class="line">        &lt;constructor-arg name=&quot;name&quot; value=&quot;item-add-topic&quot;/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><ol>
<li>发送消息，步骤注释中写的很清楚了，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 使用JMSTemplate来发送消息</div><div class="line"> * @throws Exception</div><div class="line"> */</div><div class="line">@Test</div><div class="line">public void testJmsTemplate() throws Exception &#123;</div><div class="line">    //初始化Spring容器</div><div class="line">    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring/applicationContext-activemq.xml&quot;);</div><div class="line">    //从容器中获得模板对象</div><div class="line">    JmsTemplate jmsTemplate = applicationContext.getBean(JmsTemplate.class);</div><div class="line">    //从容器中获得Destination对象</div><div class="line">    Destination destination = (Destination) applicationContext.getBean(&quot;test-queue&quot;);</div><div class="line">    //发送消息</div><div class="line">    jmsTemplate.send(destination, new MessageCreator() &#123;</div><div class="line">        @Override</div><div class="line">        public Message createMessage(Session session) throws JMSException &#123;</div><div class="line">            return session.createTextMessage(&quot;spring activemq send queue message&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>接收消息</li>
</ol>
<p>由于项目中使用ActiveMQ实现索引库和数据库的同步，为了接收ActiveMQ的消息，需要创建一个MessageListener实现类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 接收ActiveMQ发送的消息</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/3/9</div><div class="line"> */</div><div class="line">public class MyMesseageListener implements MessageListener&#123;</div><div class="line">    @Override</div><div class="line">    public void onMessage(Message message) &#123;</div><div class="line">        //接收消息</div><div class="line">        try &#123;</div><div class="line">            TextMessage textMessage = (TextMessage) message;</div><div class="line">            String text = textMessage.getText();</div><div class="line">            System.out.println(text);</div><div class="line">        &#125; catch (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在Spring中整合ActiveMQ的消息监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;!--ConnectionFactory,JMS服务厂商提供的ConnectionFactory--&gt;</div><div class="line">&lt;bean id=&quot;targetConnecctionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;</div><div class="line">    &lt;constructor-arg name=&quot;brokerURL&quot; value=&quot;tcp://192.168.25.128:61616&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;!--spring对ConnectionFactory的封装--&gt;</div><div class="line">&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.SingleConnectionFactory&quot;&gt;</div><div class="line">    &lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;targetConnecctionFactory&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;!--消息的目的地--&gt;</div><div class="line">&lt;bean id=&quot;test-queue&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;</div><div class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;test-queue&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean id=&quot;item-add-topic&quot; class=&quot;org.apache.activemq.command.ActiveMQTopic&quot;&gt;</div><div class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;item-add-topic&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;!--配置消息的接受者--&gt;</div><div class="line">&lt;!--配置监听器--&gt;</div><div class="line">&lt;bean id=&quot;messeageListener&quot; class=&quot;com.market.search.listen.MyMesseageListener&quot;/&gt;</div><div class="line">&lt;!--消息监听容器--&gt;</div><div class="line">&lt;bean class=&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt;</div><div class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;</div><div class="line">    &lt;property name=&quot;destination&quot; ref=&quot;test-queue&quot;/&gt;</div><div class="line">    &lt;property name=&quot;messageListener&quot; ref=&quot;messeageListener&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testQueueConsumer() throws Exception &#123;</div><div class="line">    //初始化Spring容器</div><div class="line">    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring/applicationContext-activemq.xml&quot;);</div><div class="line">    System.in.read();</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/17/Dubbo框架学习总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/Dubbo框架学习总结/" itemprop="url">Dubbo框架学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-17T09:15:00+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Dubbo/" itemprop="url" rel="index">
                    <span itemprop="name">Dubbo</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Dubbo/RPC/" itemprop="url" rel="index">
                    <span itemprop="name">RPC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Dubbo的定义"><a href="#Dubbo的定义" class="headerlink" title="Dubbo的定义"></a>Dubbo的定义</h1><p>官方定义：Apache Dubbo是一个由阿里提供开源的基于Java的高性能的RPC框架。遵循RPC框架的设计原则，Dubbo也定义了服务的概念，可以远程根据参数和返回值来调用具体的方法。在服务侧，服务侧实现这个接口并运行一个Dubbo服务来处理客户端的请求，在客户端保存有服务端相同的方法存根。</p>
<p>Dubbo有三个主要特性：</p>
<ul>
<li>基于接口的远程的调用</li>
<li>容错和负载均衡</li>
<li>服务的子自动注册和发现。</li>
</ul>
<p>Dubbo相关的文档：<br><a href="http://dubbo.apache.org/books/dubbo-user-book/preface/background.html" target="_blank" rel="external">Dubbo用户手册</a><br><a href="http://dubbo.apache.org/books/dubbo-dev-book/build.html" target="_blank" rel="external">Dubbo开发手册</a><br><a href="http://dubbo.apache.org/books/dubbo-admin-book/install/zookeeper.html" target="_blank" rel="external">Dubbo管理手册</a><br><a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="external">Dubbo GitHub </a></p>
<h1 id="Dubbo结构"><a href="#Dubbo结构" class="headerlink" title="Dubbo结构"></a>Dubbo结构</h1><p><img src="/img/Dubbo-Arch.png" alt="Alt text"></p>
<ol>
<li>服务提供者-对外暴露自己的服务，服务提供者会将自己提供的服务注册到注册中心</li>
<li>容器-初始化服务，加载服务，运行服务</li>
<li>服务消费者-调用远程服务，会向注册中心订阅他需要的服务。</li>
<li>注册中心-服务注册与发现</li>
<li>监控中心-记录服务相关的数据，比如服务的调用频率，调用次数等</li>
</ol>
<p><em>服务提供者，服务消费者和注册中心的连接是持久的，所以当一个服务提供者挂掉之后，注册中心可以检测到服务提供者的失效并将此信息通知给服务消费者</em></p>
<p><em>注册中心和监控中心是可选的，服务消费者可以直接连接到服务提供者，但是这样会影响整个系统的稳定性，不推荐直接连接</em></p>
<h2 id="调用关系说明"><a href="#调用关系说明" class="headerlink" title="调用关系说明"></a>调用关系说明</h2><ol>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己需要的服务。</li>
<li>注册中心返回服务提供者列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者经调用，如果调用失败，再选一台调用。</li>
<li>服务消费者和提供者，在内存中累积调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<h2 id="Dubbo架构的特点"><a href="#Dubbo架构的特点" class="headerlink" title="Dubbo架构的特点"></a>Dubbo架构的特点</h2><h3 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><ul>
<li>注册中心负责服务地址的注册于查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发消息，压力较小。</li>
<li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示。</li>
<li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销。</li>
<li>服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销。</li>
<li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心不是。</li>
<li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者。</li>
<li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地魂村了提供者列表。</li>
<li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。</li>
</ul>
<h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><ul>
<li>监控中心宕机不影响使用，只是丢失部分统计数据。</li>
<li>数据库宕机，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕机之后，将自动切换到另一台</li>
<li>注册中心全部宕机后，服务提供者和服务消费者仍能通过本地换粗通讯</li>
<li>服务提供者无状态，任意一台宕机后，不影响使用。</li>
<li>服务提供者全部宕机之后，服务消费者应用将无法使用，并无限次重连等待服务提供者回复。</li>
</ul>
<h3 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h3><ul>
<li>注册中心为了对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</li>
<li>服务提供者无状态，可动态增加及其部署实例，注册中心将推送新的服务提供者信息给消费者。</li>
</ul>
<h3 id="升级性"><a href="#升级性" class="headerlink" title="升级性"></a>升级性</h3><ul>
<li>当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有的分布式架构不会带来阻力，下图为一种可能结果：</li>
</ul>
<p><img src="/img/Dubbo-Futurearch.png" alt="Alt text"></p>
<h1 id="Dubbo依赖要求"><a href="#Dubbo依赖要求" class="headerlink" title="Dubbo依赖要求"></a>Dubbo依赖要求</h1><ul>
<li><p>工具版本要求：</p>
<ul>
<li>JDK：6及以上</li>
<li>Maven：3及以上</li>
</ul>
</li>
<li><p>Maven依赖配置：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<ul>
<li>Dubbo缺省依赖以下库：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[INFO] +- com.alibaba:dubbo:jar:2.5.9-SNAPSHOT:compile</div><div class="line">[INFO] |  +- org.springframework:spring-context:jar:4.3.10.RELEASE:compile</div><div class="line">[INFO] |  +- org.javassist:javassist:jar:3.21.0-GA:compile</div><div class="line">[INFO] |  \- org.jboss.netty:netty:jar:3.2.5.Final:compile</div></pre></td></tr></table></figure>
<ul>
<li>可选依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">netty-all 4.0.35.Final</div><div class="line">mina: 1.1.7</div><div class="line">grizzly: 2.1.4</div><div class="line">httpclient: 4.5.3</div><div class="line">hessian_lite: 3.2.1-fixed</div><div class="line">fastjson: 1.2.31</div><div class="line">zookeeper: 3.4.9</div><div class="line">jedis: 2.9.0</div><div class="line">xmemcached: 1.3.6</div><div class="line">hessian: 4.0.38</div><div class="line">jetty: 6.1.26</div><div class="line">hibernate-validator: 5.4.1.Final</div><div class="line">zkclient: 0.2</div><div class="line">curator: 2.12.0</div><div class="line">cxf: 3.0.14</div><div class="line">thrift: 0.8.0</div><div class="line">servlet: 3.0 6</div><div class="line">validation-api: 1.1.0.GA 6</div><div class="line">jcache: 1.0.0 6</div><div class="line">javax.el: 3.0.1-b08 6</div><div class="line">kryo: 4.0.1</div><div class="line">kryo-serializers: 0.42</div><div class="line">fst: 2.48-jdk-6</div><div class="line">resteasy: 3.0.19.Final</div><div class="line">tomcat-embed-core: 8.0.11</div><div class="line">slf4j: 1.7.25</div><div class="line">log4j: 1.2.16</div></pre></td></tr></table></figure>
<h2 id="Spring中Dubbo应用示例"><a href="#Spring中Dubbo应用示例" class="headerlink" title="Spring中Dubbo应用示例"></a>Spring中Dubbo应用示例</h2><ul>
<li>定义服务接口：由于服务的提供者和消费者都依赖于同一个接口，因此强烈建议将接口定义在一个单独的模块里面，从而方便服务提供者模块和消费者模块来依赖。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">package com.alibaba.dubbo.demo;</div><div class="line"></div><div class="line">public interface DemoService &#123;</div><div class="line">    String sayHello(String name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>实现服务的提供者</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package com.alibaba.dubbo.demo.provider;</div><div class="line">import com.alibaba.dubbo.demo.DemoService;</div><div class="line"></div><div class="line">public class DemoServiceImpl implements DemoService &#123;</div><div class="line">    public String sayHello(String name) &#123;</div><div class="line">        return &quot;Hello &quot; + name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>配置服务的提供者–在spring中如何配置Dubbo服务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</div><div class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</div><div class="line"></div><div class="line">    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</div><div class="line">    &lt;dubbo:application name=&quot;hello-world-app&quot;  /&gt;</div><div class="line"></div><div class="line">    &lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;</div><div class="line">    &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</div><div class="line">    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;!-- 声明需要暴露的服务接口 --&gt;</div><div class="line">    &lt;dubbo:service interface=&quot;com.alibaba.dubbo.demo.DemoService&quot; ref=&quot;demoService&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;!-- 和本地bean一样实现服务 --&gt;</div><div class="line">    &lt;bean id=&quot;demoService&quot; class=&quot;com.alibaba.dubbo.demo.provider.DemoServiceImpl&quot; /&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>从配置文件中可以看到我们只将demoService的接口暴露给一个URL，dubbo://127.0.0.1:20880,并将该服务注册给一个多媒体地址：multicast://224.5.6.7:1234</p>
<p>dubbo协议是Dubbo框架支持的众多协议之一，dubbo协议是在Java NIO特性的基础之上的，为Dubbo架构的默认协议。</p>
<ul>
<li>开启服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line">public class Provider &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(</div><div class="line">                new String[] &#123;&quot;META-INF/spring/dubbo-demo-provider.xml&quot;&#125;);</div><div class="line">        context.start();</div><div class="line">        // press any key to exit</div><div class="line">        System.in.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>配置服务消费者</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</div><div class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</div><div class="line"></div><div class="line">    &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</div><div class="line">    &lt;dubbo:application name=&quot;consumer-of-helloworld-app&quot;  /&gt;</div><div class="line"></div><div class="line">    &lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt;</div><div class="line">    &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</div><div class="line">    &lt;dubbo:reference id=&quot;demoService&quot; interface=&quot;com.alibaba.dubbo.demo.DemoService&quot; /&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>这个过程看起来和传统的web服务调用很想，但是dubbo协议使得其调用更加简单，轻量化，效率相对要高。</p>
<ul>
<li>运行服务消费者</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line">import com.alibaba.dubbo.demo.DemoService;</div><div class="line"></div><div class="line">public class Consumer &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;&quot;http://10.20.160.198/wiki/display/dubbo/consumer.xml&quot;&#125;);</div><div class="line">        context.start();</div><div class="line">        DemoService demoService = (DemoService)context.getBean(&quot;demoService&quot;); // 获取远程服务代理</div><div class="line">        String hello = demoService.sayHello(&quot;world&quot;); // 执行远程方法</div><div class="line">        System.out.println( hello ); // 显示调用结果</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>配置简单注册中心</li>
</ul>
<p>当我们使用多点传播注册中心时，注册服务不是单独的，因此适用于局域网场景。为了适应更加便于管理的注册中心，可以使用SimpleRegistryService。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:application name=&quot;simple-registry&quot; /&gt;</div><div class="line">&lt;dubbo:protocol port=&quot;9090&quot; /&gt;</div><div class="line">&lt;dubbo:service interface=&quot;com.alibaba.dubbo.registry.RegistryService&quot;</div><div class="line">  ref=&quot;registryService&quot; registry=&quot;N/A&quot; ondisconnect=&quot;disconnect&quot;&gt;</div><div class="line">    &lt;dubbo:method name=&quot;subscribe&quot;&gt;</div><div class="line">        &lt;dubbo:argument index=&quot;1&quot; callback=&quot;true&quot; /&gt;</div><div class="line">    &lt;/dubbo:method&gt;</div><div class="line">    &lt;dubbo:method name=&quot;unsubscribe&quot;&gt;</div><div class="line">        &lt;dubbo:argument index=&quot;1&quot; callback=&quot;true&quot; /&gt;</div><div class="line">    &lt;/dubbo:method&gt;</div><div class="line">&lt;/dubbo:service&gt;</div><div class="line"></div><div class="line">&lt;bean class=&quot;com.alibaba.dubbo.registry.simple.SimpleRegistryService&quot;</div><div class="line">  id=&quot;registryService&quot; /&gt;</div></pre></td></tr></table></figure>
<p>可以用于测试，但是实际工程中不推荐使用。</p>
<h1 id="Dubbo配置"><a href="#Dubbo配置" class="headerlink" title="Dubbo配置"></a>Dubbo配置</h1><h2 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h2><p>xml配置Dubbo可以参照上一节的实例，spring中可以直接通过dubbo标签库来对其进行配置设定等操作，使用广泛且条理清晰。所有的标签都支持自定义参数，用于不同扩展点实现的特殊配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:protocol name=&quot;jms&quot;&gt;</div><div class="line">    &lt;dubbo:parameter key=&quot;queue&quot; value=&quot;your_queue&quot; /&gt;</div><div class="line">&lt;/dubbo:protocol&gt;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//2.1之后开始支持这种自定义参数的方式</div><div class="line">&lt;dubbo:protocol name=&quot;jms&quot; p:queue=&quot;your_queue&quot; /&gt;</div></pre></td></tr></table></figure>
<ul>
<li>常用标签</li>
</ul>
<table>
<thead>
<tr>
<th>标签</th>
<th style="text-align:center">用途</th>
<th style="text-align:right">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;dubbo:service/&gt;</code></td>
<td style="text-align:center">服务配置</td>
<td style="text-align:right">用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</td>
</tr>
<tr>
<td><code>&lt;dubbo:reference/&gt;</code></td>
<td style="text-align:center">引用配置</td>
<td style="text-align:right">用于创建一个远程服务代理，一个引用可以指向多个注册中心</td>
</tr>
<tr>
<td><code>&lt;dubbo:protocol/&gt;</code></td>
<td style="text-align:center">协议配置</td>
<td style="text-align:right">用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受</td>
</tr>
<tr>
<td><code>&lt;dubbo:application/&gt;</code></td>
<td style="text-align:center">应用配置</td>
<td style="text-align:right">用于配置当前应用信息，不管该应用是提供者还是消费者</td>
</tr>
<tr>
<td><code>&lt;dubbo:module/&gt;</code></td>
<td style="text-align:center">模块配置</td>
<td style="text-align:right">用于配置当前模块信息，可选</td>
</tr>
<tr>
<td><code>&lt;dubbo:registry/&gt;</code></td>
<td style="text-align:center">注册中心配置</td>
<td style="text-align:right">用于配置连接注册中心相关信息</td>
</tr>
<tr>
<td><code>&lt;dubbo:monitor/&gt;</code></td>
<td style="text-align:center">监控中心配置</td>
<td style="text-align:right">用于配置连接监控中心相关信息，可选</td>
</tr>
<tr>
<td><code>&lt;dubbo:provider/&gt;</code></td>
<td style="text-align:center">提供方配置</td>
<td style="text-align:right">当ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选</td>
</tr>
<tr>
<td><code>&lt;dubbo:consumer/&gt;</code></td>
<td style="text-align:center">消费方配置</td>
<td style="text-align:right">当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选</td>
</tr>
<tr>
<td><code>&lt;dubbo:method/&gt;</code></td>
<td style="text-align:center">方法配置</td>
<td style="text-align:right">用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息</td>
</tr>
<tr>
<td><code>&lt;dubbo:argument/&gt;</code></td>
<td style="text-align:center">参数配置</td>
<td style="text-align:right">用于指定方法参数配置</td>
</tr>
</tbody>
</table>
<ul>
<li>标签之间的关系</li>
</ul>
<p><img src="/img/Dubbo-3.png" alt="Alt text"></p>
<p>  <em>配置覆盖关系为方法级别的优先，接口几倍的次之，全局配置再次之，级别一样消费者优先，提供者次之</em></p>
<h2 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h2><p>公共配置简单，没有多注册中心，多协议等情况，或者多个Spring容器想要共享配置，可以使用dubbo.properties作为缺省配置。Dubbo会自动加载classpath路径下的dubbo.properties文件，可以通过JVM启动参数<code>-Ddubbo.properties.file=xxx.properties</code>改动缺省位置。</p>
<ul>
<li>映射规则:将XML配置的标签名，属性名，用点分隔，多个属性拆分成多行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dubbo.application.name=foo</div><div class="line">dubbo.application.owner=bar</div><div class="line">dubbo.registry.address=10.20.153.10:9090</div></pre></td></tr></table></figure>
<ul>
<li>覆盖策略：JVM启动，-D参数优先，XML次之，Properties文件最后。只有XML没有配置时，dubbo.properties才会生效。</li>
</ul>
<h2 id="Java-API配置Dubbo"><a href="#Java-API配置Dubbo" class="headerlink" title="Java API配置Dubbo"></a>Java API配置Dubbo</h2><p>除了spring配置文件来配置Dubbo之外，通过Java API，property文件以及注解来配置Dubbo同样可以。配置文件和注解配置适用于结构不是很复杂的场景。下面介绍如何使用API来配置Dubbo。</p>
<ul>
<li>服务提供者</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">import com.alibaba.dubbo.rpc.config.ApplicationConfig;</div><div class="line">import com.alibaba.dubbo.rpc.config.RegistryConfig;</div><div class="line">import com.alibaba.dubbo.rpc.config.ProviderConfig;</div><div class="line">import com.alibaba.dubbo.rpc.config.ServiceConfig;</div><div class="line">import com.xxx.XxxService;</div><div class="line">import com.xxx.XxxServiceImpl;</div><div class="line"></div><div class="line">// 服务实现</div><div class="line">XxxService xxxService = new XxxServiceImpl();</div><div class="line"></div><div class="line">// 当前应用配置</div><div class="line">ApplicationConfig application = new ApplicationConfig();</div><div class="line">application.setName(&quot;xxx&quot;);</div><div class="line"></div><div class="line">// 连接注册中心配置</div><div class="line">RegistryConfig registry = new RegistryConfig();</div><div class="line">registry.setAddress(&quot;10.20.130.230:9090&quot;);</div><div class="line">registry.setUsername(&quot;aaa&quot;);</div><div class="line">registry.setPassword(&quot;bbb&quot;);</div><div class="line"></div><div class="line">// 服务提供者协议配置</div><div class="line">ProtocolConfig protocol = new ProtocolConfig();</div><div class="line">protocol.setName(&quot;dubbo&quot;);</div><div class="line">protocol.setPort(12345);</div><div class="line">protocol.setThreads(200);</div><div class="line"></div><div class="line">// 注意：ServiceConfig为重对象，内部封装了与注册中心的连接，以及开启服务端口</div><div class="line"></div><div class="line">// 服务提供者暴露服务配置</div><div class="line">ServiceConfig&lt;XxxService&gt; service = new ServiceConfig&lt;XxxService&gt;(); // 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏</div><div class="line">service.setApplication(application);</div><div class="line">service.setRegistry(registry); // 多个注册中心可以用setRegistries()</div><div class="line">service.setProtocol(protocol); // 多个协议可以用setProtocols()</div><div class="line">service.setInterface(XxxService.class);</div><div class="line">service.setRef(xxxService);</div><div class="line">service.setVersion(&quot;1.0.0&quot;);</div><div class="line"></div><div class="line">// 暴露及注册服务</div><div class="line">service.export();</div></pre></td></tr></table></figure>
<ul>
<li>此时，服务已经暴露给多点传播的注册中心了，然后配置服务消费者：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import com.alibaba.dubbo.rpc.config.ApplicationConfig;</div><div class="line">import com.alibaba.dubbo.rpc.config.RegistryConfig;</div><div class="line">import com.alibaba.dubbo.rpc.config.ConsumerConfig;</div><div class="line">import com.alibaba.dubbo.rpc.config.ReferenceConfig;</div><div class="line">import com.xxx.XxxService;</div><div class="line"></div><div class="line">// 当前应用配置</div><div class="line">ApplicationConfig application = new ApplicationConfig();</div><div class="line">application.setName(&quot;yyy&quot;);</div><div class="line"></div><div class="line">// 连接注册中心配置</div><div class="line">RegistryConfig registry = new RegistryConfig();</div><div class="line">registry.setAddress(&quot;10.20.130.230:9090&quot;);</div><div class="line">registry.setUsername(&quot;aaa&quot;);</div><div class="line">registry.setPassword(&quot;bbb&quot;);</div><div class="line"></div><div class="line">// 注意：ReferenceConfig为重对象，内部封装了与注册中心的连接，以及与服务提供方的连接</div><div class="line"></div><div class="line">// 引用远程服务</div><div class="line">ReferenceConfig&lt;XxxService&gt; reference = new ReferenceConfig&lt;XxxService&gt;(); // 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏</div><div class="line">reference.setApplication(application);</div><div class="line">reference.setRegistry(registry); // 多个注册中心可以用setRegistries()</div><div class="line">reference.setInterface(XxxService.class);</div><div class="line">reference.setVersion(&quot;1.0.0&quot;);</div><div class="line"></div><div class="line">// 和本地bean一样使用xxxService</div><div class="line">XxxService xxxService = reference.get(); // 注意：此代理对象内部封装了所有通讯细节，对象较重，请缓存复用</div></pre></td></tr></table></figure>
<h2 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h2><h3 id="服务提供方"><a href="#服务提供方" class="headerlink" title="服务提供方"></a>服务提供方</h3><ul>
<li>Service注解暴露服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import com.alibaba.dubbo.config.annotation.Service;</div><div class="line"></div><div class="line">@Service(timeout = 5000)</div><div class="line">public class AnnotateServiceImpl implements AnnotateService &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>javaconfig形式配置公共模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class DubboConfiguration &#123;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public ApplicationConfig applicationConfig() &#123;</div><div class="line">        ApplicationConfig applicationConfig = new ApplicationConfig();</div><div class="line">        applicationConfig.setName(&quot;provider-test&quot;);</div><div class="line">        return applicationConfig;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public RegistryConfig registryConfig() &#123;</div><div class="line">        RegistryConfig registryConfig = new RegistryConfig();</div><div class="line">        registryConfig.setAddress(&quot;zookeeper://127.0.0.1:2181&quot;);</div><div class="line">        registryConfig.setClient(&quot;curator&quot;);</div><div class="line">        return registryConfig;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>指定Java扫描路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@DubboComponentScan(basePackages = &quot;com.alibaba.dubbo.test.service.impl&quot;)</div><div class="line">public class ProviderTestApp &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><ul>
<li>reference 注解引用服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class AnnotationConsumeService &#123;</div><div class="line"></div><div class="line">    @com.alibaba.dubbo.config.annotation.Reference</div><div class="line">    public AnnotateService annotateService;</div><div class="line"></div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>javaconfig形式配置公共模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class DubboConfiguration &#123;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public ApplicationConfig applicationConfig() &#123;</div><div class="line">        ApplicationConfig applicationConfig = new ApplicationConfig();</div><div class="line">        applicationConfig.setName(&quot;consumer-test&quot;);</div><div class="line">        return applicationConfig;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public ConsumerConfig consumerConfig() &#123;</div><div class="line">        ConsumerConfig consumerConfig = new ConsumerConfig();</div><div class="line">        consumerConfig.setTimeout(3000);</div><div class="line">        return consumerConfig;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public RegistryConfig registryConfig() &#123;</div><div class="line">        RegistryConfig registryConfig = new RegistryConfig();</div><div class="line">        registryConfig.setAddress(&quot;zookeeper://127.0.0.1:2181&quot;);</div><div class="line">        registryConfig.setClient(&quot;curator&quot;);</div><div class="line">        return registryConfig;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>指定dubbo扫描路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@DubboComponentScan(basePackages = &quot;com.alibaba.dubbo.test.service&quot;)</div><div class="line">public class ConsumerTestApp &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，还是XML配置更加的简洁明了。</p>
<h1 id="Dubbo支持的协议"><a href="#Dubbo支持的协议" class="headerlink" title="Dubbo支持的协议"></a>Dubbo支持的协议</h1><p>Dubbo框架支持多种协议，包括dubbo、RMI、hessian、HTTP、web service、thrift、memcached、redis等。大多数协议之前都已经了解过，除了dubbo这个协议。</p>
<p>dubbo协议在服务提供者和消费者之间建立了长连接，这种长连接和非阻塞的网络传输在传输数据小于100k的时候效率非常高。dubbo协议中的参数包含端口，每个消费者的连接数，最大接受的连接数等。</p>
<p><code>&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;  connections=&quot;2&quot; accepts=&quot;1000&quot; /&gt;</code></p>
<p>Dubbo还支持通过不同协议来同时暴露服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;</div><div class="line">&lt;dubbo:protocol name=&quot;rmi&quot; port=&quot;1099&quot; /&gt;</div><div class="line"></div><div class="line">&lt;dubbo:service interface=&quot;com.baeldung.dubbo.remote.GreetingsService&quot; version=&quot;1.0.0&quot; ref=&quot;greetingsService&quot; protocol=&quot;dubbo&quot; /&gt;</div><div class="line">&lt;dubbo:service interface=&quot;com.bealdung.dubbo.remote.AnotherService&quot; version=&quot;1.0.0&quot; ref=&quot;anotherService&quot; protocol=&quot;rmi&quot; /&gt;</div></pre></td></tr></table></figure>
<h1 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h1><p>Dubbo对于远程调用的结果进行了本地的缓存来提高对于热点数据的访问速度。实现添加cache属性即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:reference interface=&quot;com.baeldung.dubbo.remote.GreetingsService&quot; id=&quot;greetingsService&quot; cache=&quot;lru&quot; /&gt;</div></pre></td></tr></table></figure>
<p>缓存策略选择的是最少最近使用缓存，当我们队服务的提供者的实现类进行修改之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class GreetingsServiceSpecialImpl implements GreetingsService &#123;</div><div class="line">    @Override</div><div class="line">    public String sayHi(String name) &#123;</div><div class="line">        try &#123;</div><div class="line">            SECONDS.sleep(5);</div><div class="line">        &#125; catch (Exception ignored) &#123; &#125;</div><div class="line">        return &quot;hi, &quot; + name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对调用速度进行一下测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void givenProvider_whenConsumerSaysHi_thenGotResponse() &#123;</div><div class="line">    ClassPathXmlApplicationContext localContext</div><div class="line">      = new ClassPathXmlApplicationContext(&quot;multicast/consumer-app.xml&quot;);</div><div class="line">    localContext.start();</div><div class="line">    GreetingsService greetingsService</div><div class="line">      = (GreetingsService) localContext.getBean(&quot;greetingsService&quot;);</div><div class="line"></div><div class="line">    long before = System.currentTimeMillis();</div><div class="line">    String hiMessage = greetingsService.sayHi(&quot;baeldung&quot;);</div><div class="line"></div><div class="line">    long timeElapsed = System.currentTimeMillis() - before;</div><div class="line">    assertTrue(timeElapsed &gt; 5000);</div><div class="line">    assertNotNull(hiMessage);</div><div class="line">    assertEquals(&quot;hi, baeldung&quot;, hiMessage);</div><div class="line"></div><div class="line">    before = System.currentTimeMillis();</div><div class="line">    hiMessage = greetingsService.sayHi(&quot;baeldung&quot;);</div><div class="line">    timeElapsed = System.currentTimeMillis() - before;</div><div class="line"></div><div class="line">    assertTrue(timeElapsed &lt; 1000);</div><div class="line">    assertNotNull(hiMessage);</div><div class="line">    assertEquals(&quot;hi, baeldung&quot;, hiMessage);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了第一次调用，后面的调用几乎是立刻完成的，说明缓存生效了。</p>
<h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><p>Dubbo通过负载均衡和集中容错策略可以支持我们来自由的扩展我们的服务。假定我们使用zookeeper来做我们管理服务的集群。服务提供者在zookeeper上注册服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt;</div></pre></td></tr></table></figure>
<p>为了引入使用以上的注册方式，需要引入zookeeper的相关依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;3.4.11&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.101tec&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;0.10&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><ul>
<li>随机负载均衡<ul>
<li>随机，按照权重设置随机概率</li>
<li>在一个截面上碰撞的概率高，单调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
</ul>
</li>
<li>轮询负载均衡<ul>
<li>按公约后的权重设置轮询比率。</li>
<li>存在慢的提供者累积请求的问题，比如第二台机器很慢，当请求调到第二台就卡在那里，时间久了所有请求都卡在第二台机器上。</li>
</ul>
</li>
<li>最少活跃数负载均衡<ul>
<li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li>
<li>使慢的提供者受到更少的请求，因为越慢的提供者的调用前后计数差会越大。</li>
</ul>
</li>
<li>一致性哈希负载均衡<ul>
<li>相同参数的请求总是发到同一个提供者</li>
<li>当某一台提供者挂掉时，原本发往该提供者的请求，基于虚拟节点，平摊到其他提供者，不会引起剧烈变动。</li>
<li>缺醒只对第一个参数哈希，也可以配置<dubbo:parameter key="hash.arguments" value="0,1">修改。</dubbo:parameter></li>
<li>缺醒使用160份虚拟节点，如果要修改，请配置<dubbo:parameter key="hash.nodes" value="320"></dubbo:parameter></li>
</ul>
</li>
</ul>
<p>配置：</p>
<ul>
<li><p>服务端</p>
<ul>
<li>服务级别<code>&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</code></li>
<li>方法级别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:service interface=&quot;...&quot;&gt;</div><div class="line">    &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;</div><div class="line">&lt;/dubbo:service&gt;&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>客户端</p>
<ul>
<li>服务级别<code>&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</code></li>
<li>方法级别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">      &lt;dubbo:reference interface=&quot;...&quot;&gt;</div><div class="line">          &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;</div><div class="line">      &lt;/dubbo:reference&gt;</div><div class="line">      ```    </div><div class="line"></div><div class="line">## 轮询负载均衡举例</div><div class="line"></div><div class="line">假定在一个集群里面存在两这个服务的实现作为服务提供者，请求时采用轮询方式做负载均衡。首先，创建服务提供者：</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>Before<br>public void initRemote() {<br>    ExecutorService executorService = Executors.newFixedThreadPool(2);<br>    executorService.submit(() -&gt; {<br>        ClassPathXmlApplicationContext remoteContext<br>          = new ClassPathXmlApplicationContext(“cluster/provider-app-default.xml”);<br>        remoteContext.start();<br>    });<br>    executorService.submit(() -&gt; {<br>        ClassPathXmlApplicationContext backupRemoteContext<br>          = new ClassPathXmlApplicationContext(“cluster/provider-app-special.xml”);<br>        backupRemoteContext.start();<br>    });<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后我们有一个标准的高速服务提供者，可以立即给出相应结果，一个低速服务提供者，每个响应需要等候5s。执行六次请求，此时采用轮询的负载均衡侧率，则期待的是平均相应时间为2.5s。</div></pre></td></tr></table></figure></p>
<p>@Test<br>public void givenProviderCluster_whenConsumerSaysHi_thenResponseBalanced() {<br>    ClassPathXmlApplicationContext localContext<br>      = new ClassPathXmlApplicationContext(“cluster/consumer-app-lb.xml”);<br>    localContext.start();<br>    GreetingsService greetingsService<br>      = (GreetingsService) localContext.getBean(“greetingsService”);</p>
<pre><code>List&lt;Long&gt; elapseList = new ArrayList&lt;&gt;(6);
for (int i = 0; i &lt; 6; i++) {
    long current = System.currentTimeMillis();
    String hiMessage = greetingsService.sayHi(&quot;baeldung&quot;);
    assertNotNull(hiMessage);
    elapseList.add(System.currentTimeMillis() - current);
}

OptionalDouble avgElapse = elapseList
  .stream()
  .mapToLong(e -&gt; e)
  .average();
assertTrue(avgElapse.isPresent());
assertTrue(avgElapse.getAsDouble() &gt; 2500.0);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">同时，动态负载均衡是支持的，下面的例子说明这一点，采用的是轮询的负载均衡策略，当新的服务注册时候，消费者会选择新的服务。低俗的服务提供者在系统启动后2s注册。</div></pre></td></tr></table></figure></p>
<p>@Before<br>public void initRemote() {<br>    ExecutorService executorService = Executors.newFixedThreadPool(2);<br>    executorService.submit(() -&gt; {<br>        ClassPathXmlApplicationContext remoteContext<br>          = new ClassPathXmlApplicationContext(“cluster/provider-app-default.xml”);<br>        remoteContext.start();<br>    });<br>    executorService.submit(() -&gt; {<br>        SECONDS.sleep(2);<br>        ClassPathXmlApplicationContext backupRemoteContext<br>          = new ClassPathXmlApplicationContext(“cluster/provider-app-special.xml”);<br>        backupRemoteContext.start();<br>        return null;<br>    });<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">服务提供者此时每秒调用一次服务，6次之后，我们期望平均响应时间大于1.6s。</div></pre></td></tr></table></figure></p>
<p>@Test<br>public void givenProviderCluster_whenConsumerSaysHi_thenResponseBalanced()<br>  throws InterruptedException {<br>    ClassPathXmlApplicationContext localContext<br>      = new ClassPathXmlApplicationContext(“cluster/consumer-app-lb.xml”);<br>    localContext.start();<br>    GreetingsService greetingsService<br>      = (GreetingsService) localContext.getBean(“greetingsService”);<br>    List<long> elapseList = new ArrayList&lt;&gt;(6);<br>    for (int i = 0; i &lt; 6; i++) {<br>        long current = System.currentTimeMillis();<br>        String hiMessage = greetingsService.sayHi(“baeldung”);<br>        assertNotNull(hiMessage);<br>        elapseList.add(System.currentTimeMillis() - current);<br>        SECONDS.sleep(1);<br>    }</long></p>
<pre><code>OptionalDouble avgElapse = elapseList
  .stream()
  .mapToLong(e -&gt; e)
  .average();

assertTrue(avgElapse.isPresent());
assertTrue(avgElapse.getAsDouble() &gt; 1666.0);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">*负载均衡在服务提供者和服务消费者都可以使用。*</div><div class="line"></div><div class="line"># 集群容错</div><div class="line"></div><div class="line">Dubbo支持多种容错机制，默认为failover重试。</div><div class="line"></div><div class="line">![Alt text](/img/Dubbo-4.png)</div><div class="line"></div><div class="line">## 各节点的关系</div><div class="line"></div><div class="line">* Invoke是Provider的一个可调用Service的抽象，Invoker封装了Provider地址及Service接口信息。</div><div class="line">* Directory代表多个Invoker，List&lt;Invoker&gt;，值可以动态变化，比如注册中心推送变更</div><div class="line">* Cluster将Director中的多个Invoker封装成一个Invoker，对上层逃命，伪装过程包含了容错逻辑，如果失败后，重试另一个</div><div class="line">* Route负责从多个Invoker中按照路由规则选出子集没比如读写分离，应用隔离等</div><div class="line">* loadbalance负责从多个Invoker中选出一个具体用于本地调用，选的过程中包含了负载均衡该算法。</div><div class="line"></div><div class="line">## 集群容错模式</div><div class="line"></div><div class="line">* fail-over</div><div class="line">    * 当一个消费者获取一个服务失败的时候，会尝试访问集群中其他的服务提供者</div><div class="line">    * 通常用于读操作，但是重试会带来更长的延迟</div><div class="line">    * 可通过retries=“2”来设置重试次数，其中第一次不包含在内。    </div><div class="line">* fail-safe</div><div class="line">    * 失败安全，出现异常时，直接忽略</div><div class="line">    * 通常用于写入审计日志等操作</div><div class="line">* fail-fast</div><div class="line">    * 快速失败，只发起一次调用，失败立即报错</div><div class="line">    * 通常用于非幂等性的写操作，比如新增记录</div><div class="line">* fail-back</div><div class="line">    * 失败自动恢复，后台记录失败请求，定时重发</div><div class="line">    * 通常用于消息通知操作</div><div class="line">* forking</div><div class="line">    * 并行调度多个服务器，只要一个成功及返回。</div><div class="line">    * 通常实时性要求比较高的读操作，但是需要浪费很多服务资源，可以通过forks=&quot;2&quot;来设置最大并行数</div><div class="line">* broadcast</div><div class="line">    * 广播调用所有的提供者，逐个调用，任意一台报错则报错。</div><div class="line">    * 通常用于通知所有提供者更新缓存或者日志等本地资源信息。</div><div class="line"></div><div class="line">## 集群模式配置</div></pre></td></tr></table></figure></p>
<p>//服务端</p>
<p><dubbo:service cluster="failsafe"><br>//客户端</dubbo:service></p>
<p><dubbo:reference cluster="failsafe"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 线性模型</div><div class="line"></div><div class="line">![Alt text](/img/Dubbo-5.png)</div><div class="line"></div><div class="line">* 如果事件的处理逻辑能够迅速完成，并且不会发起新的IO请求，比如只是在内存中标记个标识，则直接在IO线程上处理更快，因为这样减少了线程池的调度。</div><div class="line">* 如果事件处理逻辑较慢，或者需要发起新的IO请求，比如需要查询数据库，则必须派发到线程池，否则IO线程阻塞，将导致不能接受其他请求。</div><div class="line">* 如果用IO线程处理事件，又在事件处理过程中发起新的IO请求，比如在链接事件中发起登录请求，会报可能发生死锁异常。</div><div class="line"></div><div class="line">针对不同的场景，需要设定相应的派发侧率和不同的线程池：</div></pre></td></tr></table></figure></dubbo:reference></p>
<p><dubbo:protocol name="dubbo" dispatcher="all" threadpool="fixed" threads="100"><br>```</dubbo:protocol></p>
<h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><ul>
<li>all，所有消息都派发到线程池，包括请求，相应，连接事件，断开事件，心跳等。</li>
<li>direct，所有消息都不派发到线程池，全部在IO线程上直接执行</li>
<li>message，只有请求相应消息派发到线程池，其他直接在IO线程执行</li>
<li>execution，只将请求消息派发到线程池，其他直接在IO线程执行</li>
<li>connection，在IO线程上，将连接断开事件放入队列，顺序执行，其他消息派发到线程池</li>
</ul>
<h2 id="threadPool"><a href="#threadPool" class="headerlink" title="threadPool"></a>threadPool</h2><ul>
<li>fixed，固定大小线程池，启动时创建线程，不关闭，一致持有，缺省</li>
<li>cached，缓存线程池，线程空闲一分钟自动删除，需要时创建</li>
<li>limited，可伸缩性线程池，单线程池中的线程数只会增长不会收缩，避免收缩带来的性能问题。</li>
<li>eager，优先创建worker线程池，当任务数量大于corePoolSize但小于maximumPoolSize时，优先创建Worker来处理任务。当任务数量大于maximumpoolSize时，将任务放入阻塞队列，阻塞队列充满时抛出RejectedExecutionException。</li>
</ul>
<h1 id="客户端和服务端直连"><a href="#客户端和服务端直连" class="headerlink" title="客户端和服务端直连"></a>客户端和服务端直连</h1><p>测试过程中，可以绕过注册中心来直接连接，此时会忽略注册中心的提供者列表，A接口配置点对点，不影响B接口从注册中心获取列表。</p>
<p>配置方法：</p>
<ul>
<li><p>XML：<code>&lt;dubbo:reference id=&quot;xxxService&quot; interface=&quot;com.alibaba.xxx.XxxService&quot; url=&quot;dubbo://localhost:20890&quot; /&gt;</code></p>
</li>
<li><p>JVM：<code>java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890</code></p>
</li>
<li><p>properties: <code>com.alibaba.xxx.XxxService=dubbo://localhost:20890</code></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/16/Java网络编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/16/Java网络编程/" itemprop="url">Java网络编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T10:57:16+08:00">
                2018-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络编程中的两个主要问题"><a href="#网络编程中的两个主要问题" class="headerlink" title="网络编程中的两个主要问题"></a>网络编程中的两个主要问题</h1><ul>
<li>如何准确的定位网络上的一台或者多台主机</li>
</ul>
<p>TCP/IP协议中IP协议主要负责网络主机的定位，数据传输的路由，可以由IP地址唯一的确定Internet上的一台主机。</p>
<ul>
<li>找到主机后如何进行可靠高效的数据传输</li>
</ul>
<p>TCP层提供面向应用的可靠传输（TCP） 或者非可靠的UDP数据传输机制。目前比较流行的网络编程模型为C/S架构，也就是通信一方作为服务器等待客户提出请求并给予相应，客户端在需要服务时向服务器提出申请。服务器一般作为守护进程始终执行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应客户，同时自己继续监听服务端口，使后来的客户也能及时得到服务。</p>
<h1 id="TCP协议和UDP协议"><a href="#TCP协议和UDP协议" class="headerlink" title="TCP协议和UDP协议"></a>TCP协议和UDP协议</h1><p>TCP：Transfer Control Protocol的简称，是一种面向连接的可靠传输协议。通过TCP协议传输得到的是一个顺序的无差错的数据流，发送方和接收方的成对的连个socket必须建立连接，以便在TCP协议的基础上进行通信。</p>
<p>UDP：User Datagram Protocol的简称，是一种无连接的协议。每个数据报都是一个独立的消息，包括完整的源地址或目的地址，在网络上以任何可能的路径进行传送，能否到达目的地以及到达的时间都不确定。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">UDP</th>
<th style="text-align:right">TCP</th>
</tr>
</thead>
<tbody>
<tr>
<td>连接性</td>
<td style="text-align:center">无连接</td>
<td style="text-align:right">面向连接</td>
</tr>
<tr>
<td>传输数据大小</td>
<td style="text-align:center">大小有限制，64KB以内</td>
<td style="text-align:right">统一格式数据传输</td>
</tr>
<tr>
<td>可靠性</td>
<td style="text-align:center">不可靠，不保证到达</td>
<td style="text-align:right">可靠协议</td>
</tr>
<tr>
<td>应用</td>
<td style="text-align:center">Telnet/FTP</td>
<td style="text-align:right">视频会议</td>
</tr>
</tbody>
</table>
<h1 id="基于Socket的Java网络编程"><a href="#基于Socket的Java网络编程" class="headerlink" title="基于Socket的Java网络编程"></a>基于Socket的Java网络编程</h1><p>网络上两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端成为一个Socket。Socket通常用来实现客户方和服务端的链接。一个Socket由一个IP和一个PROT唯一确定。Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。</p>
<h2 id="Socket通信流程"><a href="#Socket通信流程" class="headerlink" title="Socket通信流程"></a>Socket通信流程</h2><ol>
<li>Server端监听某个端口是否有连接请求</li>
<li>Client端相Server端发送Connect请求</li>
<li>Server端相Client端发送Accept消息，建立连接。</li>
<li>Server端和Client端都可以通过Send，Write等方式通信。</li>
<li>关闭Socket</li>
</ol>
<h2 id="创建一个Socket"><a href="#创建一个Socket" class="headerlink" title="创建一个Socket"></a>创建一个Socket</h2><p>Java中java.net包中提供了两个类，Socket，ServerSocket，分别表示双向连接的客户端和服务端。</p>
<p>客户端类的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public Socket(String host, int port)</div><div class="line">    throws UnknownHostException, IOException</div><div class="line">&#123;</div><div class="line">    this(host != null ? new InetSocketAddress(host, port) :</div><div class="line">         new InetSocketAddress(InetAddress.getByName(null), port),</div><div class="line">         (SocketAddress) null, true);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>服务端的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public ServerSocket(int port) throws IOException &#123;</div><div class="line">    this(port, 50, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="简单的Client-Server程序"><a href="#简单的Client-Server程序" class="headerlink" title="简单的Client/Server程序"></a>简单的Client/Server程序</h2><hr>
<p>未完</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/avatar.gif"
              alt="cdx" />
          
            <p class="site-author-name" itemprop="name">cdx</p>
            <p class="site-description motion-element" itemprop="description">Be a better man!</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">65</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/cdx0312" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:cdxu0312@outlook.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cdx</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
