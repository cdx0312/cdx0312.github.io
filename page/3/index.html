<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Be a better man!">
<meta property="og:type" content="website">
<meta property="og:title" content="小黄">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="小黄">
<meta property="og:description" content="Be a better man!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小黄">
<meta name="twitter:description" content="Be a better man!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>小黄</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小黄</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">黄小黄的幸福生活！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-java">
          <a href="/Java/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Java
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/04/JDK源码之LinkedHashMap源码剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/04/JDK源码之LinkedHashMap源码剖析/" itemprop="url">JDK源码之LinkedHashMap源码剖析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-04T11:59:10+08:00">
                2018-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LinkedHashMap继承了HashMap类并实现了Map接口，其内部维护了一个双向链表，在每次插入数据或者修改访问数据，在双链表中会存在相应的增删高的操作，从而实现将无序的HashMap通过双链表将其管理为有序状态的map类型。</p>
<h1 id="内部节点"><a href="#内部节点" class="headerlink" title="内部节点"></a>内部节点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</div><div class="line">    Entry&lt;K,V&gt; before, after;</div><div class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        super(hash, key, value, next);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LinkedHashMap中的节点Entry继承了HashMap中内部类Node，为其添加两个链表以实现节点之间的有序存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//Hashmap中的节点</div><div class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">        final int hash;</div><div class="line">        final K key;</div><div class="line">        V value;</div><div class="line">        Node&lt;K,V&gt; next;</div><div class="line"></div><div class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">            this.hash = hash;</div><div class="line">            this.key = key;</div><div class="line">            this.value = value;</div><div class="line">            this.next = next;</div><div class="line">        &#125;</div><div class="line">        //omit</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>同时存在两个成员变量，head和tail指向双链表的首尾两端，以及一个accessOrder，accessOrder指定双链表的迭代顺序，如果其为true，则采用访问顺序，如果为false，则采用插入顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * The head (eldest) of the doubly linked list.</div><div class="line"> */</div><div class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The tail (youngest) of the doubly linked list.</div><div class="line"> */</div><div class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</div><div class="line">/**</div><div class="line"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</div><div class="line"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</div><div class="line"> *</div><div class="line"> * @serial</div><div class="line"> */</div><div class="line">final boolean accessOrder;</div></pre></td></tr></table></figure>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 构造一个按照插入顺序迭代的Hashmap对象，并指定初始容量和扩展因子</div><div class="line"> * @param  initialCapacity the initial capacity</div><div class="line"> * @param  loadFactor      the load factor</div><div class="line"> * @throws IllegalArgumentException if the initial capacity is negative</div><div class="line"> *         or the load factor is nonpositive</div><div class="line"> */</div><div class="line">public LinkedHashMap(int initialCapacity, float loadFactor) &#123;</div><div class="line">    super(initialCapacity, loadFactor);</div><div class="line">    accessOrder = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 构造一个按照插入顺序迭代的Hashmap对象，并指定初始容量，使用默认的扩展因子0.75</div><div class="line"> * @param  initialCapacity the initial capacity</div><div class="line"> * @throws IllegalArgumentException if the initial capacity is negative</div><div class="line"> */</div><div class="line">public LinkedHashMap(int initialCapacity) &#123;</div><div class="line">    super(initialCapacity);</div><div class="line">    accessOrder = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 构造一个按照插入顺序迭代的Hashmap对象，使用默认的初始容量16和扩展因子0.75</div><div class="line"> */</div><div class="line">public LinkedHashMap() &#123;</div><div class="line">    super();</div><div class="line">    accessOrder = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 通过一个map构造一个按照插入顺序迭代的Hashmap对象，</div><div class="line"> * 初始容量为大于map的值,扩展因子0.75</div><div class="line"> *</div><div class="line"> * @param  m the map whose mappings are to be placed in this map</div><div class="line"> * @throws NullPointerException if the specified map is null</div><div class="line"> */</div><div class="line">public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</div><div class="line">    super();</div><div class="line">    accessOrder = false;</div><div class="line">    //批量插入一个map到本集合中</div><div class="line">    putMapEntries(m, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 构造一个按照插入顺序迭代的Hashmap对象，并指定初始容量和扩展因子，和迭代顺序</div><div class="line"> *</div><div class="line"> * @param  initialCapacity the initial capacity</div><div class="line"> * @param  loadFactor      the load factor</div><div class="line"> * @param  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for</div><div class="line"> *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</div><div class="line"> * @throws IllegalArgumentException if the initial capacity is negative</div><div class="line"> *         or the load factor is nonpositive</div><div class="line"> */</div><div class="line">public LinkedHashMap(int initialCapacity,</div><div class="line">                     float loadFactor,</div><div class="line">                     boolean accessOrder) &#123;</div><div class="line">    super(initialCapacity, loadFactor);</div><div class="line">    this.accessOrder = accessOrder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h1><ul>
<li>LinkedHashMap添加节点采用的是HashMap中的put方法。在putVal方法中调用了newNode()方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">                   boolean evict) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">        if ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">            n = (tab = resize()).length;</div><div class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</div><div class="line">            tab[i] = newNode(hash, key, value, null);</div><div class="line">        else &#123;</div><div class="line">          //omit...</div><div class="line">        &#125;</div><div class="line">        ++modCount;</div><div class="line">        if (++size &gt; threshold)</div><div class="line">            resize();</div><div class="line">        afterNodeInsertion(evict);</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>LinkedHashMap重写了构建节点newNode()方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">    linkNodeLast(p);</div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>每次构建新节点时，通过linkNodeLast(p)将新节点链接在内部双向链表的尾部。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// link at the end of list</div><div class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</div><div class="line">    tail = p;</div><div class="line">    if (last == null)</div><div class="line">        head = p;</div><div class="line">    else &#123;</div><div class="line">        p.before = last;</div><div class="line">        last.after = p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>putVal方法中最后调用了afterNodeInsertion(evict),很容易发现，在HashMap中这个方法是空的，而LinkedHashMap中重写了这些方法，用于对相应操作之后对双链表的修改。如果是按照</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// hashMao中的预留函数</div><div class="line">// Callbacks to allow LinkedHashMap post-actions</div><div class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</div><div class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</div><div class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</div><div class="line">    //判断是否需要移除最老的值</div><div class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;</div><div class="line">        K key = first.key;</div><div class="line">        removeNode(hash(key), key, null, false, true);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//默认是不移除的，但是如果要实现缓存，需要删除最老的值。实现LRUCache需要重写该方法</div><div class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Demo展示：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class LinkedHashMapDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;();</div><div class="line">        for (int i = 1; i &lt; 7; i++) &#123;</div><div class="line">            map.put(i, &quot;&quot; + i);</div><div class="line">            System.out.println(map.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;1=1&#125;</div><div class="line">&#123;1=1, 2=2&#125;</div><div class="line">&#123;1=1, 2=2, 3=3&#125;</div><div class="line">&#123;1=1, 2=2, 3=3, 4=4&#125;</div><div class="line">&#123;1=1, 2=2, 3=3, 4=4, 5=5&#125;</div><div class="line">&#123;1=1, 2=2, 3=3, 4=4, 5=5, 6=6&#125;</div></pre></td></tr></table></figure>
<h1 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h1><ul>
<li>LinkedHashMap没有重写删除节点，调用HashMap中的删除方法。删除之后通过调用重写之后的afterNodeRemoveal()这个回调方法来对双链表进行调整。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//删除节点e时，需要相应调整双链表</div><div class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink</div><div class="line">   LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">       (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">   //链表节点中只有e一个节点</div><div class="line">   p.before = p.after = null;</div><div class="line">   //e为头节点</div><div class="line">   if (b == null)</div><div class="line">       head = a;</div><div class="line">   else</div><div class="line">       b.after = a;</div><div class="line">   //e为尾节点</div><div class="line">   if (a == null)</div><div class="line">       tail = b;</div><div class="line">   else</div><div class="line">       a.before = b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Demo展示</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class LinkedHashMapDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;();</div><div class="line">        for (int i = 1; i &lt; 7; i++) &#123;</div><div class="line">            map.put(i, &quot;&quot; + i);</div><div class="line">            System.out.println(map.toString());</div><div class="line">        &#125;</div><div class="line">        map.remove(6);</div><div class="line">        System.out.println(map.toString());</div><div class="line">        map.remove(3);</div><div class="line">        System.out.println(map.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;1=1, 2=2&#125;</div><div class="line">&#123;1=1, 2=2, 3=3&#125;</div><div class="line">&#123;1=1, 2=2, 3=3, 4=4&#125;</div><div class="line">&#123;1=1, 2=2, 3=3, 4=4, 5=5&#125;</div><div class="line">&#123;1=1, 2=2, 3=3, 4=4, 5=5, 6=6&#125;</div><div class="line">&#123;1=1, 2=2, 3=3, 4=4, 5=5&#125;</div><div class="line">&#123;1=1, 2=2, 4=4, 5=5&#125;</div></pre></td></tr></table></figure>
<h1 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h1><ul>
<li>没错，LinkedHashMap重写了get方法及getOrDefaul方法,比较简单，就是查找，查找完之后，如果迭代顺序采用是访问顺序，则需要调用函数afterNodeAccess来调整双向链表。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    if ((e = getNode(hash(key), key)) == null)</div><div class="line">        return null;</div><div class="line">    if (accessOrder)</div><div class="line">        afterNodeAccess(e);</div><div class="line">    return e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public V getOrDefault(Object key, V defaultValue) &#123;</div><div class="line">   Node&lt;K,V&gt; e;</div><div class="line">   if ((e = getNode(hash(key), key)) == null)</div><div class="line">       return defaultValue;</div><div class="line">   if (accessOrder)</div><div class="line">       afterNodeAccess(e);</div><div class="line">   return e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//将访问过的节点移动至内部的双向链表的尾部。</div><div class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</div><div class="line">    if (accessOrder &amp;&amp; (last = tail) != e) &#123;</div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">        p.after = null;</div><div class="line">        if (b == null)</div><div class="line">            head = a;</div><div class="line">        else</div><div class="line">            b.after = a;</div><div class="line">        if (a != null)</div><div class="line">            a.before = b;</div><div class="line">        else</div><div class="line">            last = b;</div><div class="line">        if (last == null)</div><div class="line">            head = p;</div><div class="line">        else &#123;</div><div class="line">            p.before = last;</div><div class="line">            last.after = p;</div><div class="line">        &#125;</div><div class="line">        tail = p;</div><div class="line">        ++modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>Demo展示</p>
<ul>
<li><p>按照插入顺序输出</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class LinkedHashMapDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;();</div><div class="line">        for (int i = 1; i &lt; 7; i++) &#123;</div><div class="line">            map.put(i, &quot;&quot; + i);</div><div class="line">        &#125;</div><div class="line">        System.out.println(map.toString());</div><div class="line">        map.get(3);</div><div class="line">        map.get(6);</div><div class="line">        System.out.println(map);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;1=1, 2=2, 3=3, 4=4, 5=5, 6=6&#125;</div><div class="line">&#123;1=1, 2=2, 3=3, 4=4, 5=5, 6=6&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>按照访问顺序输出，accessOrder=true</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class LinkedHashMapDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Map&lt;Integer,String&gt; orderMap = new LinkedHashMap&lt;Integer, String &gt;(16,0.75f, true);</div><div class="line">        for (int i = 1; i &lt; 7; i++) &#123;</div><div class="line">            orderMap.put(i, &quot;&quot; + i);</div><div class="line">        &#125;</div><div class="line">        System.out.println(orderMap.toString());</div><div class="line">        orderMap.get(3);</div><div class="line">        System.out.println(orderMap);</div><div class="line">        orderMap.get(1);</div><div class="line">        System.out.println(orderMap);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;1=1, 2=2, 3=3, 4=4, 5=5, 6=6&#125;</div><div class="line">&#123;1=1, 2=2, 4=4, 5=5, 6=6, 3=3&#125;</div><div class="line">&#123;2=2, 4=4, 5=5, 6=6, 3=3, 1=1&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="containsValue方法"><a href="#containsValue方法" class="headerlink" title="containsValue方法"></a>containsValue方法</h2><p>HashMap中的containsValue方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public boolean containsValue(Object value) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; V v;</div><div class="line">    if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;</div><div class="line">        for (int i = 0; i &lt; tab.length; ++i) &#123;</div><div class="line">            for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</div><div class="line">                if ((v = e.value) == value ||</div><div class="line">                    (value != null &amp;&amp; value.equals(v)))</div><div class="line">                    return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LinkedHashMap中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public boolean containsValue(Object value) &#123;</div><div class="line">    for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after) &#123;</div><div class="line">        V v = e.value;</div><div class="line">        if (v == value || (value != null &amp;&amp; value.equals(v)))</div><div class="line">            return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，后者的实现更加的高效。</p>
<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>LinkedHashMap中重写了entrySet()方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</div><div class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</div><div class="line">    return (es = entrySet) == null ? (entrySet = new LinkedEntrySet()) : es;</div><div class="line">&#125;</div><div class="line"></div><div class="line">final class LinkedEntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</div><div class="line">    public final int size()                 &#123; return size; &#125;</div><div class="line">    public final void clear()               &#123; LinkedHashMap.this.clear(); &#125;</div><div class="line">    public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</div><div class="line">        return new LinkedEntryIterator();</div><div class="line">    &#125;</div><div class="line">    public final boolean contains(Object o) &#123;</div><div class="line">        if (!(o instanceof Map.Entry))</div><div class="line">            return false;</div><div class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</div><div class="line">        Object key = e.getKey();</div><div class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</div><div class="line">        return candidate != null &amp;&amp; candidate.equals(e);</div><div class="line">    &#125;</div><div class="line">    public final boolean remove(Object o) &#123;</div><div class="line">        if (o instanceof Map.Entry) &#123;</div><div class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</div><div class="line">            Object key = e.getKey();</div><div class="line">            Object value = e.getValue();</div><div class="line">            return removeNode(hash(key), key, value, true, true) != null;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</div><div class="line">        return Spliterators.spliterator(this, Spliterator.SIZED |</div><div class="line">                                        Spliterator.ORDERED |</div><div class="line">                                        Spliterator.DISTINCT);</div><div class="line">    &#125;</div><div class="line">    public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;</div><div class="line">        if (action == null)</div><div class="line">            throw new NullPointerException();</div><div class="line">        int mc = modCount;</div><div class="line">        for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after)</div><div class="line">            action.accept(e);</div><div class="line">        if (modCount != mc)</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>重写之后迭代LinkedHashMap就是从内部维护的双链表的表头开始循环输出。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>LinkedHashMap继承HashMap，只需要重写几个方法，来改变其迭代遍历的顺序。同时在插入数据，访问数据，修改数据，会增加双链表上的节点或者调整顺序，来决定迭代时的输出顺序。</li>
<li>相应操作的回调函数，HashMap中有相应的空方法，也就意味着LinkedHashMap只需要重写这几个回调函数，而不用重写插入和删除方法。</li>
<li>LinkedhashMap重写了get方法。</li>
<li>LinkedHashMap优化了containsValue方法，提高其遍历性能。</li>
</ul>
<p>测试代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.util.LinkedHashMap;</div><div class="line">import java.util.Map;</div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/4</div><div class="line"> */</div><div class="line">public class LinkedHashMapDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;();</div><div class="line">        for (int i = 1; i &lt; 7; i++) &#123;</div><div class="line">            map.put(i, &quot;&quot; + i);</div><div class="line">//            System.out.println(map.toString());</div><div class="line">        &#125;</div><div class="line">        System.out.println(map.toString());</div><div class="line">//        map.remove(6);</div><div class="line">//        System.out.println(map.toString());</div><div class="line">//        map.remove(3);</div><div class="line">//        System.out.println(map.toString());</div><div class="line">        map.get(3);</div><div class="line">        map.get(6);</div><div class="line">        System.out.println(map);</div><div class="line"></div><div class="line">        Map&lt;Integer,String&gt; orderMap = new LinkedHashMap&lt;Integer, String &gt;(16,0.75f, true);</div><div class="line">        for (int i = 1; i &lt; 7; i++) &#123;</div><div class="line">            orderMap.put(i, &quot;&quot; + i);</div><div class="line">        &#125;</div><div class="line">        System.out.println(orderMap.toString());</div><div class="line">        orderMap.get(3);</div><div class="line">        System.out.println(orderMap);</div><div class="line">        orderMap.get(1);</div><div class="line">        System.out.println(orderMap);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/03/LRUCache实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/03/LRUCache实现/" itemprop="url">LRUCache的Java实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T21:49:56+08:00">
                2018-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="LRUCache简介"><a href="#LRUCache简介" class="headerlink" title="LRUCache简介"></a>LRUCache简介</h1><p>  没错，面试的时候让我写LRUCache，当时只知道需要一个HashMap和一个链表，但是考虑的问题不全名，也没有考虑到多线程的问题。回来以后学习了下LRUCache的一些Java实现，其实可以套用LinkedHashMap，很多方法都给实现好了，当然也可以使用HashMap+链表，但是后者写起来更加复杂，当时面试的情况，感觉是让我利用LinkedHashMap数据结构。</p>
<ul>
<li>首先缓存的大小是固定的，给缓存分配一个固定的大小。</li>
<li>每次读取缓存都会改变缓存的使用时间，将缓存的存在时间重新刷新。</li>
<li><p>需要在缓存满了后，将最近最久未使用的缓存删除，再添加最新的缓存。</p>
<p>熟悉LinkedHashMap的话可以继承LinkedHashMap来实现LRU缓存。因此需要去查看LinkedHashMap的源码。顺手写了一篇LinkedHashMap源码剖析，写的不是很深刻，不过可以了解其大概的实现方案。</p>
</li>
</ul>
<h1 id="LinkedHashMap实现LRUCache"><a href="#LinkedHashMap实现LRUCache" class="headerlink" title="LinkedHashMap实现LRUCache"></a>LinkedHashMap实现LRUCache</h1><p>LinkedHashMap自身实现了顺序存储，通过其初始化参数accessOrder可以指定其顺序方式，accessOrder为false时，采用默认的存储顺序，按照插入顺序存储，也就是一个FIFO缓冲实现，因为最老的总在最前面。而accessOrder为true时，采用的是访问顺序存储，也就是最近读取的数据放在最前面，最早读取的数据放在最后面。同时还有一个判断是否删除最老数据的方法，默认返回false，而我们需要当前缓存的长度小于链表长度时删除链表头的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">import java.util.LinkedHashMap;</div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/3</div><div class="line"> * 继承LinkedHashMap实现</div><div class="line"> */</div><div class="line">public class LRUCache1&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</div><div class="line">    //缓存的大小</div><div class="line">    private int cacheSize;</div><div class="line"></div><div class="line">    //初始化时保证LinkedHashMap的初始大小要大于CacheSize+1，否则会发生扩容</div><div class="line">    public LRUCache1(int cacheSize) &#123;</div><div class="line">        super(16, 0.75f, true);</div><div class="line">        this.cacheSize = cacheSize;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 重写该方法，当连表的size大于CacheSize时删除最老元素</div><div class="line">     * @param eldest</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</div><div class="line">        return size() &gt; cacheSize;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        for (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123;</div><div class="line">            sb.append(String.format(&quot;%s:%s &quot;, entry.getKey(), entry.getValue()));</div><div class="line">        &#125;</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        LRUCache1&lt;String, String&gt; lruCache1 = new LRUCache1&lt;&gt;(6);</div><div class="line">        for (int i = 0; i &lt; 6; i++) &#123;</div><div class="line">            lruCache1.put(i+&quot;&quot;, i * i + &quot;&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println(lruCache1.toString());</div><div class="line">        lruCache1.put(&quot;s&quot;, &quot;s&quot;);</div><div class="line">        System.out.println(lruCache1.toString());</div><div class="line">        lruCache1.put(&quot;2&quot;, &quot;2222&quot;);</div><div class="line">        System.out.println(lruCache1.toString());</div><div class="line">        lruCache1.get(1+&quot;&quot;);</div><div class="line">        System.out.println(lruCache1.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0:0 1:1 2:4 3:9 4:16 5:25</div><div class="line">1:1 2:4 3:9 4:16 5:25 s:s</div><div class="line">1:1 3:9 4:16 5:25 s:s 2:2222</div><div class="line">3:9 4:16 5:25 s:s 2:2222 1:1</div></pre></td></tr></table></figure>
<ul>
<li>继承实现方式，由于继承了Map接口，在多线程环境中使用时可以使用Collections.synchronizedMap()方法来实现线程安全操作。</li>
</ul>
<h1 id="LinkedHashMap的委托实现"><a href="#LinkedHashMap的委托实现" class="headerlink" title="LinkedHashMap的委托实现"></a>LinkedHashMap的委托实现</h1><p>不采用继承，而是采用委托的机制，需要自己进行线程同步来适应多线程场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">import java.util.LinkedHashMap;</div><div class="line">import java.util.Map;</div><div class="line">import java.util.Set;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/3</div><div class="line"> * LinkedHashMap的委托方法</div><div class="line"> */</div><div class="line">public class LRUCache2&lt;K, V&gt; &#123;</div><div class="line">    //缓存大小</div><div class="line">    private final int CACHE_SIZE;</div><div class="line">    //默认加载因子</div><div class="line">    private final float DEFAULT_LOAD_FACTOR = 0.75f;</div><div class="line">    //缓存容器</div><div class="line">    private LinkedHashMap&lt;K, V&gt; map;</div><div class="line"></div><div class="line">    //初始化过程中,传入缓存的大小，根据缓存大小和默认factor来计算</div><div class="line">    // LinkedHashMap的初始容量，确保其不会产生扩容操作。</div><div class="line">    // 从而完成了map容器的初始化内容。</div><div class="line">    public LRUCache2(int cacheSize) &#123;</div><div class="line">        this.CACHE_SIZE = cacheSize;</div><div class="line">        int capacity = (int)Math.ceil(CACHE_SIZE / DEFAULT_LOAD_FACTOR) + 1;</div><div class="line">        map = new LinkedHashMap&lt;K,V&gt;(capacity, DEFAULT_LOAD_FACTOR, true) &#123;</div><div class="line">            @Override</div><div class="line">            protected boolean removeEldestEntry(Map.Entry eldest) &#123;</div><div class="line">                return size() &gt; CACHE_SIZE;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 多线程put方法，需要加锁</div><div class="line">     * @param key</div><div class="line">     * @param value</div><div class="line">     */</div><div class="line">    public synchronized void put (K key, V value) &#123;</div><div class="line">        map.put(key, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 多线程get方法，需要加锁</div><div class="line">     * @param key</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public synchronized V get(K key) &#123;</div><div class="line">        return map.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 多线程remove方法，需要加锁</div><div class="line">     * @param key</div><div class="line">     */</div><div class="line">    public synchronized void remove(K key) &#123;</div><div class="line">        map.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 多线程getAll方法，需要加锁</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public synchronized Set&lt;Map.Entry&lt;K, V&gt;&gt; getAll() &#123;</div><div class="line">        return map.entrySet();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 多线程size方法，需要加锁</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public synchronized int size() &#123;</div><div class="line">        return map.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 多线程clear方法，需要加锁</div><div class="line">     */</div><div class="line">    public synchronized void clear() &#123;</div><div class="line">        map.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        for (Map.Entry entry : map.entrySet()) &#123;</div><div class="line">            sb.append(String.format(&quot; %s:%s &quot;, entry.getKey(), entry.getValue()));</div><div class="line">        &#125;</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        LRUCache2&lt;Integer, String&gt; lruCache2 = new LRUCache2&lt;&gt;(5);</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            lruCache2.put(i,&quot;&quot; + i);</div><div class="line">        &#125;</div><div class="line">        System.out.println(lruCache2.toString());</div><div class="line">        lruCache2.put(5,&quot;5&quot;);</div><div class="line">        System.out.println(lruCache2.toString());</div><div class="line">        lruCache2.get(2);</div><div class="line">        System.out.println(lruCache2.toString());</div><div class="line">        lruCache2.put(6,&quot;6&quot;);</div><div class="line">        System.out.println(lruCache2.toString());</div><div class="line">        lruCache2.remove(4);</div><div class="line">        System.out.println(lruCache2.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1:1  2:2  3:3  4:4  5:5</div><div class="line">1:1  3:3  4:4  5:5  2:2</div><div class="line">3:3  4:4  5:5  2:2  6:6</div><div class="line">3:3  5:5  2:2  6:6</div></pre></td></tr></table></figure>
<h1 id="LRU-Cache的链表-HashMap实现"><a href="#LRU-Cache的链表-HashMap实现" class="headerlink" title="LRU Cache的链表+HashMap实现"></a>LRU Cache的链表+HashMap实现</h1><p>该方法可以理解为手动实现一个LinkedHashMap，同时需要自己处理所线程的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/3</div><div class="line"> * 链表+HashMap实现</div><div class="line"> */</div><div class="line">public class LRUCache3&lt;K, V&gt; &#123;</div><div class="line">    //缓存容量</div><div class="line">    private final int CACHE_SIZE;</div><div class="line">    //链表头</div><div class="line">    private Entry head;</div><div class="line">    //链表尾</div><div class="line">    private Entry tail;</div><div class="line">    //HashMap容器</div><div class="line">    private HashMap&lt;K, Entry&lt;K, V&gt;&gt; hashMap;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化HashMap容器和cacheSize</div><div class="line">     * @param cacheSize 容量</div><div class="line">     */</div><div class="line">    public LRUCache3(int cacheSize) &#123;</div><div class="line">        this.CACHE_SIZE = cacheSize;</div><div class="line">        hashMap = new HashMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * put方法，加锁</div><div class="line">     * @param key</div><div class="line">     * @param value</div><div class="line">     */</div><div class="line">    public synchronized void put (K key, V value) &#123;</div><div class="line">        Entry entry = getEntry(key);</div><div class="line">        //hashmap中不存在key对应的entry时，新增</div><div class="line">        if (entry == null) &#123;</div><div class="line">            //判断是否需要删除最老的节点</div><div class="line">            if (hashMap.size() &gt;= CACHE_SIZE) &#123;</div><div class="line">                hashMap.remove(tail.key);</div><div class="line">                removeLast();</div><div class="line">            &#125;</div><div class="line">            entry = new Entry();</div><div class="line">            entry.key = key;</div><div class="line">        &#125;</div><div class="line">        //修改</div><div class="line">        entry.value = value;</div><div class="line">        moveToFirst(entry);</div><div class="line">        hashMap.put(key, entry);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * get方法，多线程加锁</div><div class="line">     * @param key</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public synchronized V get(K key) &#123;</div><div class="line">        Entry&lt;K, V&gt; entry = hashMap.get(key);</div><div class="line">        if (entry == null)</div><div class="line">            return null;</div><div class="line">        moveToFirst(entry);</div><div class="line">        return entry.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除</div><div class="line">     * @param key</div><div class="line">     */</div><div class="line">    public synchronized void remove(K key) &#123;</div><div class="line">        Entry entry = getEntry(key);</div><div class="line">        //从链表中删除</div><div class="line">        if (entry != null) &#123;</div><div class="line">            if (entry.pre != null)</div><div class="line">                entry.pre.next = entry.next;</div><div class="line">            if (entry.next != null)</div><div class="line">                entry.next.pre = entry.pre;</div><div class="line">            if (entry == head)</div><div class="line">                head = entry.next;</div><div class="line">            if (entry == tail)</div><div class="line">                tail = entry.pre;</div><div class="line">        &#125;</div><div class="line">        //从HashMap中删除</div><div class="line">        hashMap.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //调整entry到链表头</div><div class="line">    private void moveToFirst(Entry entry) &#123;</div><div class="line">        if (entry == head)</div><div class="line">            return;</div><div class="line">        if (entry.pre!= null)</div><div class="line">            entry.pre.next = entry.next;</div><div class="line">        if (entry.next != null)</div><div class="line">            entry.next.pre = entry.pre;</div><div class="line">        if (head == null || tail == null) &#123;</div><div class="line">            head = tail = entry;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        entry.next = head;</div><div class="line">        head.pre = entry;</div><div class="line">        head = entry;</div><div class="line">        entry.pre = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //移除链表尾的元素</div><div class="line">    private void removeLast() &#123;</div><div class="line">        if (tail != null) &#123;</div><div class="line">            tail = tail.pre;</div><div class="line">            if (tail == null)</div><div class="line">                head = null;</div><div class="line">            else</div><div class="line">                tail.next = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //从hashmap中获取key对应的Entry</div><div class="line">    private Entry&lt;K, V&gt; getEntry(K key) &#123;</div><div class="line">        return hashMap.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        Entry entry = head;</div><div class="line">        while (entry != null) &#123;</div><div class="line">            sb.append(&quot;&quot;).append(entry.key).append(&quot;:&quot;).append(entry.value).append(&quot;  &quot;);</div><div class="line">            entry = entry.next;</div><div class="line">        &#125;</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Entry内部类，双链表实现</div><div class="line">     * @param &lt;K&gt;</div><div class="line">     * @param &lt;V&gt;</div><div class="line">     */</div><div class="line">    class Entry&lt;K,V&gt; &#123;</div><div class="line">        public Entry pre;</div><div class="line">        public Entry next;</div><div class="line">        public K key;</div><div class="line">        public V value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        LRUCache3&lt;Integer, String&gt; lruCache3 = new LRUCache3&lt;&gt;(5);</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            lruCache3.put(i,&quot;&quot; + i);</div><div class="line">        &#125;</div><div class="line">        System.out.println(lruCache3.toString());</div><div class="line">        lruCache3.put(5,&quot;5&quot;);</div><div class="line">        System.out.println(lruCache3.toString());</div><div class="line">        lruCache3.get(2);</div><div class="line">        System.out.println(lruCache3.toString());</div><div class="line">        lruCache3.put(6,&quot;6&quot;);</div><div class="line">        System.out.println(lruCache3.toString());</div><div class="line">        lruCache3.remove(4);</div><div class="line">        System.out.println(lruCache3.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">4:4  3:3  2:2  1:1  0:0  </div><div class="line">5:5  4:4  3:3  2:2  1:1  </div><div class="line">2:2  5:5  4:4  3:3  1:1  </div><div class="line">6:6  2:2  5:5  4:4  3:3  </div><div class="line">6:6  2:2  5:5  3:3</div></pre></td></tr></table></figure>
<h1 id="继承LinkedHashMap实现FIFO缓存"><a href="#继承LinkedHashMap实现FIFO缓存" class="headerlink" title="继承LinkedHashMap实现FIFO缓存"></a>继承LinkedHashMap实现FIFO缓存</h1><p>FIFO缓存只需要继承LinkedHashMap采用其默认的输出顺序就可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">import java.util.LinkedHashMap;</div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/4/3</div><div class="line"> * 继承实现FIFO缓存</div><div class="line"> */</div><div class="line">public class FIFOCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt;&#123;</div><div class="line"></div><div class="line">    //缓存的大小</div><div class="line">    private int cacheSize;</div><div class="line"></div><div class="line">    //初始化时保证LinkedHashMap的初始大小要大于CacheSize+1，否则会发生扩容</div><div class="line">    public FIFOCache(int cacheSize) &#123;</div><div class="line">        super(16, 0.75f);</div><div class="line">        this.cacheSize = cacheSize;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 重写该方法，当连表的size大于CacheSize时删除最新插入的元素</div><div class="line">     * @param eldest</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</div><div class="line">        return size() &gt; cacheSize;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        for (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123;</div><div class="line">            sb.append(String.format(&quot;%s:%s &quot;, entry.getKey(), entry.getValue()));</div><div class="line">        &#125;</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        FIFOCache&lt;String, String&gt; f = new FIFOCache&lt;&gt;(6);</div><div class="line">        for (int i = 0; i &lt; 6; i++) &#123;</div><div class="line">            f.put(i+&quot;&quot;, i * i + &quot;&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println(f.toString());</div><div class="line">        f.put(&quot;s&quot;, &quot;s&quot;);</div><div class="line">        System.out.println(f.toString());</div><div class="line">        f.put(&quot;5&quot;, &quot;2222&quot;);</div><div class="line">        System.out.println(f.toString());</div><div class="line">        f.get(1 + &quot;&quot;);</div><div class="line">        System.out.println(f.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0:0 1:1 2:4 3:9 4:16 5:25</div><div class="line">1:1 2:4 3:9 4:16 5:25 s:s</div><div class="line">1:1 2:4 3:9 4:16 5:2222 s:s</div><div class="line">1:1 2:4 3:9 4:16 5:2222 s:s</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/数据库整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/数据库整理/" itemprop="url">数据库整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-02T21:14:40+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/database/" itemprop="url" rel="index">
                    <span itemprop="name">database</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是存储过程？有什么优缺点？"><a href="#什么是存储过程？有什么优缺点？" class="headerlink" title="什么是存储过程？有什么优缺点？"></a>什么是存储过程？有什么优缺点？</h1><p>存储过程是一些预编译的SQL语句。也就是说存储过程是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（比如对单表的CRUD），然后再给这个代码块取一个名字，在用到这个功能的时候调用就可以。</p>
<ul>
<li>存储过程是一个预编译的代码块，执行效率比较高</li>
<li>一个存储过程替代大量T-SQL语句，可以降低网络通信量，提高通信速率。</li>
<li>可以一定程度上确保数据安全。</li>
</ul>
<h1 id="索引是什么？有什么作用及优缺点？"><a href="#索引是什么？有什么作用及优缺点？" class="headerlink" title="索引是什么？有什么作用及优缺点？"></a>索引是什么？有什么作用及优缺点？</h1><ul>
<li><p>索引是对数据库表中一列或多列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构。</p>
</li>
<li><p>索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</p>
</li>
<li><p>MySQL数据库几个基本的索引类型：</p>
<ul>
<li><p>普通索引：没有任何限制，最基本的索引，创建方式有以下几种</p>
<ul>
<li><p>直接创建索引：<code>CREATE INDEX index_name ON table(column(length))</code></p>
</li>
<li><p>修改表结构的方式添加索引：<code>ALTER TABLE table_name ADD INDEX index_name ON (column(length))</code></p>
</li>
<li><p>创建表的时候创建索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `table` (</div><div class="line">  `id` int(11) NOT NULL AUTO_INCREMENT ,</div><div class="line">  `title` char(255) CHARACTER NOT NULL ,</div><div class="line">  `content` text CHARACTER NULL ,</div><div class="line">  `time` int(10) NULL DEFAULT NULL ,</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  INDEX index_name (title(length))</div><div class="line">  )</div></pre></td></tr></table></figure>
</li>
<li><p>删除索引：<code>DROP INDEX index_name ON table</code></p>
</li>
</ul>
</li>
<li><p>主键索引：一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般在建表的同时创建主键索引：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `table` (</div><div class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</div><div class="line">    `title` char(255) NOT NULL ,</div><div class="line">    PRIMARY KEY (`id`)</div><div class="line">);</div></pre></td></tr></table></figure>
</li>
<li><p>唯一索引：索引列的值必须是唯一的，允许有控制。如果是组合索引，则列的组合必须唯一，创建方式：</p>
<ul>
<li><p>创建唯一索引：<code>CREATE UNIQUE INDEX indexName ON table(column(length))</code></p>
</li>
<li><p>修改表结构的时候指定唯一索引：<code>ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))</code>  </p>
</li>
<li><p>创建表的时候直接指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `table` (</div><div class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</div><div class="line">    `title` char(255) CHARACTER NOT NULL ,</div><div class="line">    `content` text CHARACTER NULL ,</div><div class="line">    `time` int(10) NULL DEFAULT NULL ,</div><div class="line">    UNIQUE indexName (title(length))</div><div class="line">);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>组合索引：多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用，使用组合索引时遵循最左前缀集合：<code>ALTER TABLE</code>table<code>ADD INDEX name_city_age (name,city,age);</code></p>
</li>
<li><p>全文索引:主要用来查找文本中的关键字，而不是直接参与索引中的值的比较。fulltext索引和其他索引不太一样，更像一个搜索引擎，而不是一个简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。全文索引可以在建表，修改表，创建索引中使用，不过目前只有cahr,varchar,text列上可以创建全文索引。而当数据量较大时，将现有数据放入一个没有全局索引的表中，然后再create index创建全文索引，要比先为一张表创建全文索引然后再将数据写入速度快很多。</p>
<ul>
<li><p>创建表时添加全文索引:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `table` (</div><div class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</div><div class="line">    `title` char(255) CHARACTER NOT NULL ,</div><div class="line">    `content` text CHARACTER NULL ,</div><div class="line">    `time` int(10) NULL DEFAULT NULL ,</div><div class="line">    PRIMARY KEY (`id`),</div><div class="line">    FULLTEXT (content)</div><div class="line">);</div></pre></td></tr></table></figure>
</li>
<li><p>修改表结构添加全文索引：<code>ALTER TABLE article ADD FULLTEXT index_content(content)</code></p>
</li>
<li><p>直接创建索引：<code>CREATE FULLTEXT INDEX index_content ON article(content)</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li>索引加快数据库的检索速度</li>
<li>索引降低了插入，删除，修改等维护任务的速度</li>
<li>唯一索引可以确保每一行数据的唯一性</li>
<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</li>
<li>索引需要占物理和数据空间</li>
</ul>
</li>
</ul>
<h1 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h1><ul>
<li>事务是并发控制的基本单位。所谓的事务，它指的是一个操作序列，这些操作要么都执行，要么都不执行。它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据的一致性。</li>
</ul>
<h1 id="数据库的乐观锁AND悲观锁是什么？"><a href="#数据库的乐观锁AND悲观锁是什么？" class="headerlink" title="数据库的乐观锁AND悲观锁是什么？"></a>数据库的乐观锁AND悲观锁是什么？</h1><ul>
<li>数据库管理系统DBMS中并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</li>
<li>乐观锁和悲观锁是并发控制主要采用的技术手段：<ul>
<li>乐观锁：假定不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</li>
</ul>
</li>
</ul>
<h1 id="使用索引查询一定能提高查询的性能吗？为什么？"><a href="#使用索引查询一定能提高查询的性能吗？为什么？" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么？"></a>使用索引查询一定能提高查询的性能吗？为什么？</h1><ul>
<li>通常来说，通过索引查询数据比全表扫描要快。</li>
<li>但是索引需要空间来存储，也需要定期维护。每当有记录在表中增减或者索引列被修改时，索引本身也会被修改。意味着每条记录的insert，delete，update方法将会为此多付出4,5次的磁盘IO。</li>
<li>因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引不一定能提高查询性能。</li>
<li><p>索引范围性查找适用于两种情况：</p>
<ul>
<li>基于一个范围的检索，一般返回结果集小于表中记录的30%。</li>
<li>基于唯一性索引的检索。</li>
</ul>
</li>
</ul>
<h1 id="MySQL数据库索引失效的原因："><a href="#MySQL数据库索引失效的原因：" class="headerlink" title="MySQL数据库索引失效的原因："></a>MySQL数据库索引失效的原因：</h1><ul>
<li>对单字段建立了索引，where条件多字段</li>
<li>建立了联合索引，where条件单字段</li>
<li>对索引列运算，运算包括（+、-、*、/、！、&lt;&gt;、%、like’%_‘、or、in、exist）导致索引失效</li>
<li>类型错误，如字段类型为varchar，where条件用number</li>
<li>对应索引内部函数，这种情况下应该建立基于函数的索引</li>
<li>查询表的效率要比查询索引快的情况</li>
<li>is null索引失效，is not null betree索引生效。</li>
</ul>
<h1 id="说一下drop、delete、truncate的区别："><a href="#说一下drop、delete、truncate的区别：" class="headerlink" title="说一下drop、delete、truncate的区别："></a>说一下drop、delete、truncate的区别：</h1><ul>
<li>delete和truncate只删除表的数据不删除表的结构</li>
<li>速度来说：drop&gt;truncate&gt;delete</li>
<li>delete语句是dml，这个操作会放到rollback segment中，事务提交之后才生效。如果有相应的trigger，执行的时候将被出发。truncate和drop是ddl，操作立即生效，原数据不放到rollback segment中，不能回滚也不能触发trigger。</li>
</ul>
<h1 id="drop、delete、truncate的使用场景？"><a href="#drop、delete、truncate的使用场景？" class="headerlink" title="drop、delete、truncate的使用场景？"></a>drop、delete、truncate的使用场景？</h1><ul>
<li>drop，不再需要一张表时</li>
<li>delete，向删除部分数据行时，并带上where子句</li>
<li>truncate，保留表结构而删除所有数据的时候</li>
</ul>
<h1 id="超键，候选键，主键，外键分别是什么"><a href="#超键，候选键，主键，外键分别是什么" class="headerlink" title="超键，候选键，主键，外键分别是什么"></a>超键，候选键，主键，外键分别是什么</h1><table>
<thead>
<tr>
<th></th>
<th style="text-align:center">GET</th>
</tr>
</thead>
<tbody>
<tr>
<td>超键</td>
<td style="text-align:center">在关系中能唯一标识元组的属性集成为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键</td>
</tr>
<tr>
<td>候选键</td>
<td style="text-align:center">是最小的超键，即没有冗余元素的超键</td>
</tr>
<tr>
<td>主键</td>
<td style="text-align:center">数据库表中对存储数据对象给予唯一和完整标识的数据列或者属性的集合。一个数据列只能有一个主键，且主键的取值不能缺少，即不能为空值（null）</td>
</tr>
<tr>
<td>外键</td>
<td style="text-align:center">在一个表中存在另一个表的主键称为此表的外键</td>
</tr>
</tbody>
</table>
<h1 id="什么是视图？以及视图的使用场景？"><a href="#什么是视图？以及视图的使用场景？" class="headerlink" title="什么是视图？以及视图的使用场景？"></a>什么是视图？以及视图的使用场景？</h1><ul>
<li><p>视图是一张虚拟的表，具有和物理表相同的功能。可以对视图进行CRUD，视图通常是由一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
</li>
<li><p>只暴露部分字段给访问者，所以就建一个虚表，也就是一个视图。</p>
</li>
<li>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表中的差异。</li>
</ul>
<h1 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h1><ul>
<li><p>1NF：数据库表中的字段都是单一属性，不可再分。这个单一属性由基本类型构成，包括整形，实数，字符型，逻辑型，日期型等。</p>
</li>
<li><p>2NF：数据库表中不存在非关键字段对任意候选关键字段的部分依赖（部分依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</p>
</li>
<li><p>3NF：数据表中不存在非关键字段对任一候选关键字段的传递依赖。传递依赖指的数据库中不存在如下依赖关系：关键字段-&gt;非关键字段X-&gt;非关键字段Y</p>
</li>
</ul>
<h1 id="SQL语句总结"><a href="#SQL语句总结" class="headerlink" title="SQL语句总结"></a>SQL语句总结</h1><ol>
<li><p>SELECT：将数据从数据库中的表中取出，<code>SELECT &quot;列名&quot; FROM &quot;表名&quot;</code>。</p>
</li>
<li><p>DISTINCT：去重，在上述 SELECT 关键词后加上一个 DISTINCT 就可以去除选择出来的重复，从而完成求得这个表格中该字段有哪些不同的值的功能。语法为<code>SELECT DISTINCT &quot;列名&quot; FROM &quot;表名&quot;</code>。</p>
</li>
<li><p>WHERE：这个关键词可以帮助我们选择性地获取数据，而不是全取出来。语法为<code>SELECT &quot;列名&quot; FROM &quot;表名&quot; WHERE &quot;条件&quot;</code></p>
</li>
<li><p>AND OR：上例中的 WHERE 指令可以被用来由表格中有条件地选取资料。这个条件可能是简单的，也可能是复杂的。复杂条件是由二或多个简单条件透过 AND 或是 OR 的连接而成。语法为：<code>SELECT &quot;列名&quot;  FROM &quot;表名&quot;  WHERE &quot;简单条件&quot;  {[AND|OR] &quot;简单条件&quot;}+</code></p>
</li>
<li><p>IN：在SQL中，与 WHERE一起使用，我们事先已知道至少一个我们需要的值，而我们将这些知道的值都放入 IN  这个子句。语法为：<code>SELECT &quot;列名&quot;  FROM &quot;表名&quot;  WHERE &quot;列名&quot; IN (&#39;值一&#39;, &#39;值二&#39;, ...)</code>  </p>
</li>
<li><p>BETWEEN：IN 这个指令可以让我们依照一或数个不连续 (discrete)的值的限制之内获取数据，而 BETWEEN 则是让我们可以运用一个范围 (range)获取数据，语法为：<br><code>SELECT &quot;列名&quot;  FROM &quot;表名&quot; WHERE &quot;列名&quot; BETWEEN &#39;值一&#39; AND &#39;值二&#39;</code></p>
</li>
<li><p>LIKE：LIKE 是另一个在 WHERE子句中会用到的指令。LIKE依据一个模式(pattern)来找出我们要的数据。语法为：<br><code>SELECT &quot;列名&quot;  FROM &quot;表名&quot;  WHERE &quot;列名&quot; LIKE {模式}</code></p>
</li>
<li><p>ORDER BY：排序指令。语法为：<code>SELECT &quot;列名&quot;  FROM &quot;表名 [WHERE &quot;条件&quot;] ORDER BY &quot;列名&quot; [ASC, DESC]</code></p>
</li>
<li><p>函数: 函数允许我们能够对这些数字的型态存在的行或者列做运算，包括 AVG (平均)、COUNT (计数)、MAX (最大值)、MIN (最小值)、SUM (总合)。语法为：<code>SELECT &quot;函数名&quot;(&quot;列名&quot;) FROM &quot;表名&quot;</code></p>
</li>
<li><p>COUNT：这个关键词能够帮我我们统计有多少个数据被选出来，语法为：<code>SELECT COUNT(&quot;列名&quot;) FROM &quot;表名&quot;</code></p>
</li>
<li><p>GROUP BY：GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。语法为：<code>SELECT &quot;列1&quot;, SUM(&quot;列2&quot;)  FROM &quot;表名&quot;  GROUP BY &quot;列1&quot;</code></p>
</li>
<li><p>HAVING：该关键词可以帮助我们对函数产生的值来设定条件。语法为：<code>SELECT &quot;；列1&quot;, SUM(&quot;列2&quot;)  FROM &quot;表格名&quot;  GROUP BY &quot;列1&quot;  HAVING (函数条件)</code></p>
</li>
<li><p>ALIAS：我们可以通过ALIAS为列名称和表名称指定别名，语法为：<code>SELECT &quot;表格别名&quot;.&quot;列1&quot; &quot;；列1别名&quot;  FROM &quot;表格名&quot; &quot;表格别名&quot;</code></p>
</li>
</ol>
<ul>
<li>实战，数据库结构如下</li>
</ul>
<p>Student(S#,Sname,Sage,Ssex) 学生表<br>Course(C#,Cname,T#) 课程表<br>SC(S#,C#,score) 成绩表<br>Teacher(T#,Tname) 教师表</p>
<pre><code>1. 查询“001”课程比“002”课程成绩高的所有学生的学号：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT a.S# from (select s#,score from SC where C#=&apos;001&apos;) a,</div><div class="line">(select s#,score from SC where C#=&apos;002&apos;) b</div><div class="line">WHERE a.score &gt; b.score and a.S#=b.S#;</div></pre></td></tr></table></figure>

2. 查询平均成绩大于60分的同学的学号和平均成绩：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT S#, AVG(score)</div><div class="line">FROM SC</div><div class="line">GROUP by S# HAVING AVG(score) &gt; 60;</div></pre></td></tr></table></figure>

3. 查询所有同学的学号、姓名、选课数、总成绩:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select Student.S#, Student.Sname, COUNT(SC.C#), SUM(score)</div><div class="line">from Student left Outer join SC on Student.S#=SC.S#</div><div class="line">GROUP by Student.S#, Sname;</div></pre></td></tr></table></figure>

4. 查询姓“李”的老师的个数:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select COUNT(distinct(Tname))</div><div class="line">from Teacher</div><div class="line">WHERE Tname LIKE &apos;李%&apos;；</div></pre></td></tr></table></figure>

5. 查询没学过“叶平”老师课的同学的学号、姓名；

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select Student.S#,Student.Sname</div><div class="line">from Student</div><div class="line">where S# not in (select distinct( SC.S#) from SC,Course,Teacher where SC.C#=Course.C# and Teacher.T#=Course.T# and Teacher.Tname=’叶平’);</div></pre></td></tr></table></figure>

6. 查询学过“001”并且也学过编号“002”课程的同学的学号、姓名:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select Student.S#,Student.Sname</div><div class="line">from Student,SC</div><div class="line">where Student.S#=SC.S# and SC.C#=’001′and exists( Select * from SC as SC_2 where SC_2.S#=SC.S# and SC_2.C#=’002′);</div></pre></td></tr></table></figure>

7. 查询学过“叶平”老师所教的所有课的同学的学号、姓名:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">select S#,Sname</div><div class="line">from Student</div><div class="line">where S# in</div><div class="line">(select S#</div><div class="line">from SC ,Course ,Teacher</div><div class="line">where SC.C#=Course.C# and Teacher.T#=Course.T# and Teacher.Tname=’叶平’ group by S# having count(SC.C#)=(select count(C#) from Course,Teacher where Teacher.T#=Course.T# and Tname=’叶平’));</div></pre></td></tr></table></figure>

8. 查询所有课程成绩小于60分的同学的学号、姓名:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select S#,Sname</div><div class="line">from Student</div><div class="line">where S# not in (select Student.S# from Student,SC where S.S#=SC.S# and score&gt;60);</div></pre></td></tr></table></figure>

9. 查询没有学全所有课的同学的学号、姓名:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select Student.S#,Student.Sname</div><div class="line">from Student,SC</div><div class="line">where Student.S#=SC.S#</div><div class="line">group by Student.S#,Student.Sname having count(C#) &lt;(select count(C#) from Course);</div></pre></td></tr></table></figure>

10. 查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select S#,Sname</div><div class="line">from Student,SC</div><div class="line">where Student.S#=SC.S# and C# in （select C# from SC where S#=&apos;1001&apos;）;</div></pre></td></tr></table></figure>

11. 删除学习“叶平”老师课的SC表记录:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Delect SC</div><div class="line">from course ,Teacher</div><div class="line">where Course.C#=SC.C# and Course.T#= Teacher.T# and Tname=&apos;叶平&apos;;</div></pre></td></tr></table></figure>

12. 查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">SELECT L.C# 课程ID,L.score 最高分,R.score 最低分</div><div class="line">FROM SC L ,SC R</div><div class="line">WHERE L.C# = R.C#</div><div class="line">and</div><div class="line">L.score = (SELECT MAX(IL.score)</div><div class="line">FROM SC IL,Student IM</div><div class="line">WHERE IL.C# = L.C# and IM.S#=IL.S#</div><div class="line">GROUP BY IL.C#)</div><div class="line">and</div><div class="line">R.Score = (SELECT MIN(IR.score)</div><div class="line">FROM SC IR</div><div class="line">WHERE IR.C# = R.C#</div><div class="line">GROUP BY IR.C# );</div></pre></td></tr></table></figure>

  13. 查询学生平均成绩及其名次:
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SELECT 1+(SELECT COUNT( distinct 平均成绩)</div><div class="line">FROM (SELECT S#,AVG(score) 平均成绩</div><div class="line">FROM SC</div><div class="line">GROUP BY S# ) T1</div><div class="line">WHERE 平均成绩 &gt; T2.平均成绩) 名次, S# 学生学号,平均成绩</div><div class="line">FROM (SELECT S#,AVG(score) 平均成绩 FROM SC GROUP BY S# ) T2</div><div class="line">ORDER BY 平均成绩 desc;</div></pre></td></tr></table></figure>

  14. 查询各科成绩前三名的记录:(不考虑成绩并列情况)

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SELECT t1.S# as 学生ID,t1.C# as 课程ID,Score as 分数</div><div class="line">FROM SC t1</div><div class="line">WHERE score IN (SELECT TOP 3 score</div><div class="line">FROM SC</div><div class="line">WHERE t1.C#= C#</div><div class="line">ORDER BY score DESC)</div><div class="line">ORDER BY t1.C#;</div></pre></td></tr></table></figure>

  15. 查询每门功成绩最好的前两名
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SELECT t1.S# as 学生ID,t1.C# as 课程ID,Score as 分数</div><div class="line">FROM SC t1</div><div class="line">WHERE score IN (SELECT TOP 2 score</div><div class="line">FROM SC</div><div class="line">WHERE t1.C#= C#</div><div class="line">ORDER BY score DESC )</div><div class="line">ORDER BY t1.C#;</div></pre></td></tr></table></figure>
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/HTTP协议小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/HTTP协议小结/" itemprop="url">HTTP协议小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T13:30:17+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTTP/" itemprop="url" rel="index">
                    <span itemprop="name">HTTP</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTTP/TCP/" itemprop="url" rel="index">
                    <span itemprop="name">TCP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>HTTP协议是基于TCP/IP协议来传递数据的应用层协议，规定了客户端和服务器之间的通信格式，其默认端口为80，HTTP是无连接无状态的。</p>
<h1 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h1><ol>
<li>简单快速：客户向服务器请求服务时只需要传送请求方法和路径，请求方法常用的有GET，POST，不同方法规定了客户和服务器不同的联系类型。协议通信速度很快。</li>
<li>灵活：HTTP协议允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记。</li>
<li>无连接：限制每次连接只处理一个请求，服务端确定用户端收到了处理后的结果之后，立刻断开连接。节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议。无状态指的是协议对于事务处理没有记忆能力。</li>
<li>支持BS及CS模式</li>
</ol>
<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p><code>http://host[:port][abs_path]</code></p>
<p>例如：</p>
<p><code>https://www.baidu.com/s?wd=HttP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93&amp;rsv_spt=1&amp;rsv_iqid=0xbb6ac0d200022f6c&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;oq=HttP%25E6%2580%25BB%25E7%25BB%2593&amp;inputT=7363&amp;rsv_t=089bmiWk56%2BnKt5Ljs7CZihPEekxaufgYcpdefPyy4J6qS3KjJEt6Qzyg5XhLwQPRZTF&amp;rsv_pq=c43d53970003ea1e&amp;rsv_sug3=58&amp;rsv_sug1=42&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_sug4=8625&amp;rsv_sug=2</code></p>
<ul>
<li>协议部分：如http,https,tcp，其后加<code>://</code></li>
<li>域名部分：<code>www.baidu.com</code>,合法的Internet主机域名或者IP地址</li>
<li>端口部分：指定一个端口，拥有被请求资源的服务器主机监听该端口的TCP连接。如果port为空，HTTP协议默认为80，HTTPS协议默认为443。</li>
<li>虚拟目录部分：从域名的第一个<code>/</code>开始到最后一个<code>/</code>为止。</li>
<li>文件名部分：从域名后的最后一个<code>/</code>开始到<code>?</code>为止，是文件名部分，如果没有<code>?</code>文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。</li>
<li>锚部分：从“#”开始到最后，都是锚部分。</li>
<li>参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。</li>
</ul>
<h1 id="URL和URI的区别："><a href="#URL和URI的区别：" class="headerlink" title="URL和URI的区别："></a>URL和URI的区别：</h1><table>
<thead>
<tr>
<th></th>
<th style="text-align:center">URL</th>
<th style="text-align:center">URI</th>
</tr>
</thead>
<tbody>
<tr>
<td>全名</td>
<td style="text-align:center">Uniform resource locator</td>
<td style="text-align:center">Uniform resource identifier</td>
</tr>
<tr>
<td>用途</td>
<td style="text-align:center">url可以用来标识一个资源，还指明了如何locate这个资源</td>
<td style="text-align:center">定位web上可用的各种资源文件</td>
</tr>
<tr>
<td>组成</td>
<td style="text-align:center">协议+IP地址（端口）+主机资源的具体地址</td>
<td style="text-align:center">访问资源的命名机制+存放资源的主机名+资源自身的名称</td>
</tr>
</tbody>
</table>
<h1 id="请求消息Request"><a href="#请求消息Request" class="headerlink" title="请求消息Request"></a>请求消息Request</h1><p>客户端发送一个HTTP请求到服务器的请求消息包含：</p>
<ul>
<li>请求行</li>
<li>请求头部</li>
<li>空行</li>
<li><p>请求数据</p>
<p><img src="/img/http-1.png" alt="Alt text"></p>
</li>
</ul>
<ol>
<li>请求行：说明请求类型，要访问的资源以及使用的HTTP版本</li>
<li>请求头部:说明服务器要使用的附加信息，host将指出请求的目的地，User-Agent。</li>
<li>空行：强制空行划分请求头和请求数据</li>
<li>请求数据：也叫请求主题，可以添加任意的其他数据。</li>
</ol>
<h2 id="请求头的常用字段："><a href="#请求头的常用字段：" class="headerlink" title="请求头的常用字段："></a>请求头的常用字段：</h2><ul>
<li>Accept：告诉服务器，客户机支持的数据格式</li>
<li>Accept-Charset：告诉服务器，客户机采用的编码</li>
<li>Accept-Encoding：告诉服务器，客户机支持的数据压缩格式</li>
<li>Accept-language：用于告诉服务器，资源缓存的时间</li>
<li>Host：用于告诉服务器，客户机向访问的主机名</li>
<li>If-Modified-Since：用于告诉客户机，资源缓存的时间</li>
<li>Referer: 用于告诉服务器，客户机是从哪个资源链接到本资源的</li>
<li>User-Agent：客户机通过这个头可以向服务器带数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Accept: text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01</div><div class="line">Accept-Encoding: gzip, deflate, br</div><div class="line">Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,ja;q=0.6</div><div class="line">Connection: keep-alive</div><div class="line">Cookie: BAIDUID=CDFD2D15954E6F99667163D726B3A3E4:FG=1; BIDUPSID=CDFD2D15954E6F99667163D726B3A3E4; PSTM=1500866515; BDUSS=hEYVF-Wmpka0lRLXMwWGRQZmtiVkViUDB5OVJnblNrQVpEM29EcHJPZ2JMS1paSUFBQUFBJCQAAAAAAAAAAAEAAAD0yYIxX8biX9fTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABufflkbn35ZWj; MCITY=-131%3A; BD_UPN=12314753; H_PS_PSSID=1445_21099_20928; BD_CK_SAM=1; PSINO=1; H_PS_645EC=b5cdqANCiMatErji8Z8BouSUOvY79iH5o%2Fjy%2FUKJM0yMzqrgjyQy2ee4g9p7aR60t86a</div><div class="line">Host: www.baidu.com</div><div class="line">Referer: https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;tn=baiduhome_pg&amp;wd=http%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5&amp;rsv_spt=1&amp;oq=http%25E8%25AF%25B7%25E6%25B1%2582&amp;rsv_pq=c189685100052af0&amp;rsv_t=596djY6Nc%2B2XuiZI2%2BAjz0DgMcM0Kn2EZBS1dtxl4a3ykgijQGu4DuQ3OjfSPXh6SjPu&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=5&amp;rsv_sug1=4&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;inputT=5807&amp;rsv_sug4=6646</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36</div><div class="line">X-Requested-With: XMLHttpRequest</div></pre></td></tr></table></figure>
<h1 id="消息相应Response"><a href="#消息相应Response" class="headerlink" title="消息相应Response"></a>消息相应Response</h1><p>消息相应由四部分组成：</p>
<p><img src="/img/http-2.png" alt="Alt text"></p>
<ul>
<li>状态行：由HTTP协议版本号，状态码，状态消息三部分组成</li>
<li>消息报头：说明客户端要使用的一些附加信息</li>
<li>空行：分割用，必须</li>
<li>响应正文：服务器返回给客户端的文本信息</li>
</ul>
<h2 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h2><ol>
<li>1XX：指示信息，表示请求已经接收，继续处理</li>
<li>2XX：成功，表示请求已经被成功接收</li>
<li>3XX：重定向，要完成请求需要进行更进一步的操作</li>
<li>4XX：客户端错误，请求有语法错误或者请求无法实现</li>
<li>5XX：服务器内部错误。</li>
</ol>
<p>常见状态码：</p>
<ul>
<li>200 OK</li>
<li>400 bad Request</li>
<li>401 Unauthorized</li>
<li>403 Forbidden</li>
<li>404 Not Found</li>
<li>500 Internal Server Error</li>
<li>503 Server Unavailable</li>
</ul>
<h2 id="常见响应头"><a href="#常见响应头" class="headerlink" title="常见响应头"></a>常见响应头</h2><ul>
<li>Location：这个响应头配合302状态码使用，用于告诉客户机资源的地址</li>
<li>Server：服务器通过这个头，告诉浏览器服务器的类型</li>
<li>Content-Encoding：服务器通过这个头，告诉浏览器数据压缩的格式</li>
<li>Content-Length：服务器通过这个头，告诉浏览器回送数据的长度</li>
<li>Content-Type：服务器通过这个头，告诉浏览器回送数据的类型</li>
<li>Last-Modified:服务器通过这个头，告诉浏览器当前资源缓存时间</li>
<li>Refresh：服务器通过这个头，告诉浏览器隔多长时间刷新一次</li>
<li>Content-Disposition：服务器通过这个头，告诉浏览器以下载方式打开数据</li>
<li>Transfer-Encoding：服务器通过这个头，告诉浏览器数据传送的格式</li>
<li>ETag：缓存相关的头，和Last-Modified功能一样，不过实时性更强（Last-Modified是一秒内即使内容更新也让浏览器找缓存）</li>
<li>Expires:服务器通过这个头，告诉浏览器把回送的资源缓存多长时间，0或-1表示不缓存</li>
<li>Cache-Control：no-cache</li>
<li>Pragma： no-cache</li>
</ul>
<h1 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h1><p>HTTP1.0定义了三种请求方式，get、post、head，HTTP1.1新增了五种请求方法，options、put、delete、trace、connect。</p>
<ul>
<li>GET：请求指定的页面信息，并返回实体主体</li>
<li>HEAD：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头。</li>
<li>POST：向指定资源提交数据进行处理请求，数据被包含在请求体中，POST请求可能会导致新的资源的尽力或者已有资源的修改。</li>
<li>PUT：从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li>DELETE：请求服务器删除指定的页面。</li>
<li>CONNECT：HTTP1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>
<li>OPTIONS：允许客户端查看服务器性能。</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>
</ul>
<h1 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h1><p>HTTP协议采用了请求/响应模型，客户端向服务器发送一个请求报文，请求报文包含请求的方法，URL，协议版本，请求头部和请求数据。服务器以一个状态行作为相应，相应的内容包括协议的版本，成功或者错误代码，服务器信息，响应头部和响应数据。</p>
<p>HTTP请求响应的步骤：</p>
<ol>
<li><p>客户端连接到Web服务器，HTTP客户端，比如浏览器，与Web服务器的HTTP端口建立一个TCP套接字连接。</p>
</li>
<li><p>发送HTTP请求，通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行，请求头部，空行和请求数据四部分组成。</p>
</li>
<li><p>服务器接收请求并返回HTTP响应，Web服务器解析请求，定位请求资源。服务器将资源副本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部，空行和响应数据4部分组成。</p>
</li>
<li><p>释放TCP连接，如果Connection模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接受请求。</p>
</li>
<li><p>客户端浏览器解析HTML内容。浏览器解析状态行，查看表明请求是否成功的状态代码，然后解析每一个响应头，响应头告知一下若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML语法对其进行格式化，并在浏览器窗口中显示。</p>
</li>
</ol>
<h1 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h1><table>
<thead>
<tr>
<th></th>
<th style="text-align:center">GET</th>
<th style="text-align:center">POST</th>
</tr>
</thead>
<tbody>
<tr>
<td>提交</td>
<td style="text-align:center">GET提交，请求的数据会附在URL之后，也就是讲数据放在HTTP协议头之内，以？分隔URL和传输数据，多个参数用&amp;连接</td>
<td style="text-align:center">POST提交，把提交的数据放置在HTTP包的包体中，不像get提交会在地址栏上显示出来</td>
</tr>
<tr>
<td>传输数据大小</td>
<td style="text-align:center">特定浏览器和服务器对URL长度有限制，get请求会收到URL长度的限制</td>
<td style="text-align:center">理论上不受到任何限制</td>
</tr>
<tr>
<td>安全性</td>
<td style="text-align:center">get提交数据，例如用户名和密码将明文出现在URL上</td>
<td style="text-align:center">安全性较高</td>
</tr>
</tbody>
</table>
<ul>
<li><p>HTTP get,post,soap协议都是在HTTP上运行的</p>
<ul>
<li><p>get:请求参数是作为一个key-value键值对的序列附加到URL上，查询字符串长度受到浏览器和服务器的限制，不适合传输大型数据集且其极不安全。</p>
</li>
<li><p>psot:请求参数是在HTTP标题的一个不同部分传输的，这一部分用来传输表单信息，因此必须将contentType设置为application/x-www-form- urlencoded。POST参数也是key-value键值对。但是它不支持复杂类型数据，因为POST没有定义传输数据结构的语义和规则。</p>
</li>
<li><p>soap：http POST的一个专用版本，遵循一种特殊的XML消息格式，contentType设置为text/xml 任何数据都可以xml化。</p>
</li>
</ul>
</li>
</ul>
<h1 id="TCP连接建立过程"><a href="#TCP连接建立过程" class="headerlink" title="TCP连接建立过程"></a>TCP连接建立过程</h1><p><img src="/img/tcp-conn.png" alt="Alt text"></p>
<ol>
<li>两端TCP进程都是处于关闭状态，A是主动打开连接，B是被动打开连接。</li>
<li>A的TCP客户端进程向B发出连接请报文段，这时首部中的同步位SYN=1，同时选择一个初始序号seq=x。TCP规定，SYN报文段不能携带数据但要消耗一个序号。这时，A的客户进程就进入SYN-SENT状态（同步已发送）。</li>
<li>B收到连接请求报文之后，向A发送确认。在确认报文段中把SYN和ACK位都设置为1，确认号是ack=x+1,同时也为自己选择一个初始序号seq=y。这个报文段也不携带信息但是要消耗掉一个序号。这时B的TCP进程就进入SYN-RCVD（已收到同步）状态。</li>
<li>A的TCP客户端收到B的确认后，还要向B给出确认，确认报文段的ACK设置为1，确认号ack=y+1，而自己的序号seq=x+1。这时TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态。</li>
<li>B收到A的确认后，也会进入ESTABLISHED状态。</li>
</ol>
<ul>
<li>为什么A还要再发送一次确认呢？<br>是为了防止已失效的连接请求报文段突然又回传到了B，而产生错误。（该报文段可能因为网络延时而失效）</li>
</ul>
<h1 id="TCP连接断开的过程"><a href="#TCP连接断开的过程" class="headerlink" title="TCP连接断开的过程"></a>TCP连接断开的过程</h1><p><img src="/img/tcp-close.png" alt="Alt text"></p>
<ol>
<li><p>断开连接时，发起方可以是客户端也可以是服务端。发起方会先发送一个FIN包，就进入FIN_WAIT状态，因此就不能发送用户数据，等待响应方回复ACK。</p>
</li>
<li><p>响应方收到FIN包后，就给发起方回复ACK。此时，响应方进入CLOSE_WAIT状态，因此响应方还有待发送的数据，需要等待发送完毕，才能关闭连接（发起方在发送FIN前，会保证已经发送完数据）。</p>
</li>
<li><p>发起方收到ACK后，就进入FIN_WAIT_2。此时还能继续接受数据，直到收到响应方的FIN。</p>
</li>
<li><p>响应方等数据发送完毕后，就给发起方发送FIN包。</p>
</li>
<li><p>发起方收到响应方的FIN包后，就进入TIME_WAIT状态，并向响应方发送ACK。</p>
</li>
<li><p>响应方收到ACK后，就进入CLOSE状态，完成了断开流程。</p>
</li>
<li><p>发起方的TIME_WAIT状态会持续2MSL（最大报文生存时间）。然后进入到CLOSED。</p>
</li>
</ol>
<ul>
<li><p>为何是四次握手？<br>响应方还有待发送端 数据，需要数据发送完才能发SYN包。</p>
</li>
<li><p>为什么需要TIME_WAIT状态？<br>因为在发起方发送ACK之后，不保证响应方一定能收到ACK。响应方在发送FIN后，就等待发起方的ACK，在等待一段时间之后，如果没有收到ACK，就会重发FIN包。发起方在TIME_WAIT的时间内如果又收到了FIN包，就会在发送ACK包。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/30/设计模式之七种单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/30/设计模式之七种单例模式/" itemprop="url">设计模式之七种单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-30T17:34:28+08:00">
                2018-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/design-patterns/" itemprop="url" rel="index">
                    <span itemprop="name">design patterns</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对其中单例模式做个总结，以备不时之需。</p>
<h1 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package singleton;</div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/3/23</div><div class="line"> * 饿汉，基于ClassLoader机制避免了多线程的同步问题，加载过程较慢，获取对象速度较快</div><div class="line"> * 不过instance在类装载时就实例化。虽然大多数情况下调用单例模式的getInstance方法导致类加载，但是也不能确定没有其他</div><div class="line"> * 静态方法导致类被加载，从而没有达到懒加载的效果。</div><div class="line"> */</div><div class="line">public class Singleton &#123;</div><div class="line">    private Singleton() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static Singleton singleton = new Singleton();</div><div class="line"></div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        return singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="懒汉（线程不安全）"><a href="#懒汉（线程不安全）" class="headerlink" title="懒汉（线程不安全）"></a>懒汉（线程不安全）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package singleton;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/3/24</div><div class="line"> * 懒汉设计模式，线程安全，但是效率很低，每次调用getInstance方法都需要</div><div class="line"> * 获得锁，而大多数情况下不需要同步</div><div class="line"> */</div><div class="line">public class Singleton1 &#123;</div><div class="line">    private Singleton1()&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static Singleton1 singleton1;</div><div class="line"></div><div class="line">    public static synchronized Singleton1 getInstacne()&#123;</div><div class="line">        if (singleton1 == null)</div><div class="line">            singleton1 = new Singleton1();</div><div class="line">        return singleton1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="懒汉（线程安全）"><a href="#懒汉（线程安全）" class="headerlink" title="懒汉（线程安全）"></a>懒汉（线程安全）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package singleton;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/3/24</div><div class="line"> * 懒汉设计模式，线程不安全</div><div class="line"> */</div><div class="line">public class Singleton2 &#123;</div><div class="line">    private Singleton2()&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static Singleton2 singleton1;</div><div class="line"></div><div class="line">    public static Singleton2 getInstacne()&#123;</div><div class="line">        if (singleton1 == null)</div><div class="line">            singleton1 = new Singleton2();</div><div class="line">        return singleton1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="双重检查单例模式"><a href="#双重检查单例模式" class="headerlink" title="双重检查单例模式"></a>双重检查单例模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package singleton;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/3/30</div><div class="line"> * 双重检查模式，第一次是为了减少不必要的同步，当singleton对象存在时，</div><div class="line"> * 直接返回实例对象，则同步只发生在多个线程同时调用getInstance加载类</div><div class="line"> * 第二次判空是为了singleton为null才创建实例。</div><div class="line"> * DCL优点是资源利用率高，第一次执行getInstance时单例对象才被实例化，效率高。</div><div class="line"> * 缺点是第一次加载速度慢，高并发场景中也会影响其性能，但是也存在DCL失效，</div><div class="line"> * 建议使用静态内部类单例模式来替代DCL</div><div class="line"> */</div><div class="line">public class Singleton3 &#123;</div><div class="line">    private volatile static Singleton3 singleton;</div><div class="line"></div><div class="line">    private Singleton3() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Singleton3 getInstance() &#123;</div><div class="line">        if (singleton == null) &#123;</div><div class="line">            synchronized (Singleton3.class) &#123;</div><div class="line">                if (singleton == null) &#123;</div><div class="line">                    singleton = new Singleton3();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package singleton;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/3/30</div><div class="line"> * 静态内部类单例：</div><div class="line"> * 第一次加载Singleton类时并不会初始化是Instance，只有第一次调用Singleton</div><div class="line"> * 方法时虚拟机加载SingletonHolder并初始化sInstance，这样不仅能确保线程安</div><div class="line"> * 全也能保证Singleton的唯一性，推荐使用。</div><div class="line"> */</div><div class="line">public class Singleton4 &#123;</div><div class="line">    private Singleton4() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Singleton4 getInstance() &#123;</div><div class="line">        return SingletonHolder.sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class SingletonHolder&#123;</div><div class="line">        private static final Singleton4 sInstance = new Singleton4();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package singleton;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/3/30</div><div class="line"> * 默认枚举类实例的创建是线程安全的，并且在任何情况下都是单例，上述的几种</div><div class="line"> * 单例在反序列化的情况下会创建对象，将一个单例实例对象写到磁盘再读回来，</div><div class="line"> * 从而获得一个实例。反序列化操作提供了</div><div class="line"> */</div><div class="line">public enum Singleton5 &#123;</div><div class="line">    INSTANCE;</div><div class="line">    public void doSomething() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="容器实现单例"><a href="#容器实现单例" class="headerlink" title="容器实现单例"></a>容器实现单例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package singleton;</div><div class="line"></div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/3/30</div><div class="line"> * 使用容器实现单例模式</div><div class="line"> * 用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象</div><div class="line"> * 对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用</div><div class="line"> * 时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐</div><div class="line"> * 藏了具体实现，降低了耦合度。</div><div class="line"> */</div><div class="line">public class Singleton6 &#123;</div><div class="line">    private static Map&lt;String, Object&gt; objectMap = new HashMap&lt;&gt;();</div><div class="line">    private Singleton6() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void registerService(String key, Object instance) &#123;</div><div class="line">        if (!objectMap.containsKey(key)) &#123;</div><div class="line">            objectMap.put(key, instance);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Object getService(String key) &#123;</div><div class="line">        return objectMap.get(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/29/Redis-redis底层数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/Redis-redis底层数据结构/" itemprop="url">Redis-redis底层数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-29T10:52:55+08:00">
                2018-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h1><p>  redis是一个基于键值对的分布式存储系统，与memcached类似，却优于memcached的一个高性能的key-value数据库。其中键值对的key总是为一个字符串对象，字符串的值可以为字符串对象，列表对象，哈希对象，集合对象，有序集合对象之一。</p>
<p>  Redis中value的值为上面五种，但是底层数据结构包括：</p>
<ul>
<li>简单动态字符串</li>
<li>链表</li>
<li>字典</li>
<li>跳跃表</li>
<li>整数集合</li>
<li>压缩列表</li>
<li>对象</li>
</ul>
<h1 id="简单动态字符串（simple-dynamic-string）"><a href="#简单动态字符串（simple-dynamic-string）" class="headerlink" title="简单动态字符串（simple dynamic string）"></a>简单动态字符串（simple dynamic string）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis底层是由C编写的，但是其对C中字符串做了一个封装，构建了种名为简单动态字符串的抽象类型，并将SDS设置为redis默认采用的字符串表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis&gt;SET msg &quot;sdsTest&quot;</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>key是一个字符串对象，字符串对象的低层是一个保存着“msg”的SDS；<br>value是一个字符串对象，低层是一个保存着字符串“sdsTest”的SDS。</p>
<h2 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h2><p>redis中定义动态字符串的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef char *sds;  </div><div class="line">//指向sdshdr结构buf成员的地址</div><div class="line"></div><div class="line">struct sdshdr &#123;</div><div class="line">    int len;        //buf中已占用空间的长度</div><div class="line">    int free;       //buf中剩余可用空间的长度</div><div class="line">    char buf[];     //初始化sds分配的数据空间</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>则msg可以被表示为：</p>
<p><img src="/img/redis-sds-example.png" alt="Alt text"></p>
<ul>
<li>len为7，表示这个sds的长度为7</li>
<li>free为0，表示这个sds可用空间为0</li>
<li>buf是一个char数组，分配了len + 1 + free个字节的长度，前len个字节保存着SDS的信息，接下来一个字符保存字符串终止符’\0’,剩下free个字节是未使用的。</li>
</ul>
<h2 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h2><p>  redis不直接使用C字符串而采用SDS的原因主要在于传统C语言使用长度为N+1的字符数组来存储长度为N的字符串，这样在获取字符串长度，字符串扩展操作时效率低，不能满足redis对字符串在安全性、功能、效率等的要求。</p>
<ol>
<li><p>获取字符串长度</p>
<ul>
<li>传统C语言：获取字符串长度需要遍历字符数组，复杂度为O(N);</li>
<li>Redis SDS：获取len属性的值就是字符串的长度 O(1);</li>
</ul>
</li>
<li><p>杜绝缓冲区溢出</p>
<ul>
<li>C语言中字符串不记录字符串的长度，容易造成缓冲区溢出。比如拼接字符串过程容易发生缓冲区溢出。</li>
<li>redis中sds的空间分配策略杜绝了发生缓冲区溢出：redis会在拼接字符串之前，预先检查给定SDS空间是否足够，如果不够会先扩展SDS空间，然后再执行拼接操作。</li>
</ul>
</li>
<li><p>减少修改字符串时带来的内存重新分配次数。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/* Enlarge the free space at the end of the sds string so that the caller</div><div class="line"> * is sure that after calling this function can overwrite up to addlen</div><div class="line"> * bytes after the end of the string, plus one more byte for nul term.</div><div class="line"> *</div><div class="line"> * Note: this does not change the *length* of the sds string as returned</div><div class="line"> * by sdslen(), but only the free buffer space we have. */</div><div class="line">sds sdsMakeRoomFor(sds s, size_t addlen) &#123;</div><div class="line">    void *sh, *newsh;</div><div class="line">    size_t avail = sdsavail(s);</div><div class="line">    size_t len, newlen;</div><div class="line">    char type, oldtype = s[-1] &amp; SDS_TYPE_MASK;</div><div class="line">    int hdrlen;</div><div class="line"></div><div class="line">    /* Return ASAP if there is enough space left. */</div><div class="line">    if (avail &gt;= addlen) return s;</div><div class="line"></div><div class="line">    len = sdslen(s);</div><div class="line">    sh = (char*)s-sdsHdrSize(oldtype);</div><div class="line">    newlen = (len+addlen);</div><div class="line">    if (newlen &lt; SDS_MAX_PREALLOC)</div><div class="line">        newlen *= 2;</div><div class="line">    else</div><div class="line">        newlen += SDS_MAX_PREALLOC;</div><div class="line"></div><div class="line">    type = sdsReqType(newlen);</div><div class="line"></div><div class="line">    /* Don&apos;t use type 5: the user is appending to the string and type 5 is</div><div class="line">     * not able to remember empty space, so sdsMakeRoomFor() must be called</div><div class="line">     * at every appending operation. */</div><div class="line">    if (type == SDS_TYPE_5) type = SDS_TYPE_8;</div><div class="line"></div><div class="line">    hdrlen = sdsHdrSize(type);</div><div class="line">    if (oldtype==type) &#123;</div><div class="line">        newsh = s_realloc(sh, hdrlen+newlen+1);</div><div class="line">        if (newsh == NULL) return NULL;</div><div class="line">        s = (char*)newsh+hdrlen;</div><div class="line">    &#125; else &#123;</div><div class="line">        /* Since the header size changes, need to move the string forward,</div><div class="line">         * and can&apos;t use realloc */</div><div class="line">        newsh = s_malloc(hdrlen+newlen+1);</div><div class="line">        if (newsh == NULL) return NULL;</div><div class="line">        memcpy((char*)newsh+hdrlen, s, len+1);</div><div class="line">        s_free(sh);</div><div class="line">        s = (char*)newsh+hdrlen;</div><div class="line">        s[-1] = type;</div><div class="line">        sdssetlen(s, len);</div><div class="line">    &#125;</div><div class="line">    sdssetalloc(s, newlen);</div><div class="line">    return s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>C语言在进行字符串的扩展和收缩的时候，都会面临着内存空间的重新分配问题。字符串拼接会产生字符串的内存空间的扩充，忘记申请分配空间会导致内存溢出；而字符串切割的时候，如果没有对内存空间重新分配会造成内存泄漏。</p>
</li>
<li><p>redis对SDS进行扩展，修改是SDS的长度，通过预分配侧率，SDS将连续增长的N次字符串所需的内存重分配次数从固定N次，降低为最多N次。</p>
</li>
</ul>
</li>
<li><p>惰性空间的释放</p>
<p>redis字符串进行收缩时，修改free属性来记录剩余的空间，并不直接回收那些不使用的内存，这样可以避免下次对字符串再次修改过程中可能存在的空间扩展，避免了缩短字符串所需要的内存重分配操作和将来可能存在的增长字符串操作。</p>
</li>
<li><p>二进制安全<br>C语言中字符串以空字符串为结束符，所以传统字符串不能保存图片视频等二级制文件。redis中依靠len来判断字符串是否结束，而不是寻找空字符串，这样可以用来保存图片，音频，视频等二进制数据，实现了二级制安全。SDS遵循C字符串以空字符串结尾的惯例。</p>
</li>
</ol>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表在redis中使用很多，比如列表件的低层实现之一就是链表。而且在redis中链表的结构被实现为双向链表，收尾操作很快。</p>
<h2 id="链表的数据结构"><a href="#链表的数据结构" class="headerlink" title="链表的数据结构"></a>链表的数据结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* Node, List, and Iterator are the only data structures used currently. */</div><div class="line"></div><div class="line">typedef struct listNode &#123;</div><div class="line">    struct listNode *prev;</div><div class="line">    struct listNode *next;</div><div class="line">    void *value;</div><div class="line">&#125; listNode;</div></pre></td></tr></table></figure>
<ul>
<li>双向链表通过prev和next指针来会获取当前节点的前驱节点和后继节点的复杂度为O(1);</li>
</ul>
<p>我们可以直接通过list来操作链表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct list &#123;</div><div class="line">    listNode *head;</div><div class="line">    listNode *tail;</div><div class="line">    void *(*dup)(void *ptr);</div><div class="line">    void (*free)(void *ptr);</div><div class="line">    int (*match)(void *ptr, void *key);</div><div class="line">    unsigned long len;</div><div class="line">&#125; list;</div></pre></td></tr></table></figure>
<p><img src="/img/redis-linked-example.png" alt="Alt text"></p>
<ul>
<li>其中head指针指向链表头，tail指针指向链表尾，获取收尾节点复杂度O(1)</li>
<li>len记载链表的长度 获取长度复杂度为O(1);</li>
<li>dup,free,match指针实现多态，链表节点listNode使用空指针来保存节点的值，表头list使用dup，free, match指针来针对链表中存放非不同对象来实现不同的方法。</li>
</ul>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>  或者成为map,是一种用于保存键值对的抽象数据结构。字典中一个key可以和一个value进行关联，每一个key独一无二并且指向一个value，一个value可以被多个可以同时指定。C语言中不存在字典这种数据结构，redis实现了字典的数据结构。redis存取数据采用的都是key-value的形式，其中key为一个字符串对象，而value取值可以是字符串，可以是列表，可以是集合等。</p>
<h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>  redis中字典是通过哈希表实现的，一个哈希表有多个节点，每个节点保存一个键值对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct dict &#123;</div><div class="line">    dictType *type;</div><div class="line">    void *privdata;</div><div class="line">    dictht ht[2];</div><div class="line">    long rehashidx; /* rehashing not in progress if rehashidx == -1 */</div><div class="line">    int iterators; /* number of iterators currently running */</div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<ul>
<li>type: 指针指向dictType结构，该结构使得key和value能够存储任何类型的数据。</li>
<li>privdata: 私有数据，存放dictType结构中的函数的参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct dictType &#123;</div><div class="line">    unsigned int (*hashFunction)(const void *key);      //计算hash值的函数</div><div class="line">    void *(*keyDup)(void *privdata, const void *key);   //复制key的函数</div><div class="line">    void *(*valDup)(void *privdata, const void *obj);   //复制value的函数</div><div class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);  //比较key的函数</div><div class="line">    void (*keyDestructor)(void *privdata, void *key);   //销毁key的析构函数</div><div class="line">    void (*valDestructor)(void *privdata, void *obj);   //销毁val的析构函数</div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure>
<ul>
<li>ht[2]: 两张哈希表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef struct dictht &#123;</div><div class="line">    dictEntry **table;        //哈希表节点dictEntry位置</div><div class="line">    unsigned long size;       //哈希表大小，初始4</div><div class="line">    unsigned long sizemask;   //将哈希值映射到table索引</div><div class="line">    unsigned long used;       //记录哈希表已有节点数量</div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct dictEntry &#123;</div><div class="line">    void *key;</div><div class="line">    union &#123;</div><div class="line">        void *val;</div><div class="line">        uint64_t u64;</div><div class="line">        int64_t s64;</div><div class="line">        double d;</div><div class="line">    &#125; v;</div><div class="line">    struct dictEntry *next;   //解决哈希冲突</div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<ul>
<li>rehashidx: rehash的标志位</li>
<li>iterators：记录迭代器的数量</li>
</ul>
<h2 id="Redis中使用的哈希算法"><a href="#Redis中使用的哈希算法" class="headerlink" title="Redis中使用的哈希算法"></a>Redis中使用的哈希算法</h2><ul>
<li>计算int的哈希函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">unsigned int dictIntHashFunction(unsigned int key)</div><div class="line">&#123;</div><div class="line">    key += ~(key &lt;&lt; 15);</div><div class="line">    key ^=  (key &gt;&gt; 10);</div><div class="line">    key +=  (key &lt;&lt; 3);</div><div class="line">    key ^=  (key &gt;&gt; 6);</div><div class="line">    key += ~(key &lt;&lt; 11);</div><div class="line">    key ^=  (key &gt;&gt; 16);</div><div class="line">    return key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>MurmurHash2哈希算法：redis使用MurmurHash2算法来计算法哈希值，能产生32-bit或64-bit哈希值。该算法对硬件的要求在于：1.机器可以从任意一个地址读取一个4-bit大小的值，并且int的大小为4bit。seed默认值为5381，可以人为改变，不过没什么意义。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">unsigned int dictGenHashFunction(const void *key, int len) &#123;</div><div class="line">    /* &apos;m&apos; and &apos;r&apos; are mixing constants generated offline.</div><div class="line">     They&apos;re not really &apos;magic&apos;, they just happen to work well.  */</div><div class="line">    uint32_t seed = dict_hash_function_seed;</div><div class="line">    const uint32_t m = 0x5bd1e995;</div><div class="line">    const int r = 24;</div><div class="line"></div><div class="line">    /* Initialize the hash to a &apos;random&apos; value */</div><div class="line">    uint32_t h = seed ^ len;</div><div class="line"></div><div class="line">    /* Mix 4 bytes at a time into the hash */</div><div class="line">    const unsigned char *data = (const unsigned char *)key;</div><div class="line"></div><div class="line">    while(len &gt;= 4) &#123;</div><div class="line">        uint32_t k = *(uint32_t*)data;</div><div class="line"></div><div class="line">        k *= m;</div><div class="line">        k ^= k &gt;&gt; r;</div><div class="line">        k *= m;</div><div class="line"></div><div class="line">        h *= m;</div><div class="line">        h ^= k;</div><div class="line"></div><div class="line">        data += 4;</div><div class="line">        len -= 4;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Handle the last few bytes of the input array  */</div><div class="line">    switch(len) &#123;</div><div class="line">    case 3: h ^= data[2] &lt;&lt; 16;</div><div class="line">    case 2: h ^= data[1] &lt;&lt; 8;</div><div class="line">    case 1: h ^= data[0]; h *= m;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    /* Do a few final mixes of the hash to ensure the last few</div><div class="line">     * bytes are well-incorporated. */</div><div class="line">    h ^= h &gt;&gt; 13;</div><div class="line">    h *= m;</div><div class="line">    h ^= h &gt;&gt; 15;</div><div class="line"></div><div class="line">    return (unsigned int)h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>djb哈希算法: seed和字符串的ascii值，len次变换之后得到hash值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* And a case insensitive hash function (based on djb hash) */</div><div class="line">unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len) &#123;</div><div class="line">    unsigned int hash = (unsigned int)dict_hash_function_seed;</div><div class="line"></div><div class="line">    while (len--)</div><div class="line">        hash = ((hash &lt;&lt; 5) + hash) + (tolower(*buf++)); /* hash * 33 + c */</div><div class="line">    return hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>当哈希表的大小不能满足需求，可能会有两个以上的键值被分配到同一个位置上，这时候就发生了冲突，redis中解决冲突的方法和HashMap中类似，使用链表法。但是当这种情况频繁发生，会影响查找的性能，需要尽力避免。这个时候希望通过哈希表的load factor来动态的决定扩展哈希表或者收缩哈希表。</p>
<ul>
<li>rehash流程：<ol>
<li>根据要求扩展或者收缩ht[1]</li>
<li>将ht[0]上的节点rehash到ht[1]上</li>
<li>释放ht[0], 将ht[1]设置为ht[0],新建一个ht[1]</li>
</ol>
</li>
</ul>
<p>扩展操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/* Expand the hash table if needed */</div><div class="line">static int _dictExpandIfNeeded(dict *d)</div><div class="line">&#123;</div><div class="line">    /* Incremental rehashing already in progress. Return. */</div><div class="line">    if (dictIsRehashing(d)) return DICT_OK;</div><div class="line"></div><div class="line">    /* If the hash table is empty expand it to the initial size. */</div><div class="line">    if (d-&gt;ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);</div><div class="line"></div><div class="line">    /* If we reached the 1:1 ratio, and we are allowed to resize the hash</div><div class="line">     * table (global setting) or we should avoid it but the ratio between</div><div class="line">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</div><div class="line">     * the number of buckets. */</div><div class="line">    if (d-&gt;ht[0].used &gt;= d-&gt;ht[0].size &amp;&amp;</div><div class="line">        (dict_can_resize ||</div><div class="line">         d-&gt;ht[0].used/d-&gt;ht[0].size &gt; dict_force_resize_ratio))</div><div class="line">    &#123;</div><div class="line">        return dictExpand(d, d-&gt;ht[0].used*2);</div><div class="line">    &#125;</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>收缩操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int dictResize(dict *d)</div><div class="line">&#123;</div><div class="line">    int minimal;</div><div class="line"></div><div class="line">    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;</div><div class="line">    minimal = d-&gt;ht[0].used;</div><div class="line">    if (minimal &lt; DICT_HT_INITIAL_SIZE)</div><div class="line">        minimal = DICT_HT_INITIAL_SIZE;</div><div class="line">    return dictExpand(d, minimal);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据传入的size来跳帧过着创建字典d的哈希表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/* Expand or create the hash table */</div><div class="line">int dictExpand(dict *d, unsigned long size)</div><div class="line">&#123;</div><div class="line">    dictht n; /* the new hash table */</div><div class="line">    unsigned long realsize = _dictNextPower(size);</div><div class="line"></div><div class="line">    /* the size is invalid if it is smaller than the number of</div><div class="line">     * elements already inside the hash table */</div><div class="line">    if (dictIsRehashing(d) || d-&gt;ht[0].used &gt; size)</div><div class="line">        return DICT_ERR;</div><div class="line"></div><div class="line">    /* Rehashing to the same table size is not useful. */</div><div class="line">    if (realsize == d-&gt;ht[0].size) return DICT_ERR;</div><div class="line"></div><div class="line">    /* Allocate the new hash table and initialize all pointers to NULL */</div><div class="line">    n.size = realsize;</div><div class="line">    n.sizemask = realsize-1;</div><div class="line">    n.table = zcalloc(realsize*sizeof(dictEntry*));</div><div class="line">    n.used = 0;</div><div class="line"></div><div class="line">    /* Is this the first initialization? If so it&apos;s not really a rehashing</div><div class="line">     * we just set the first hash table so that it can accept keys. */</div><div class="line">    if (d-&gt;ht[0].table == NULL) &#123;</div><div class="line">        d-&gt;ht[0] = n;</div><div class="line">        return DICT_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Prepare a second hash table for incremental rehashing */</div><div class="line">    d-&gt;ht[1] = n;</div><div class="line">    d-&gt;rehashidx = 0;</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>rehash过程不是一次性集中完成的，而是分多次，渐进式的，断续进行的，这样可以减少对服务器的影响。</p>
<h2 id="渐进式rehash-incremental-rehashing"><a href="#渐进式rehash-incremental-rehashing" class="headerlink" title="渐进式rehash(incremental rehashing)"></a>渐进式rehash(incremental rehashing)</h2><ol>
<li>dict中有一个成员为rehashidx，表示rehash的状态标志，-1表示不进行rehash，0表示开始进行rehash。</li>
<li>rehash过程中，每次对字典的CRUD时，会检查rehashidx标志位，如果在进行rehash，CRUD结束之后顺带进行单步rehash，同时rehashidx+1;</li>
<li>rehash结束之后，将rehashidx该为-1。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">static void _dictRehashStep(dict *d) &#123;</div><div class="line">    if (d-&gt;iterators == 0) dictRehash(d,1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int dictRehash(dict *d, int n) &#123;</div><div class="line">    int empty_visits = n*10; /* Max number of empty buckets to visit. */</div><div class="line">    if (!dictIsRehashing(d)) return 0;</div><div class="line"></div><div class="line">    while(n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        /* Note that rehashidx can&apos;t overflow as we are sure there are more</div><div class="line">         * elements because ht[0].used != 0 */</div><div class="line">        assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);</div><div class="line">        while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            if (--empty_visits == 0) return 1;</div><div class="line">        &#125;</div><div class="line">        de = d-&gt;ht[0].table[d-&gt;rehashidx];</div><div class="line">        /* Move all the keys in this bucket from the old to the new hash HT */</div><div class="line">        while(de) &#123;</div><div class="line">            unsigned int h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            /* Get the index in the new hash table */</div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;</div><div class="line">            de-&gt;next = d-&gt;ht[1].table[h];</div><div class="line">            d-&gt;ht[1].table[h] = de;</div><div class="line">            d-&gt;ht[0].used--;</div><div class="line">            d-&gt;ht[1].used++;</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;</div><div class="line">        d-&gt;rehashidx++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Check if we already rehashed the whole table... */</div><div class="line">    if (d-&gt;ht[0].used == 0) &#123;</div><div class="line">        zfree(d-&gt;ht[0].table);</div><div class="line">        d-&gt;ht[0] = d-&gt;ht[1];</div><div class="line">        _dictReset(&amp;d-&gt;ht[1]);</div><div class="line">        d-&gt;rehashidx = -1;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* More to rehash... */</div><div class="line">    return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><p>跳跃表示一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而可以快速到达要访问的节点。跳跃表是一个有序链表，其查找复杂度平均为O(logN)，最坏O(N)。redis中将跳跃表应用在有序集合键。</p>
<p>Redis中跳跃表主要有两部分组成：zskiplist和中skiplistNode：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">typedef struct zskiplist &#123;</div><div class="line">    struct zskiplistNode *header, *tail;</div><div class="line">    unsigned long length;       </div><div class="line">    int level;                  //跳跃表中节点的最大层数，除了第一个节点</div><div class="line">&#125; zskiplist;</div><div class="line"></div><div class="line">typedef struct zskiplistNode &#123;</div><div class="line">    robj *obj;                          </div><div class="line">    double score;                       </div><div class="line">    struct zskiplistNode *backward;     </div><div class="line">    struct zskiplistLevel &#123;</div><div class="line">        struct zskiplistNode *forward;  </div><div class="line">        unsigned int span;              </div><div class="line">    &#125; level[];                          </div><div class="line">&#125; zskiplistNode;</div></pre></td></tr></table></figure>
<ul>
<li>level：层，每个元素包含一个指向其他节点的指针，实现跳跃查询的关键。</li>
</ul>
<h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>整数结合是集合键低层实现之一。集合键另一实现为值为空的散列表。整数集合是为了节省使用散列表存储整形对象时的空间浪费。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct intset &#123;</div><div class="line">    uint32_t encoding;</div><div class="line">    uint32_t length;</div><div class="line">    int8_t contents[];</div><div class="line">&#125; intset;</div></pre></td></tr></table></figure>
<ul>
<li>encoding:编码格式，默认用2个字节存储，还有4个字节和8个字节</li>
<li>length:集合元素的数量</li>
<li>contents:数组类型</li>
</ul>
<p>新的元素插入到集合的流程：</p>
<ol>
<li>判断新元素的编码格式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* Return the required encoding for the provided value. */</div><div class="line">static uint8_t _intsetValueEncoding(int64_t v) &#123;</div><div class="line">    if (v &lt; INT32_MIN || v &gt; INT32_MAX)</div><div class="line">        return INTSET_ENC_INT64;</div><div class="line">    else if (v &lt; INT16_MIN || v &gt; INT16_MAX)</div><div class="line">        return INTSET_ENC_INT32;</div><div class="line">    else</div><div class="line">        return INTSET_ENC_INT16;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>调整内存空间</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* Resize the intset */</div><div class="line">static intset *intsetResize(intset *is, uint32_t len) &#123;</div><div class="line">    uint32_t size = len*intrev32ifbe(is-&gt;encoding);</div><div class="line">    is = zrealloc(is,sizeof(intset)+size);</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>根据编码格式设置对应的值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* Set the value at pos, using the configured encoding. */</div><div class="line">static void _intsetSet(intset *is, int pos, int64_t value) &#123;</div><div class="line">    uint32_t encoding = intrev32ifbe(is-&gt;encoding);</div><div class="line"></div><div class="line">    if (encoding == INTSET_ENC_INT64) &#123;</div><div class="line">        ((int64_t*)is-&gt;contents)[pos] = value;</div><div class="line">        memrev64ifbe(((int64_t*)is-&gt;contents)+pos);</div><div class="line">    &#125; else if (encoding == INTSET_ENC_INT32) &#123;</div><div class="line">        ((int32_t*)is-&gt;contents)[pos] = value;</div><div class="line">        memrev32ifbe(((int32_t*)is-&gt;contents)+pos);</div><div class="line">    &#125; else &#123;</div><div class="line">        ((int16_t*)is-&gt;contents)[pos] = value;</div><div class="line">        memrev16ifbe(((int16_t*)is-&gt;contents)+pos);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数组集合的好处：提升灵活性并节省内存空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/* Upgrades the intset to a larger encoding and inserts the given integer. */</div><div class="line">static intset *intsetUpgradeAndAdd(intset *is, int64_t value) &#123;</div><div class="line">    uint8_t curenc = intrev32ifbe(is-&gt;encoding);</div><div class="line">    uint8_t newenc = _intsetValueEncoding(value);</div><div class="line">    int length = intrev32ifbe(is-&gt;length);</div><div class="line">    int prepend = value &lt; 0 ? 1 : 0;</div><div class="line"></div><div class="line">    /* First set new encoding and resize */</div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc);</div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);</div><div class="line"></div><div class="line">    /* Upgrade back-to-front so we don&apos;t overwrite values.</div><div class="line">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</div><div class="line">     * space at either the beginning or the end of the intset. */</div><div class="line">    while(length--)</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line"></div><div class="line">    /* Set the value at the beginning or the end. */</div><div class="line">    if (prepend)</div><div class="line">        _intsetSet(is,0,value);</div><div class="line">    else</div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>ziplist是哈希键的低层实现之一。为特殊编码的双向链表，和整数集合一样是为了提高内存的存储效率而的设计的。当保存的对象是小整数，或者长度较短的字符串，redis就会使用压缩列表来作为哈希键的实现。</p>
<h2 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* Macro to determine type */</div><div class="line">#define ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)</div><div class="line"></div><div class="line">/* Utility macros */</div><div class="line">#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</div><div class="line">#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</div><div class="line">#define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</div><div class="line">#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</div><div class="line">#define ZIPLIST_END_SIZE        (sizeof(uint8_t))</div><div class="line">#define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</div><div class="line">#define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</div><div class="line">#define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</div></pre></td></tr></table></figure>
<p><img src="/img/redis-ziplist.png" alt="Alt text"></p>
<p>压缩链表可以包含任意多个节点，每个节点保存一个字节数组或者一个整数值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/28/算法之堆排序与快速排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/算法之堆排序与快速排序/" itemprop="url">算法-堆排序与快速排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T20:14:40+08:00">
                2018-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/algorithms/" itemprop="url" rel="index">
                    <span itemprop="name">algorithms</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><ul>
<li><p>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。堆排序很适合在m个数中选择最大的k个数的问题。只需要进行k此调整就可以取出。</p>
</li>
<li><p>思路：</p>
<ul>
<li>首先需要构成一个大顶堆。</li>
<li>将堆首元素出堆，将堆尾元素放在堆首，然后对剩下的m-1个数进行成堆。</li>
</ul>
</li>
<li><p>Java实现：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">package sort;</div><div class="line"></div><div class="line">import java.util.Arrays;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/3/28</div><div class="line"> */</div><div class="line">public class HeapSort &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int[] arr = &#123;53, 23, 45, 86, 12, 33, 10, 90, 36, 70, 43, 88, 60, 29&#125;;</div><div class="line">        System.out.println(&quot;排序之前： &quot; + Arrays.toString(arr));</div><div class="line">        heapSort(arr);</div><div class="line">        System.out.println(&quot;排序之后： &quot; + Arrays.toString(arr));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 堆排序方法</div><div class="line">     * @param arr 待排序的数组</div><div class="line">     */</div><div class="line">    private static void heapSort(int[] arr) &#123;</div><div class="line">        //1、创建大根堆，从第一个非叶子节点向堆首元素进行交换</div><div class="line">        for (int i = arr.length / 2; i &gt;= 0; i--) &#123;</div><div class="line">            heapAdjust(arr, i, arr.length);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //最后一个节点与root节点交换，然后调整成大根堆，</div><div class="line">        for (int i = arr.length - 1; i &gt; 0; i--) &#123;</div><div class="line">            swap(arr, 0, i);</div><div class="line">            heapAdjust(arr, 0, i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 构建堆的过程</div><div class="line">     * @param arr 需要排列的数组</div><div class="line">     * @param i 需要构建堆的根节点的序号</div><div class="line">     * @param length 堆元素的个数，随着出堆不断的减少</div><div class="line">     */</div><div class="line">    private static void heapAdjust(int[] arr, int i, int length) &#123;</div><div class="line">        int child;</div><div class="line">        for (int fathre = arr[i]; leftChild(i) &lt; length; i = child) &#123;</div><div class="line">            child = leftChild(i);</div><div class="line">            //选择节点i的较大的孩子节点</div><div class="line">            if (child != length - 1 &amp;&amp; arr[child] &lt; arr[child+1]) &#123;</div><div class="line">                child++;</div><div class="line">            &#125;</div><div class="line">            //如果父节点的值小于其较大的孩子节点，则交换二者的值</div><div class="line">            if (fathre &lt; arr[child]) &#123;</div><div class="line">                swap(arr, i, child);</div><div class="line">            &#125; else &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void swap(int[] arr, int i, int j) &#123;</div><div class="line">        int tmp =arr[i];</div><div class="line">        arr[i] = arr[j];</div><div class="line">        arr[j] = tmp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static int leftChild(int i) &#123;</div><div class="line">        return 2 * i+ 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序一般基于递归实现：</p>
<ul>
<li>选定一个合适的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">package sort;</div><div class="line"></div><div class="line">import java.util.Arrays;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by cdx0312</div><div class="line"> * 2018/3/28</div><div class="line"> */</div><div class="line">public class QuickSort &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int[] arr = &#123;53, 23, 45, 86, 12, 33, 10, 90, 36, 70, 43, 88, 60, 29&#125;;</div><div class="line">        System.out.println(&quot;排序之前： &quot; + Arrays.toString(arr));</div><div class="line">        quickSort(arr);</div><div class="line">        System.out.println(&quot;排序之后： &quot; + Arrays.toString(arr));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void quickSort(int[] arr) &#123;</div><div class="line">        quickSortHelp(arr, 0, arr.length - 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void quickSortHelp(int[] arr, int low, int high) &#123;</div><div class="line">        if (low &lt; high) &#123;</div><div class="line">            int pivot = partition(arr, low, high);</div><div class="line">            quickSortHelp(arr, low, pivot - 1);</div><div class="line">            quickSortHelp(arr, pivot + 1, high);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static int partition(int[] arr, int low, int high) &#123;</div><div class="line">        int pivot = arr[low];</div><div class="line">        while (low &lt; high) &#123;</div><div class="line">            while (low &lt; high &amp;&amp; arr[high] &gt;= pivot)</div><div class="line">                high--;</div><div class="line">            arr[low] = arr[high];</div><div class="line">            while (low &lt; high &amp;&amp; arr[low] &lt;= pivot)</div><div class="line">                low++;</div><div class="line">            arr[high] = arr[low];</div><div class="line">        &#125;</div><div class="line">        arr[low] = pivot;</div><div class="line">        return low;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void swap(int[] arr, int low, int high) &#123;</div><div class="line">        int temp = arr[low];</div><div class="line">        arr[low] = arr[high];</div><div class="line">        arr[high] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/26/设计模式之Spring中的应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/设计模式之Spring中的应用/" itemprop="url">设计模式之Spring中的应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T10:02:26+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/design-patterns/" itemprop="url" rel="index">
                    <span itemprop="name">design patterns</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/design-patterns/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring中使用的设计模式"><a href="#Spring中使用的设计模式" class="headerlink" title="Spring中使用的设计模式"></a>Spring中使用的设计模式</h1><ol>
<li><p>简单工厂</p>
<ul>
<li>又称为静态工厂，简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定创建哪一个产品类。</li>
<li>Spring中BeanFactory通过传入一个唯一标示来获取bean对象</li>
</ul>
</li>
<li><p>工厂方法</p>
<ul>
<li>程序将对象的创建及初始化职责交给工厂对象，工厂父类负责定义创建产品对象的公共接口，工厂子类负责生成具体的产品对象。将产品类的实例化操作延迟到工厂子类中完成。</li>
<li>Spring中的FactoryBean就是一个典型的工厂方法模式。</li>
</ul>
</li>
<li><p>单例</p>
<ul>
<li>保证一个类仅有一个实例，并提供一个访问他的全局访问点。</li>
<li>Spring下默认的bean均为singleton，通过singleton或者scope属性指定</li>
</ul>
</li>
<li><p>适配器</p>
<ul>
<li>将一个接口转换成客户希望的另一个接口，使得接口不兼容的类可以一起工作，其别名为Wrapper。</li>
<li>Spring中AOP的处理利用了Adapter模式</li>
</ul>
</li>
<li><p>装饰器</p>
<ul>
<li>动态的给一个对象添加一些额外的职责。就增加对象功能来说，装饰模式比生成子类实现更为灵活，别名与适配器相同。</li>
<li>Spring中类名中含有Wrapper或者Decorator中应用了装饰器</li>
</ul>
</li>
<li><p>代理</p>
<ul>
<li>为其他对象提供一种代理以控制对这个对象的访问。</li>
<li>Spring中AOP就是利用JDK动态代理来增强类的切面管理。</li>
</ul>
</li>
<li><p>观察者</p>
<ul>
<li>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于他的对象都被通知并被自动更新</li>
<li>spring中listener利用了观察者模式</li>
</ul>
</li>
<li><p>策略</p>
<ul>
<li>定义一系列的算法，将他们封装起来，并且使他们可互相替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式。</li>
<li>Spring在实例化对象的时候使用到策略模式。</li>
</ul>
</li>
<li><p>模板方法</p>
<ul>
<li>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。</li>
<li>Spring中jdbcTemplate就使用了模板方法。 </li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/25/设计模式之代理模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/设计模式之代理模式/" itemprop="url">设计模式之代理模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-25T19:59:03+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/design-patterns/" itemprop="url" rel="index">
                    <span itemprop="name">design patterns</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h1><p>为其他对象提供一种代理，以控制对这个对象的访问。代理对象起到中介作用，可以去掉功能服务或者增加额外的功能服务。</p>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>代理和被代理对象在代理之前是确定的。他们都是事先相同的接口或者继承相同的抽象类。</p>
<p><img src="/img/dp-staticProxy.png" alt="Alt text"></p>
<p>创建一个接口Moveable，Car继承Moveable接口，要求用代理类来记录Car的运行时间。</p>
<p>Car继承Moveable接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Moveable &#123;</div><div class="line">    void move();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Car:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Car implements Moveable&#123;</div><div class="line">    @Override</div><div class="line">    public void move() &#123;</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(new Random().nextInt(1000));</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="继承实现静态代理"><a href="#继承实现静态代理" class="headerlink" title="继承实现静态代理"></a>继承实现静态代理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Car2 extends Car&#123;</div><div class="line">    @Override</div><div class="line">    public void move() &#123;</div><div class="line">        long startTime = System.currentTimeMillis();</div><div class="line">        System.out.println(startTime);</div><div class="line">        super.move();</div><div class="line">        long endTime = System.currentTimeMillis();</div><div class="line">        System.out.println(endTime);</div><div class="line">        System.out.println(endTime - startTime);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="聚合实现静态代理"><a href="#聚合实现静态代理" class="headerlink" title="聚合实现静态代理"></a>聚合实现静态代理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Car3 implements Moveable&#123;</div><div class="line"></div><div class="line">    private Car car;</div><div class="line"></div><div class="line">    public Car3(Car car) &#123;</div><div class="line">        this.car = car;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void move() &#123;</div><div class="line">        long startTime = System.currentTimeMillis();</div><div class="line">        System.out.println(startTime);</div><div class="line">        car.move();</div><div class="line">        long endTime = System.currentTimeMillis();</div><div class="line">        System.out.println(endTime);</div><div class="line">        System.out.println(endTime - startTime);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>考虑到继承方式扩展代理功能的不方便，推荐使用聚合实现静态代理。也就是代理类和实际类实现共同的接口，代理类中包含所实现接口的引用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class CarLogProxy implements Moveable&#123;</div><div class="line"></div><div class="line">    private Moveable moveable;</div><div class="line"></div><div class="line">    public CarLogProxy(Moveable moveable) &#123;</div><div class="line">        this.moveable = moveable;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void move() &#123;</div><div class="line">        System.out.println(&quot;log start&quot;);</div><div class="line">        moveable.move();</div><div class="line">        System.out.println(&quot;log end&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class CarTimeProxy implements Moveable&#123;</div><div class="line"></div><div class="line">    private Moveable moveable;</div><div class="line"></div><div class="line">    public CarTimeProxy(Moveable moveable) &#123;</div><div class="line">        this.moveable = moveable;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void move() &#123;</div><div class="line">        long startTime = System.currentTimeMillis();</div><div class="line">        System.out.println(startTime);</div><div class="line">        moveable.move();</div><div class="line">        long endTime = System.currentTimeMillis();</div><div class="line">        System.out.println(endTime);</div><div class="line">        System.out.println(endTime - startTime);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Moveable car = new Car();</div><div class="line">        CarTimeProxy carTimeProxy = new CarTimeProxy(car);</div><div class="line">        CarLogProxy carLogProxy = new CarLogProxy(carTimeProxy);</div><div class="line">        carLogProxy.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>前面实现了Car类的静态代理，为其添加了运行时间记录和日志记录的功能。如果需要为火车或者自行车添加类似的功能，需要重新定义相同的类，类十分臃肿，同时代码重用性不高，因此引入了动态代理，也就是在程序</p>
<h2 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><p><img src="/img/dp-dynamicProxy.png" alt="Alt text"></p>
<ul>
<li>InvocationHandler接口，接口中定义了一个invoke方法，invoke方法中第一个参数表示代理类，第二个参数指被代理的方法，args指该方法的参数数组。这个抽象方法会在代理类中动态实现。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface InvocationHandler &#123;</div><div class="line">    public Object invoke(Object proxy, Method method, Object[] args)</div><div class="line">        throws Throwable;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Proxy：该类为动态代理类，其中的newProxyInstance方法返回一个代理类实例，返回后的代理类可以被当做代理类使用，可使用被代理类的在接口中声明过的方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public static Object newProxyInstance(ClassLoader loader,</div><div class="line">                                          Class&lt;?&gt;[] interfaces,</div><div class="line">                                          InvocationHandler h)</div><div class="line">        throws IllegalArgumentException</div><div class="line">    &#123;</div><div class="line">        Objects.requireNonNull(h);</div><div class="line"></div><div class="line">        final Class&lt;?&gt;[] intfs = interfaces.clone();</div><div class="line">        final SecurityManager sm = System.getSecurityManager();</div><div class="line">        if (sm != null) &#123;</div><div class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /*</div><div class="line">         * Look up or generate the designated proxy class.</div><div class="line">         */</div><div class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</div><div class="line"></div><div class="line">        /*</div><div class="line">         * Invoke its constructor with the designated invocation handler.</div><div class="line">         */</div><div class="line">        try &#123;</div><div class="line">            if (sm != null) &#123;</div><div class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</div><div class="line">            final InvocationHandler ih = h;</div><div class="line">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</div><div class="line">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</div><div class="line">                    public Void run() &#123;</div><div class="line">                        cons.setAccessible(true);</div><div class="line">                        return null;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">            return cons.newInstance(new Object[]&#123;h&#125;);</div><div class="line">        &#125; catch (IllegalAccessException|InstantiationException e) &#123;</div><div class="line">            throw new InternalError(e.toString(), e);</div><div class="line">        &#125; catch (InvocationTargetException e) &#123;</div><div class="line">            Throwable t = e.getCause();</div><div class="line">            if (t instanceof RuntimeException) &#123;</div><div class="line">                throw (RuntimeException) t;</div><div class="line">            &#125; else &#123;</div><div class="line">                throw new InternalError(t.toString(), t);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (NoSuchMethodException e) &#123;</div><div class="line">            throw new InternalError(e.toString(), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="动态代理实现步骤"><a href="#动态代理实现步骤" class="headerlink" title="动态代理实现步骤"></a>动态代理实现步骤</h2><ol>
<li>创建一个实现接口InvocationHandler的类，实现invoke方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class TimeHandler implements InvocationHandler&#123;</div><div class="line"></div><div class="line">    private Object target;</div><div class="line"></div><div class="line">    public TimeHandler(Object target) &#123;</div><div class="line">        this.target = target;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     *</div><div class="line">     * @param proxy 被代理的对象</div><div class="line">     * @param method 被代理对象的方法</div><div class="line">     * @param args 被代理对象的方法的参数</div><div class="line">     * @return Object对象，方法的返回值</div><div class="line">     * @throws Throwable</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class="line">        System.out.println(&quot;time begin&quot;);</div><div class="line">        method.invoke(target);</div><div class="line">        System.out.println(&quot;time end&quot;);</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>创建被代理的类以及接口(Car以及Moveable)</li>
<li>调用Proxy的静态方法，创建一个代理类</li>
<li>通过代理调用方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Car car = new Car();</div><div class="line"></div><div class="line">        InvocationHandler h = new TimeHandler(car);</div><div class="line">        Class&lt;?&gt; cls = car.getClass();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * loader：类加载器</div><div class="line">         * interfaces：实现接口</div><div class="line">         * h ：invocationHandler</div><div class="line">         */</div><div class="line">        Moveable m = (Moveable) Proxy.newProxyInstance(cls.getClassLoader(), cls.getInterfaces(), h);</div><div class="line"></div><div class="line">        m.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="JDK动态代理与CGLIB动态代理的区别"><a href="#JDK动态代理与CGLIB动态代理的区别" class="headerlink" title="JDK动态代理与CGLIB动态代理的区别"></a>JDK动态代理与CGLIB动态代理的区别</h2><table>
<thead>
<tr>
<th>jdk动态代理</th>
<th>CGLIB动态代理</th>
</tr>
</thead>
<tbody>
<tr>
<td>只能代理实现了接口的类</td>
<td>针对类来实现代理</td>
</tr>
<tr>
<td>没有实现接口的类不能实现JDK动态代理</td>
<td>对指定目标类产生一个子类，通过方法拦截技术拦截所有父类方法调用</td>
</tr>
<tr>
<td>JDK动态代理利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvocationHandler来处理</td>
<td>cglib是利用asm开源包，对代理对象的class文件加载进来，通过修改其字节码生成子类来处理</td>
</tr>
</tbody>
</table>
<h2 id="模拟JDK动态代理的实现"><a href="#模拟JDK动态代理的实现" class="headerlink" title="模拟JDK动态代理的实现"></a>模拟JDK动态代理的实现</h2><p>实现功能，通过Proxy的newproxyInstance返回代理对象<br>1、声明一段源码，动态产生代理<br>2、编译源码，产生新的类<br>3、将这个类load到内存中，产生一个新的对象<br>4、return代理对象</p>
<p>handler:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package proxy;</div><div class="line"></div><div class="line">import java.lang.reflect.Method;</div><div class="line"></div><div class="line">public interface InvocationHandler &#123;</div><div class="line">    public void invoke(Object o, Method m);</div><div class="line">&#125;</div><div class="line"></div><div class="line">package proxy;</div><div class="line"></div><div class="line">import java.lang.reflect.InvocationTargetException;</div><div class="line">import java.lang.reflect.Method;</div><div class="line"></div><div class="line">public class TimeHandler implements InvocationHandler&#123;</div><div class="line"></div><div class="line">    private Object target;</div><div class="line"></div><div class="line">    public TimeHandler(Object target) &#123;</div><div class="line">        this.target = target;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void invoke(Object o, Method m) &#123;</div><div class="line">        try &#123;</div><div class="line">            long starttime = System.currentTimeMillis();</div><div class="line">            System.out.println(&quot;汽车开始行驶....&quot;);</div><div class="line">            m.invoke(target);</div><div class="line">            long endtime = System.currentTimeMillis();</div><div class="line">            System.out.println(&quot;汽车结束行驶....  汽车行驶时间：&quot;+ (endtime - starttime) + &quot;毫秒！&quot;);</div><div class="line">        &#125; catch (IllegalAccessException | InvocationTargetException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>proxy:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public class Proxy &#123;</div><div class="line"></div><div class="line">    public static Object newProxyInstance(Class infce, InvocationHandler h) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</div><div class="line">        //创建源码</div><div class="line">        String rt = &quot;\r\n&quot;;</div><div class="line">        String methodStr = &quot;&quot;;</div><div class="line">        for(Method m : infce.getMethods())&#123;</div><div class="line">            methodStr += &quot;	@Override&quot; + rt +</div><div class="line">                    &quot;	public void &quot; + m.getName() + &quot;() &#123;&quot; + rt +</div><div class="line">                    &quot;  try&#123;&quot; + rt +</div><div class="line">                    &quot;  Method md = &quot; + infce.getName() + &quot;.class.getMethod(\&quot;&quot;</div><div class="line">                    + m.getName() + &quot;\&quot;);&quot; + rt +</div><div class="line">                    &quot;  h.invoke(this,md);&quot; +rt+</div><div class="line">                    &quot;  &#125;catch(Exception e)&#123; e.printStackTrace();&#125;&quot; + rt +</div><div class="line">                    &quot;	&#125;&quot; ;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String str =</div><div class="line">                &quot;package proxy;&quot; + rt +</div><div class="line">                        &quot;import java.lang.reflect.Method;&quot; + rt +</div><div class="line">                        &quot;import proxy.InvocationHandler;&quot; +  rt+</div><div class="line">                        &quot;public class $Proxy0 implements &quot; + infce.getName() + &quot; &#123;&quot; + rt +</div><div class="line">                        &quot;	public $Proxy0(InvocationHandler h) &#123;&quot; + rt +</div><div class="line">                        &quot;		this.h = h;&quot; + rt +</div><div class="line">                        &quot;	&#125;&quot; + rt +</div><div class="line">                        &quot;  private InvocationHandler h;&quot; + rt+</div><div class="line">                        methodStr + rt +</div><div class="line">                        &quot;&#125;&quot; ;</div><div class="line">        String fileName = System.getProperty(&quot;user.dir&quot;) + &quot;/out/production/Design_Patterns_new/proxy/$Proxy0.java&quot;;</div><div class="line">        File file = new File(fileName);</div><div class="line">        FileUtils.writeStringToFile(file, str);</div><div class="line"></div><div class="line">        //编译源码</div><div class="line">        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">        StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);</div><div class="line">        Iterable units = fileManager.getJavaFileObjects(fileName);</div><div class="line">        //编译任务</div><div class="line">        JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, null, null, null, units);</div><div class="line">        //执行任务</div><div class="line">        task.call();</div><div class="line">        fileManager.close();</div><div class="line"></div><div class="line">        //load到内存</div><div class="line">        ClassLoader loader = ClassLoader.getSystemClassLoader();</div><div class="line">        Class&lt;?&gt; c = loader.loadClass(&quot;proxy.$Proxy0&quot;);</div><div class="line"></div><div class="line">        Constructor constructor = c.getConstructor(InvocationHandler.class);</div><div class="line">        return constructor.newInstance(h);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/25/算法之全排列和全组合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cdx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/算法之全排列和全组合/" itemprop="url">算法-全排列和全组合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-25T16:55:40+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/algorithms/" itemprop="url" rel="index">
                    <span itemprop="name">algorithms</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul>
<li><p>输入一个字符串，求字符串包含元素（含重复，比如aab的情况）的所有排列可能。</p>
</li>
<li><p>例如：输入abc,所有排列组合包括: abc, acb, bac, bca, cab, cba。</p>
</li>
</ul>
<h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><ul>
<li><p>思路：如果输入为abcdef，则首先确定排列的第一个字母，有6中可能，如果选定a,则其后接bcdef的全排列，明显适用于递归结题。结题思路为第一个字母分别选定所有可能的情况，然后对剩下的字母进行递归。递归终止条件为选定的字母的下标为字符串长度-1。</p>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class AllSort &#123;</div><div class="line">    private static ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</div><div class="line">        String str = br.readLine();</div><div class="line">        Permutation(str.toCharArray(), str.length(), 0);</div><div class="line">        System.out.println(list.toString());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void Permutation(char[] chars, int strLen, int curIndex) &#123;</div><div class="line">        //如果到最后一个数，将排好的加入到list中</div><div class="line">        if (curIndex == strLen - 1) &#123;</div><div class="line">            list.add(new String(chars));</div><div class="line">        &#125; else &#123;</div><div class="line">            for (int i = curIndex; i &lt;= strLen - 1; i++) &#123;</div><div class="line">                //去重，避免相同数字的交换造成最终结果存在重复</div><div class="line">                if (i == curIndex || chars[i] != chars[curIndex]) &#123;</div><div class="line">                    //依次交换开头字母与后面的进行递归</div><div class="line">                    Swap(chars, i, curIndex);</div><div class="line">                    Permutation(chars, strLen, curIndex + 1);</div><div class="line">                    Swap(chars, i, curIndex);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void Swap(char[] chars, int i, int curIndex) &#123;</div><div class="line">        char tmp = chars[i];</div><div class="line">        chars[i] = chars[curIndex];</div><div class="line">        chars[curIndex] = tmp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="字典序法"><a href="#字典序法" class="headerlink" title="字典序法"></a>字典序法</h2><ul>
<li>思想：将输入排序，如输入为1234，则其最小值为1234，然后下一次加入的值为除了1234以外，1,2,3,4组成的最小的值。获取方法为从末尾找第一个从右向左不递增的数a，然后找到从末尾开始从右向左第一个大于a的数，并将这两个数交换次序。然后将原来a的位置之后的字符串反序。也就是说1234，的下一个为1243，在下一个为1324..直到字符串从右向左递增为止。</li>
</ul>
<p>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class AllSort &#123;</div><div class="line">    private static ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</div><div class="line">        String str = br.readLine();</div><div class="line">        PermutationWithDictionary(str.toCharArray(), str.length());</div><div class="line">        System.out.println(list.toString());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void Swap(char[] chars, int i, int curIndex) &#123;</div><div class="line">        char tmp = chars[i];</div><div class="line">        chars[i] = chars[curIndex];</div><div class="line">        chars[curIndex] = tmp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void PermutationWithDictionary(char[] chars, int strLen) &#123;</div><div class="line">        //对字符数组进行排序</div><div class="line">        Arrays.sort(chars);</div><div class="line"></div><div class="line">        while (true) &#123;</div><div class="line">            int j;</div><div class="line">            int index = 0;</div><div class="line">            //找到从右向左第一个不是非递增元素</div><div class="line">            for (j = strLen - 2; j &gt;= 0; j--) &#123;</div><div class="line">                if (chars[j] &lt; chars[j+1])&#123;</div><div class="line">                    index = j;</div><div class="line">                    break;</div><div class="line">                &#125; else if (j == 0)&#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            //与从右向左第一个大于这个元素的元素交换</div><div class="line">            for (j = strLen - 1; j &gt;= 0; j--) &#123;</div><div class="line">                if (chars[j] &gt; chars[index]) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            //交换这两个值</div><div class="line">            Swap(chars, index, j);</div><div class="line">            //对非递增元素位置后面的数组进行逆序排序</div><div class="line">            Reverse(chars, index+1);</div><div class="line">            list.add(new String(chars));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void Reverse(char[] chars, int index) &#123;</div><div class="line">        int k = index, j = chars.length-1;</div><div class="line">        while (k &lt; j) &#123;</div><div class="line">            Swap(chars,k,j);</div><div class="line">            k++;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="全组合"><a href="#全组合" class="headerlink" title="全组合"></a>全组合</h1><ul>
<li>题目描述：输入一个字符串，求字符的所有组合。如abc,则输出可能为a,b,c,ab,ac,bc,abc。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class AllCombine &#123;</div><div class="line">    static ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</div><div class="line">        String str = br.readLine();</div><div class="line">        combinetion(str.toCharArray(), str.length());</div><div class="line">        System.out.println(list.toString());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void combinetion(char[] chars, int length) &#123;</div><div class="line">       if (chars == null || length == 0)</div><div class="line">           return;</div><div class="line">        List&lt;Character&gt; array = new ArrayList&lt;&gt;();</div><div class="line">        //n中情况分别考虑</div><div class="line">        for (int i = 1; i &lt;= length; i++) &#123;</div><div class="line">            combine(chars, 0, i, array);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 从字符数组中index以后挑选number个数加入list</div><div class="line">     * @param chars 输入的字符数组</div><div class="line">     * @param index 开始字符下标</div><div class="line">     * @param number</div><div class="line">     * @param array</div><div class="line">     */</div><div class="line">    private static void combine(char[] chars, int index, int number, List&lt;Character&gt; array) &#123;</div><div class="line">        if (number == 0) &#123;</div><div class="line">            //递归终止条件，判断是为了去重</div><div class="line">            if (!list.contains(array.toString())) &#123;</div><div class="line">                list.add(array.toString());</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (index == chars.length) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //取当前元素，并考察递归选取n-1个元素的情况</div><div class="line">        array.add(chars[index]);</div><div class="line">        combine(chars, index+1, number - 1, array);</div><div class="line">        array.remove((Character) chars[index]);</div><div class="line">        //不取当前元素，考察后面选取n个元素</div><div class="line">        combine(chars, index+1, number, array);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>基于位图：假定元素有n个，则最终结果组合为2^n-1个，我们使用位操作方法：假设元素原本为123，则1表示取该元素，0表示不取该元素。000是没有意义是，则选取的对应如下：<br>001,010,100,011,101,110,111-&gt;a,b,c,bc,ac,ab,abc。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class AllCombine1 &#123;</div><div class="line">    static ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</div><div class="line">        String str = br.readLine();</div><div class="line">        combinetion(str.toCharArray());</div><div class="line">        System.out.println(list.toString());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void combinetion(char[] chars) &#123;</div><div class="line">        if (chars == null || chars.length == 0)</div><div class="line">            return;</div><div class="line">        int len = chars.length;</div><div class="line">        //n=2^len</div><div class="line">        int n = 1&lt;&lt;len;</div><div class="line">        for (int i = 1; i &lt; n; i++) &#123;</div><div class="line">            StringBuilder sb = new StringBuilder();</div><div class="line">            for (int j = 0; j &lt; len; j++) &#123;</div><div class="line">                int temp = i;</div><div class="line">                if ((temp &amp; (1&lt;&lt;j)) != 0)</div><div class="line">                    sb.append(chars[j]);</div><div class="line">            &#125;</div><div class="line">            list.add(sb.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/avatar.gif"
              alt="cdx" />
          
            <p class="site-author-name" itemprop="name">cdx</p>
            <p class="site-description motion-element" itemprop="description">Be a better man!</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">65</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/cdx0312" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:cdxu0312@outlook.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cdx</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
